 <!DOCTYPE html>
<html>
<head>
  <link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#ffffff" id="theme-color-meta">

  
  
  <meta charset="utf-8">
  <title>Brother Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, interactive-widget=resizes-content">

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <script src="firebase-config.js"></script>

  <!-- Preload images for faster UI -->
  <link rel="preload" as="image" href="chat_logo.png">
  <link rel="preload" as="image" href="chat.png">
<!-- Emoji picker -->
<script src="https://cdn.jsdelivr.net/npm/@joeattardi/emoji-button@4.6.2/dist/index.min.js"></script>

<style>

/* Keep input area fully transparent */
#inputArea {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 10px;
  background: transparent;
  border-top: none;
  display: flex;
  flex-direction: column;
  z-index: 30;
}

/* textarea with slight transparent background for visibility */
#inputControls textarea,
#replyInput {
  background: rgba(255, 255, 255, 0.85);  /* almost solid white */
  border: 1px solid rgba(0,0,0,0.1);
  border-radius: 20px;
  padding: 8px 12px;
  color: #000;
  font-size: 15px;
  line-height: 1.3;
  flex: 1;
  resize: none;
}

/* buttons with subtle background */
#inputControls button,
#gifBtn, #attachBtn, #sendBtn {
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid rgba(0,0,0,0.1);
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: grey;
}

/* reply preview */
.reply-preview {
  background: rgba(255, 255, 255, 0.85);
  border-left: 4px solid #4caf50;
  color: #333;
  border-radius: 6px;
  font-size: 13px;
  margin-bottom: 6px;
  padding: 6px 10px;
}

/* dark mode overrides */
body.dark #inputControls textarea,
body.dark #replyInput {
  background: rgba(42,42,42,0.9);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.1);
}

body.dark #inputControls button {
  background: rgba(42,42,42,0.9);
  border: 1px solid rgba(255,255,255,0.1);
  color: #fff;
}

body.dark .reply-preview {
  background: rgba(42,42,42,0.85);
  color: #e5e5e5;
}



/* Compact WhatsApp-like icon buttons for GIF & Attach */
#inputControls {
  display: flex;
  align-items: center;   /* center vertically */
  gap: 2px;              /* small spacing between controls */
}

#inputControls button.icon-btn,
#gifBtn, /* fallback selector if you don't change HTML */
#attachBtn {
  width: 36px;
  height: 36px;
  margin-right: 1px;
  border-radius: 50%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;      /* icon / emoji size */
  line-height: 1;
  flex: 0 0 36px;       /* don't grow or shrink */
  cursor: pointer;
  border: 1px solid rgba(0,0,0,0.06);
  background: #ffffff;
  box-shadow: 0 1px 3px rgba(16,24,40,0.06);
  transition: transform 120ms ease, box-shadow 120ms ease;
}

/* make sure textarea doesn’t push icons out on small screens */
#inputControls textarea {
  flex: 1 1 auto;    /* textarea grows, icons keep fixed size */
  margin: 0;
}

/* slightly shrink the 'Send' button so it balances with icons */
#inputControls button#sendBtn {
  padding: 4px 6px;
  border-radius: 18px;
  margin-left: 2px;
  flex: 0 0 auto;
}



/* GIF picker modal */
#gifModal {
  position: fixed;
  left: 0; right: 0; top: 0; bottom: 0;
  display: none;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(4px);
  z-index: 9999;
}
#gifModal .panel {
  width: 92%;
  max-width: 720px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 12px 40px rgba(0,0,0,0.25);
  padding: 12px;
  max-height: 80vh;
  overflow: auto;
}
#gifModal .search {
  display:flex;
  gap:8px;
  margin-bottom:10px;
}
#gifResults {
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}
.gif-thumb {
  width: 30%;
  max-width: 160px;
  border-radius: 8px;
  cursor: pointer;
  object-fit: cover;
}
@media (max-width:480px){ .gif-thumb{ width: 48%; } }
</style>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html { height: 100%; font-family: 'Segoe UI', sans-serif; background: #f2f3f7; overflow-x: hidden; }

    #list, #chat { display: none; height: 100%; width: 100%; }
    #list.active, 
    
    #chat.active {
  display: flex;
  flex-direction: column;
  height: 100%;
}

    #messages { overflow-x: hidden; }

    #inboxHeader {
      padding: 25px 20px 10px;
      font-size: 28px;
      font-weight: 700;
      
      background: #ffffff;
      background-clip: text;
      color: transparent;
      background-image: linear-gradient(to right, #2563eb, #7c3aed);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      border-bottom: 1px solid #e5e7eb;
    }

    #searchBox {
      margin: 12px 20px 0;
      padding: 10px 15px;
      border-radius: 30px;
      border: 1px solid #ccc;
      outline: none;
      font-size: 15px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.04);
    }
    


    #list {
      background: linear-gradient(to bottom right, #f4f6f9, #e2e6ec);
      overflow-y: auto;
    }
    
    
    

    .chat-item {
      position: relative;
      background: #ffffff;
      padding: 15px 20px;
      margin: 12px 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .chat-item:hover { background: #e0ecff; transform: translateY(-2px); }
    .chat-name { font-size: 16px; font-weight: 600; color: #333; }
    .chat-preview { font-size: 14px; color: #666; margin-top: 4px; }
    .chat-time {
      position: absolute; right: 20px; top: 18px;
      font-size: 12px; color: #888;
    }
    


    #chatHeader {
      flex-shrink: 0;
      background: #FFFFFF; color: #000000;
      padding: 4px; font-weight: 400; font-size: 18px;
      border-bottom: 1px solid #D2D0CEEB;
      display: flex; align-items: center;
    }

    #messages {
      flex: 1; padding: 10px; overflow-y: auto; display: flex; flex-direction: column;
      background-color: #BBBBBB;
      background-size: 110% 110%;
      background-repeat: no-repeat;
      background-position: center;
    }





/* Common bubble style */
.bubble {
  
  white-space: pre-wrap; 
  position: relative;
  margin: 6px 0;
  padding: 12px 16px;
  border-radius: 16px;
  max-width: 75%;
  font-size: 16px;
  line-height: 1.4;
  word-wrap: break-word;
}

/* User bubble (left) */
.from-user {
  background: #ffffff;
  align-self: flex-start;
  border-bottom-left-radius: 4px; /* smaller radius for tail corner */
}

/* Brother bubble (right) */
.from-brother {
  background: #dcf8c6;
  align-self: flex-end;
  border-bottom-right-radius: 4px; /* smaller radius for tail corner */
}

/* Tail for user bubble (left) */
.from-user::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0; /* start from left corner */
  width: 12px;
  height: 12px;
  background: #ffffff;
  border-bottom-left-radius: 4px;
  clip-path: polygon(0 0, 0% 100%, 100% 100%);
}

/* Tail for brother bubble (right) */
.from-brother::after {
  content: '';
  position: absolute;
  bottom: 0;
  right: 0; /* start from right corner */
  width: 12px;
  height: 12px;
  background: #dcf8c6;
  border-bottom-right-radius: 4px;
  clip-path: polygon(100% 0, 0% 100%, 100% 100%);
}




    .msg-time {
      font-size: 10px; color: #555; margin-top: 4px; align-self: flex-end;
    }

    .reply-box {
      font-size: 13px;
      color: #555;
      background: rgba(0,0,0,0.05);
      padding: 6px 10px;
      border-left: 4px solid #888;
      margin-bottom: 6px;
      border-radius: 4px;
    }

  #inputArea {
  flex-shrink: 0;
  display: flex;
  padding: 10px;
  background: transparent; /* ✅ transparent background */
  border-top: none;        /* ✅ no border */
  flex-direction: column;
  backdrop-filter: none;   /* ✅ no blur, fully clear */
}

    .reply-preview {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f0f0f0;
      padding: 6px 10px;
      border-left: 4px solid #4caf50;
      border-radius: 6px;
      font-size: 13px;
      margin-bottom: 6px;
      color: #333;
    }
    .reply-preview-text {
      flex: 1;
      white-space: normal;
      overflow: hidden;
      max-height: 3.2em;
    }
    .reply-preview button {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: #888;
    }
    
    .date-divider {
  text-align: center;
  margin: 10px auto;
  padding: 6px 14px;
  border-radius: 14px;
  font-size: 13px;
  font-weight: 600;
  color: #555;
  background: #e5e7eb;
  display: inline-block;
}

/* Dark mode divider */
body.dark .date-divider {
  background: #2a2a2a;
  color: #ddd;
}
  
  body.dark .from-user::after {
  background: #2a2a2a; /* matches dark bubble */
}
body.dark .from-brother::after {
  background: #056162; /* matches dark brother bubble */
}
    
    #inputControls { display: flex; align-items: flex-end; }
    #inputControls textarea {
      flex: 1;
      padding: 8px 12px;
      
      border: 1px solid #979595;
      border-radius: 20px;
      resize: none;
      overflow: hidden;
      font-size: 15px;
      line-height: 1.3;
      max-height: 80px;
    }
    #inputControls textarea:focus {
      border-color: #979595;
      outline: none;
    }
    #inputControls button {
      margin-left: 5px; 
      border: 1px solid #979595;
      background: #fff; color: #fff; border-radius: 20px;
    }

    .reply-arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      transition: opacity 0.2s ease;
      font-size: 18px;
      color: #4caf50;
    }
    .from-user .reply-arrow { left: -28px; }
    .from-brother .reply-arrow { right: -28px; }
    .bubble.show-arrow .reply-arrow { opacity: 1; }
    
    
    
    
    /* 🌙 DARK MODE FIX */
body.dark {
  background: #121212 !important;
  color: #e5e5e5 !important;
}



/* 🌙 Dark mode for search bar */
body.dark #searchBox {
  background: #2a2a2a !important;
  color: #ffffff !important;
  border: 1px solid #444 !important;
}

body.dark #searchBox::placeholder {
  color: #aaaaaa !important;
}



/* Inbox header */
body.dark #inboxHeader {
  background-image: linear-gradient(to right, #9333ea, #3b82f6) !important;
  color: #ffffff !important;
}




/* Inbox chat items (dark mode) */
body.dark .chat-item {
  background: #2a2a2a;          /* dark gray card */
  color: #fff;                  /* default text = white */
}

body.dark .chat-item .chat-name {
  color: #ffffff;               /* pure white for names */
}

body.dark .chat-item .chat-preview {
  color: #bbbbbb;               /* softer gray for preview */
}

body.dark .chat-item .chat-time {
  color: #888888;               /* dim gray for timestamp */
}


/* Chat list */
body.dark #list {
  background: #1e1e1e !important;
}

body.dark .chat-item {
  background: #2a2a2a !important;
  color: #ffffff !important;   /* chat list names = pure white */
}

body.dark .chat-item:hover {
  background: #333 !important;
}

body.dark .chat-item small,
body.dark .chat-item .preview {
  color: #cccccc !important; /* slightly brighter gray */
}

/* Chat header */
body.dark #chatHeader {
  background: #1e1e1e !important;
  color: #ffffff !important;
}

/* Messages area */
body.dark #messages {
  background: #121212 !important;
}

/* User bubbles */
body.dark .from-user {
  background: #2a2a2a !important;
  color: #ffffff !important;
}

/* Brother bubbles */
body.dark .from-brother {
  background: #056162 !important;
  color: #ffffff !important;
}

/* Chat bubble timestamp */
body.dark .msg-time {
  font-size: 11px !important;
  color: #ffffff !important;   /* full white */
  text-align: right !important;
  margin-top: 4px !important;
  display: block !important;
}


/* Reply box (dark mode) */
body.dark .reply-box {
  color: #e5e5e5;
  background: rgba(255,255,255,0.08);  /* soft white overlay */
  border-left: 3px solid #3b82f6;      /* nice blue accent */
}


    /* Reply preview (dark mode) */
body.dark .reply-preview {
  background: rgba(255, 255, 255, 0.08);  /* soft overlay on dark */
  border-left: 4px solid #3b82f6;         /* blue accent */
  color: #e5e5e5;
}

    /* Toggle button base */
#darkModeToggle {
  margin-left: auto;
  margin-right: 10px;
  padding: 6px 14px;
  border-radius: 20px;
  border: none;
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  transition: all 0.3s ease;
}

/* Light mode toggle */
body:not(.dark) #darkModeToggle {
background: #FFFFFF;   /* light gray */
  color: #111;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);

  
}


/* Dark mode toggle */
body.dark #darkModeToggle {
  background: #2a2a2a;   /* dark gray */
  color: #facc15;        /* warm yellow (sun icon) */
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

/* Hover effect */
#darkModeToggle:hover {
  transform: scale(1.05);
}
    

    
    
    
    
    
    
  </style>
</head>
<body>
  
  <audio id="sendSound" src="send.mp3" preload="auto"></audio>
<audio id="receiveSound" src="receive.mp3" preload="auto"></audio>
  <div id="list" class="active">
    <div id="inboxHeader" style="margin-left: 10px;">S talk</div>
    <input type="text" id="searchBox" placeholder="Search chats..." oninput="filterChats()" />
    <div id="chatList"></div>
  </div>

  <div id="chat">
    <div id="chatHeader">
      
<img id="userLogo" src="chat_logo.png"
     style="width:50px; height:50px; border:3px solid orange; border-radius:50%;
     margin-left: 5px;" />

      
<div style="margin-left:10px; display:flex; flex-direction:column;">
  <div id="chatTitle">Babu😘</div>
  <div id="typingIndicator" style="font-size:12px; color:gray; display:none;">
    typing…
  </div>
</div>
      <button id="darkModeToggle" >
  🌙
</button>
    </div>
    <div id="messages"></div>
<div id="inputArea">
  <div id="replyPreviewContainer"></div>
  <div id="inputControls">
    
    <button id="gifBtn" title="GIF" >
      
      
      
      
<svg xmlns="http://www.w3.org/2000/svg" 
     width="24" height="24" 
     fill="none" 
     stroke="grey" 
     stroke-width="2" 
     stroke-linecap="round" 
     stroke-linejoin="round">

  <!-- outer rounded square -->
  <rect x="3" y="3" width="18" height="18" rx="6" ry="6"/>

  <!-- eyes -->
  <circle cx="9" cy="10" r="1"/>
  <circle cx="15" cy="10" r="1"/>

  <!-- mouth with folded corner -->
  <path d="M8 15h4c1.5 0 3 1 3 2v1l3-3"/>
</svg>
      
      
    </button>
    <!-- optional file attach (works locally; to upload to Firebase Storage add storage SDK) -->
    <input id="attachFile" type="file" accept="image/*,video/gif" style="display:none" />
    <button id="attachBtn" title="Attach">
  <svg xmlns="http://www.w3.org/2000/svg" 
       width="24" height="24" 
       fill="none" 
       stroke="grey" 
       stroke-width="2" 
       stroke-linecap="round" 
       stroke-linejoin="round">
    <path d="M21.44 11.05l-9.19 9.19a5 5 0 0 1-7.07-7.07l9.19-9.19a3.5 3.5 0 0 1 4.95 4.95l-9.19 9.19a2 2 0 0 1-2.83-2.83l8.48-8.48" />
  </svg>

      
      
    </button>
    
    <textarea id="replyInput" placeholder="Type" rows="1" style="flex:1"></textarea>
    <button id="sendBtn">
      
  <!-- Up Arrow Icon -->
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="grey" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
    <path d="M12 19V5"></path>
    <path d="M5 12l7-7 7 7"></path>
  </svg>

    </button>
  </div>
</div>

<!-- GIF modal -->
<div id="gifModal" aria-hidden="true">
  <div class="panel">
    <div class="search">
      <input id="gifSearch" placeholder="Search GIFs (GIPHY)" style="flex:1;padding:8px;border-radius:8px;border:1px solid #ccc" />
      <button id="gifSearchBtn">Search</button>
      <button id="gifCloseBtn">Close</button>
    </div>
    <div id="gifResults"></div>
  </div>
</div>
  </div>
  
  
  
  <script>
  document.addEventListener("DOMContentLoaded", function() {
    if (!localStorage.getItem("authenticated")) {
      document.body.style.filter = "blur(8px)";
      
      setTimeout(() => {
        const raw = prompt("Enter password to access:");
        const entered = raw === null ? '' : raw.trim();
        
        // CORRECT encoded value for this scheme:
        // scheme: reverse the real password, then Base64-encode that reversed string.
        // For real password "8990" -> reversed "0998" -> base64 => "MDk5OA=="
        const encoded = "MDk5OA==";
        
        function decodePassword(enc) {
          try {
            const decoded = atob(enc); // Base64 decode -> "0998"
            return decoded.split('').reverse().join(''); // reverse -> "8990"
          } catch (e) {
            return null;
          }
        }
        
        const expected = decodePassword(encoded);
        
        if (entered && expected && entered === expected) {
          localStorage.setItem("authenticated", "true");
          alert("Access granted ✅");
          document.body.style.filter = "none";
        } else {
          alert("Wrong password ❌");
          location.reload();
        }
      }, 50);
    }
  });
</script>
 
 

<script>
const db = firebase.database();

const listEl = document.getElementById('list');
const chatEl = document.getElementById('chat');
const chatList = document.getElementById('chatList');
const messagesEl = document.getElementById('messages');
const replyInput = document.getElementById('replyInput');


// ---- Presence in the SAME typingIndicator div ----
let statusListener = null; // holds { ref, callback } for cleanup

function formatLastSeen(ts) {
  if (!ts) return 'Last seen: unknown';
  const d = new Date(Number(ts));
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today); yesterday.setDate(today.getDate() - 1);

  const timeStr = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });

  if (d.toDateString() === today.toDateString()) return 'Last seen today at ' + timeStr;
  if (d.toDateString() === yesterday.toDateString()) return 'Last seen yesterday at ' + timeStr;
  return 'Last seen ' + d.toLocaleDateString([], { day: 'numeric', month: 'short', year: 'numeric' }) + ' at ' + timeStr;
}

function subscribeToPresenceFor(chatKey) {
  // remove previous listener
  if (statusListener && statusListener.ref) {
    try { statusListener.ref.off('value', statusListener.callback); } catch(e) {}
    statusListener = null;
  }

  const typingEl = document.getElementById('typingIndicator');
  const userLogo = document.getElementById('userLogo');
  if (!typingEl) return;

  const statusRef = db.ref('status/' + chatKey);
  const callback = snap => {
    const statusObj = snap.val();
    let typing = false;
    let state = 'offline';
    let last_changed = null;

    if (statusObj) {
      if (typeof statusObj === 'object') {
        typing = !!statusObj.typing;
        state = statusObj.state || state;
        last_changed = statusObj.last_changed || null;
      } else if (typeof statusObj === 'string') {
        state = statusObj;
      }
    }

    // Show in same div
    if (typing) {
      typingEl.style.display = 'block';
      typingEl.textContent = 'typing…';
      typingEl.style.color = ''; // inherit or keep your css
      if (userLogo) userLogo.style.border = '3px solid green';
    } else {
      // not typing: online or last seen
      typingEl.style.display = 'block';
      if (state === 'online') {
        typingEl.textContent = 'online';
        typingEl.style.color = ''; // use CSS color or inline if you like
        if (userLogo) userLogo.style.border = '3px solid green';
      } else {
        typingEl.textContent = formatLastSeen(last_changed);
        typingEl.style.color = '';
        if (userLogo) userLogo.style.border = '3px solid orange';
      }
    }
  };

  statusListener = { ref: statusRef, callback };
  statusRef.on('value', callback);
}

// Ensure we subscribe when opening a chat
const oldOpenChat_forPresence = openChat;
openChat = function(key) {
  oldOpenChat_forPresence(key);
  // key in your app is the DB key (looks like you already use underscores)
  subscribeToPresenceFor(key);
};

// Optional: cleanup listener when going back to inbox
const oldPop = window.onpopstate;
window.addEventListener('popstate', function(event) {
  // remove presence listener when leaving chat view
  if (statusListener && statusListener.ref) {
    try { statusListener.ref.off('value', statusListener.callback); } catch(e) {}
    statusListener = null;
  }
  // also hide the typingIndicator when leaving
  const typingEl = document.getElementById('typingIndicator');
  if (typingEl) typingEl.style.display = 'none';

  if (typeof oldPop === 'function') oldPop(event);
});

/* ===== improved presence helper =====
   Replace your current setPresence(...) function with this.
*/




let _presenceHeartbeat = null;


function adjustMessagesPadding(){
  const input = document.getElementById('inputArea');
  const messages = document.getElementById('messages');
  if(!input || !messages) return;
  // add extra spacing for safe area
  const extra = 16;
  messages.style.paddingBottom = (input.offsetHeight + extra) + 'px';
}

// run on load and whenever window resizes or input changes
window.addEventListener('load', adjustMessagesPadding);
window.addEventListener('resize', adjustMessagesPadding);

// if your textarea auto-resizes, call adjustMessagesPadding on input
const txt = document.getElementById('replyInput');
if(txt){
  txt.addEventListener('input', function(){ 
    // if you have an auto-height script, run it first then adjust
    setTimeout(adjustMessagesPadding, 60);
  });
}




function setPresence(userKey) {
  if (!userKey) return;
  const userStatusRef = db.ref('status/' + userKey);

  const makeOffline = () => ({
    state: 'offline',
    last_changed: Date.now(),
  });
  const makeOnline = () => ({
    state: 'online',
    last_changed: Date.now(),
  });

  // Clear any previous heartbeat
  if (_presenceHeartbeat) {
    clearInterval(_presenceHeartbeat);
    _presenceHeartbeat = null;
  }

  // Listen for connection status to RTDB servers
  db.ref('.info/connected').on('value', (snap) => {
    if (snap.val() === true) {
      // Ensure server will set offline when this client truly disconnects
      userStatusRef.onDisconnect().set(makeOffline()).catch(()=>{});

      // Immediately mark online
      userStatusRef.set(makeOnline()).catch(()=>{});

      // Start heartbeat to continually update last_changed so server
      // will not mark connection idle. 10s is a good compromise.
      if (!_presenceHeartbeat) {
        _presenceHeartbeat = setInterval(() => {
          userStatusRef.update({ last_changed: Date.now(), state: 'online' }).catch(()=>{});
        }, 5000);
      }
    } else {
      // not connected -> clear heartbeat
      if (_presenceHeartbeat) {
        clearInterval(_presenceHeartbeat);
        _presenceHeartbeat = null;
      }
    }
  });

  // Best-effort attempt to mark offline on page unload using beacon
  window.addEventListener('unload', () => {
    try {
      // Try to use onDisconnect as main line; sendBeacon is fallback
      const payload = JSON.stringify(makeOffline());
      // Using REST endpoint would be ideal, but as a fallback use sendBeacon to a small cloud function
      // Here we attempt a tiny write via navigator.sendBeacon to a special endpoint if you have one.
      // Fallback: attempt a synchronous set (sometimes fails)
      userStatusRef.set(makeOffline());
    } catch (e) {
      // ignore
    }
  });
}

// Call it like this:
setPresence("brother");




let typingTimeout;

replyInput.addEventListener("input", () => {
  // Mark brother as typing
  db.ref("status/brother/typing").set(true);
  
  // Reset after 2 seconds of no input
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    db.ref("status/brother/typing").set(false);
  }, 2000);
});
const searchBox = document.getElementById('searchBox');
const replyPreviewContainer = document.getElementById('replyPreviewContainer');

// Instead of listening to your own typing status:
const typingIndicator = document.getElementById('typingIndicator');

// use a single place to derive the DB key from the email
const currentUserEmail = "mahekj05@gmail.com";
const currentUserKey = currentUserEmail.replace(/\./g, '_');

// listen for typing under the same key used elsewhere
db.ref('status/' + currentUserKey + '/typing').on('value', (snapshot) => {
  const isTyping = snapshot.val();
  typingIndicator.style.display = isTyping ? 'block' : 'none';
});

let currentKey = null;
let childListener = null;
let allChats = [];
let replyToText = null;
let searchTimeout;

// --- Infinite scroll ---
let oldestLoadedKey = null;
let isLoadingOlder = false;
let reachedBeginning = false;

// --- Store messages ---
let messageStore = {};
let lastRenderedDate = null; 
let lastRenderedMsgTime = 0;
let initialLoadDone = false;
// global tracker// *** FIX: Track last date divider ***

// --- Cache helpers ---
function cacheChats(data) { localStorage.setItem('cachedChats', JSON.stringify(data)); }
function getCachedChats() { const c = localStorage.getItem('cachedChats'); return c ? JSON.parse(c) : null; }
function cacheMessages(chatKey, data) { localStorage.setItem('chat_' + chatKey, JSON.stringify(data)); }


function getCachedMessages(chatKey) { const c = localStorage.getItem('chat_' + chatKey); return c ? JSON.parse(c) : null; }

// --- Load cached chats ---
const cached = getCachedChats();
if (cached) renderChats(cached);

db.ref('chats').on('value', snapshot => {
  const chats = snapshot.val();
  if (chats) { cacheChats(chats); renderChats(chats); }
});


// use the correct brotherKey
function renderChats(chats) {
  chatList.innerHTML = '';
  allChats = [];
  const sortedKeys = Object.keys(chats).sort((a,b)=>{
    const lastA = Math.max(...Object.keys(chats[a]).map(Number));
    const lastB = Math.max(...Object.keys(chats[b]).map(Number));
    return lastB - lastA;
  });
  sortedKeys.forEach(key=>{
    const messages = chats[key];
    const timestamps = Object.keys(messages).map(Number).sort((a,b)=>a-b);
    const lastMsg = messages[timestamps[timestamps.length-1]];
    const lastTime = new Date(timestamps[timestamps.length-1]).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', hour12:true});
    
    
    const item = document.createElement('div');
    item.className = 'chat-item';
    item.onclick = ()=>openChat(key);
    const name = document.createElement('div'); name.className = 'chat-name'; name.textContent = key.replace(/_/g,'.');
    const preview = document.createElement('div'); preview.className = 'chat-preview'; preview.textContent = lastMsg.text;
    
    const event = new CustomEvent('chatOpened', { detail: key });
window.dispatchEvent(event);
    
    const time = document.createElement('div'); time.className = 'chat-time'; time.textContent = lastTime;
    item.appendChild(name); item.appendChild(preview); item.appendChild(time);
    chatList.appendChild(item);
    allChats.push({ key, element:item, preview:lastMsg.text });
  });
}

// --- Search ---
function filterChats(){
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(()=>{
    const term = searchBox.value.toLowerCase();
    allChats.forEach(chat=>{
      chat.element.style.display =
        chat.key.toLowerCase().includes(term) || chat.preview.toLowerCase().includes(term) ? '' : 'none';
    });
  },200);
}




// --- Date dividers ---
function formatDateSeparator(ts){
  const msgDate = new Date(Number(ts));
  const today = new Date();
  const yesterday = new Date(); yesterday.setDate(today.getDate()-1);
  if(msgDate.toDateString()===today.toDateString()) return "Today";
  else if(msgDate.toDateString()===yesterday.toDateString()) return "Yesterday";
  else return msgDate.toLocaleDateString([], { day:"numeric", month:"short", year:"numeric" });
}

function createDateDivider(label){
  const div = document.createElement("div");
  div.className = "date-divider";
  div.textContent = label;
  return div;
}




function buildMessageBubble(msgKey, val) {
  // create bubble wrapper & classes
  const div = document.createElement('div');
  div.className = 'bubble ' + (val.from === 'user' ? 'from-user' : 'from-brother');
  
  // reply arrow (swipe UI)
  const arrow = document.createElement('div');
  arrow.className = 'reply-arrow';
  arrow.innerHTML = '↩';
  div.appendChild(arrow);
  
  // attach swipe/reply behavior (re-uses your helper)
  attachSwipeHandlers(div, msgKey, val.text || val.url || '');
  
  // reply preview if present
  if (val.replyTo && messageStore[val.replyTo]) {
    const replyDiv = document.createElement('div');
    replyDiv.className = 'reply-box';
    // if the referenced message had text use it, otherwise if media show type
    const ref = messageStore[val.replyTo];
    replyDiv.textContent = ref && ref.text ? ref.text : (ref && ref.type ? '[' + (ref.type || 'media') + ']' : '');
    div.prepend(replyDiv);
  }
  
  // If media (gif/image) -> render image tag, allow optional text underneath
  if (val.type === 'gif' || val.type === 'image' || val.url) {
    const media = document.createElement('img');
    media.style.maxWidth = '260px';
    media.style.maxHeight = '260px';
    media.style.borderRadius = '8px';
    media.style.display = 'block';
    media.style.marginBottom = '6px';
    // prefer val.url; some payloads may include url or mediaUrl
    media.src = val.url || val.mediaUrl || '';
    media.alt = val.type || 'media';
    // add error handler to help debug CORS/missing URL
    media.addEventListener('error', () => {
      const err = document.createElement('div');
      err.style.fontSize = '12px';
      err.style.color = '#b00';
      err.textContent = '[Unable to load media]';
      div.insertBefore(err, media.nextSibling);
    });
    div.appendChild(media);
    if (val.text) {
      const textNode = document.createElement('div');
      textNode.textContent = val.text;
      div.appendChild(textNode);
    }
  } else {
    // regular text-only message
    const textNode = document.createElement('div');
    textNode.textContent = val.text || '';
    div.appendChild(textNode);
  }
  
  // timestamp
  const timeNode = document.createElement('div');
  timeNode.className = 'msg-time';
  timeNode.textContent = new Date(Number(msgKey)).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
  div.appendChild(timeNode);
  
  return div;
}


// ensure the local name points to the same function used in renderMessages
buildMessageBubble = window.buildMessageBubble;

// --- Render messages (fixed) ---
function renderMessages(chatKey, messages) {
  const sortedKeys = Object.keys(messages).map(Number).sort((a, b) => a - b).map(String);
  const fragment = document.createDocumentFragment();
  
  sortedKeys.forEach(msgKey => {
    if (messageStore[msgKey]) return; // already rendered
    const val = messages[msgKey];
    if (!val || (!(val.text) && !(val.type) && !(val.url))) return;
    messageStore[msgKey] = val;
    
    const msgDate = new Date(Number(msgKey));
    const dateLabel = formatDateSeparator(msgKey);
    
    // Date divider
    if (lastRenderedDate !== msgDate.toDateString()) {
      fragment.appendChild(createDateDivider(dateLabel));
      lastRenderedDate = msgDate.toDateString();
    }
    
    const div = buildMessageBubble(msgKey, val);
    fragment.appendChild(div);
    
    // 🔊 Play sound only for new incoming msgs (not history)
    if (initialLoadDone && val.from === "user" && chatKey === currentKey && Number(msgKey) > lastRenderedMsgTime) {
      const snd = document.getElementById("receiveSound");
      if (snd) snd.play().catch(() => {});
    }
    
    // update last seen
    if (Number(msgKey) > lastRenderedMsgTime) {
      lastRenderedMsgTime = Number(msgKey);
    }
  });
  
  messagesEl.appendChild(fragment);
  messagesEl.scrollTop = messagesEl.scrollHeight;
  
  // Mark first load as done
  initialLoadDone = true;
}

function openChat(key){
  listEl.classList.remove('active'); chatEl.classList.add('active');
  
  
  currentKey = key; document.getElementById('chatTitle').textContent="Babu😘";
  history.pushState({screen:"chat"},"Chat");

  messageStore = {};
  lastRenderedDate = null; // *** Reset date tracking when opening a new chat ***
  messagesEl.innerHTML = '';

  const cachedMsgs = getCachedMessages(key);
  if(cachedMsgs) renderMessages(key,cachedMsgs);

  if(childListener) db.ref('chats/'+currentKey).off('value',childListener);
  childListener = db.ref('chats/'+currentKey)
    .on('value', snap=>{
      const msgs = snap.val();
      if(msgs){
        cacheMessages(currentKey,msgs);
        renderMessages(currentKey,msgs);
      }
    });
}

// --- Send reply ---
function sendReply(){
  const text = replyInput.value.trim();
  if(text==='' || !currentKey) return;
  const timestamp = Date.now();
  const message = {text,from:'brother'};
  if(replyToText){message.replyTo = replyToText.msgKey; replyToText=null;}
  
  db.ref('chats/'+currentKey+'/'+timestamp).set(message);
  db.ref("status/brother/typing").set(false); // stop typing

  document.getElementById("sendSound").play();
  
  replyInput.value='';
  replyInput.style.height="auto";
  replyInput.focus();
  replyPreviewContainer.innerHTML='';
}



// --- Swipe & reply handlers ---
function attachSwipeHandlers(bubbleEl,msgKey,text){
  let startX=0,startY=0,currentX=0,dragging=false,vibrated=false;
  bubbleEl.addEventListener('touchstart',e=>{startX=e.touches[0].clientX; startY=e.touches[0].clientY; dragging=true; vibrated=false; bubbleEl.style.transition="none";});
  bubbleEl.addEventListener('touchmove',e=>{
    if(!dragging) return; currentX=e.touches[0].clientX-startX; const dy=e.touches[0].clientY-startY; if(Math.abs(dy)>30) return;
    const offset=Math.sign(currentX)*Math.min(Math.abs(currentX),120);
    bubbleEl.style.transform=`translateX(${offset}px)`;
    if(Math.abs(offset)>50 && !bubbleEl.classList.contains("show-arrow")){
      bubbleEl.classList.add("show-arrow");
      if(!vibrated && navigator.vibrate){navigator.vibrate([80,50,80]);vibrated=true;}
    } else bubbleEl.classList.remove("show-arrow");
  });
  bubbleEl.addEventListener('touchend',()=>{
    dragging=false; bubbleEl.style.transition="transform 0.2s ease"; bubbleEl.classList.remove("show-arrow");
    if(Math.abs(currentX)>80){
      replyToText={msgKey,text};
      replyPreviewContainer.innerHTML=`<div class="reply-preview"><div class="reply-preview-text">${text}</div><button onclick="cancelReply()">✖</button></div>`;
      replyInput.focus();
    }
    bubbleEl.style.transform="translateX(0px)"; currentX=0;
  });
}

function cancelReply(){replyToText=null; replyPreviewContainer.innerHTML=''; replyInput.placeholder='Type a message…';}
replyInput.addEventListener('blur',()=>{if(!replyInput.value && !replyToText) cancelReply();});

// --- Dark mode ---
// --- Dark mode ---
const darkModeToggle = document.getElementById("darkModeToggle");
const themeMeta = document.getElementById("theme-color-meta");

function updateThemeColor() {
  if (document.body.classList.contains("dark")) {
    themeMeta.setAttribute("content", "#121212"); // dark mode color
  } else {
    themeMeta.setAttribute("content", "#F2F2F2"); // light mode color
  }
}




// On load, check saved mode
if (localStorage.getItem("darkMode") === "enabled") {
  document.body.classList.add("dark");
  darkModeToggle.textContent = "☀️";
}
updateThemeColor();

// Toggle button click
darkModeToggle.addEventListener("click", () => {
  document.body.classList.toggle("dark");
  if (document.body.classList.contains("dark")) {
    localStorage.setItem("darkMode", "enabled");
    darkModeToggle.textContent = "☀️";
  } else {
    localStorage.setItem("darkMode", "disabled");
    darkModeToggle.textContent = "🌙";
  }
  updateThemeColor();
});




window.addEventListener("popstate", function(event) {
  if (chatEl.classList.contains('active')) {
    chatEl.classList.remove('active');
    listEl.classList.add('active');
    currentKey = null;
  } else {
    history.back();
  }
});
</script>




<script>
  // ensure this runs after firebase.initializeApp(...) and after "const db = firebase.database();"
  const userEmail = "mahekj05@gmail.com";
  const userKey = userEmail.replace(/\./g, '_');
  
  // debug helper
  db.ref('.info/connected').on('value', snap => {
    console.log('DEBUG: .info/connected =>', snap.val());
  });
  
  // call setPresence that you already defined (or add below if missing)
  
  
  // For UI: update avatar border on status changes (you already have similar code)
  db.ref('status/' + userKey).on('value', snapshot => {
    const status = snapshot.val();
    console.log('DEBUG: status snapshot', status);
    const userLogo = document.getElementById('userLogo');
    if (!userLogo) return;
    let state = null;
    if (status && typeof status === 'object') state = status.state;
    else state = status;
    userLogo.style.border = (state === 'online') ? '3px solid green' : '3px solid orange';
  });
</script>
<style>
.chat-item {
  position: relative; /* Important for absolute badge positioning */
}
.unread-badge {
  position: absolute;
  top: 40px;
  right: 20px;
  background: #25D366; /* WhatsApp green */
  color: white;
  font-size: 12px;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 12px;
  min-width: 18px;
  text-align: center;
  display: inline-block; /* Show by default for testing */
}
</style>
<script>
// --- UNREAD BADGES & LAST SEEN TRACKING ---
let unreadCounts = {}; // store counts per chat key
let lastSeen = {};     // store last seen timestamp per chat

// --- Load/Save last seen from localStorage ---
function saveLastSeen() {
  localStorage.setItem('lastSeen', JSON.stringify(lastSeen));
}
function loadLastSeen() {
  const data = localStorage.getItem('lastSeen');
  if (data) lastSeen = JSON.parse(data);
}
loadLastSeen();

// --- Render chats and show badges ---
const oldRenderChats = renderChats;
renderChats = function(chats) {
  oldRenderChats(chats); // call original renderChats
  Object.keys(chats).forEach(key => {
    const item = allChats.find(c => c.key === key)?.element;
    if (item) {
      let badge = item.querySelector('.unread-badge');
      if (!badge) {
        badge = document.createElement('span');
        badge.className = 'unread-badge';
        item.appendChild(badge);
      }
      badge.textContent = unreadCounts[key] || 0;
      badge.style.display = (unreadCounts[key] || 0) > 0 ? 'inline-block' : 'none';
    }
  });
};

// --- Reset unread count when opening a chat ---
const oldOpenChat = openChat;
openChat = function(key) {
  unreadCounts[key] = 0;
  lastSeen[key] = Date.now();
  saveLastSeen();
  renderChats(getCachedChats() || {});
  oldOpenChat(key);
};

// --- Listen for new messages (child_added and child_changed) ---
db.ref('chats').on('child_added', snap => {
  const chatKey = snap.key;
  const msgs = snap.val();
  const lastKey = Math.max(...Object.keys(msgs).map(Number));
  const lastMsg = msgs[lastKey];
  const seenTime = lastSeen[chatKey] || 0;

  if (lastMsg.from === 'user' && lastKey > seenTime && chatKey !== currentKey) {
    unreadCounts[chatKey] = (unreadCounts[chatKey] || 0) + 1;
    renderChats(getCachedChats() || {});
  }
});

db.ref('chats').on('child_changed', snap => {
  const chatKey = snap.key;
  const msgs = snap.val();
  const lastKey = Math.max(...Object.keys(msgs).map(Number));
  const lastMsg = msgs[lastKey];
  const seenTime = lastSeen[chatKey] || 0;

  if (lastMsg.from === 'user' && lastKey > seenTime && chatKey !== currentKey) {
    unreadCounts[chatKey] = (unreadCounts[chatKey] || 0) + 1;
    renderChats(getCachedChats() || {});
  }
});
  // When going back to inbox, badges will already be updated
</script>
<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker
        .register("./service-worker.js")
        .then((reg) => console.log("Service Worker registered:", reg.scope))
        .catch((err) => console.error("Service Worker failed:", err));
    });
  }
</script>
  <script>
    // Prevent pinch zoom
    document.addEventListener('touchmove', function(event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
    }, { passive: false });
    
    // Prevent double-tap zoom
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, { passive: false });
  </script>

<script>
/* ===== Configuration ===== */
// Add your GIPHY API key here:
const GIPHY_API_KEY = "e68mngd8xYdq05iTwWRZPlbK92CIPhMB"; // <-- get one at https://developers.giphy.com/ (free)

/* ===== Emoji picker setup using emoji-button ===== */
const { EmojiButton } = window;
let picker;
try{
  picker = new EmojiButton({ position: 'top-end', zIndex: 99999 });
  const emojiBtn = document.getElementById('emojiBtn');
  const replyInput = document.getElementById('replyInput');

  emojiBtn.addEventListener('click', () => {
    picker.togglePicker(emojiBtn);
  });

  picker.on('emoji', selection => {
    // Insert emoji at cursor position in textarea
    insertAtCursor(replyInput, selection.emoji);
    replyInput.focus();
  });
} catch(e){
  console.warn("Emoji picker failed to load:", e);
}

/* helper: insert at cursor for textarea */
function insertAtCursor(input, text) {
  const start = input.selectionStart || 0;
  const end = input.selectionEnd || 0;
  const value = input.value || '';
  input.value = value.slice(0, start) + text + value.slice(end);
  // move cursor after inserted text
  const newPos = start + text.length;
  input.selectionStart = input.selectionEnd = newPos;
  input.dispatchEvent(new Event('input'));
}

/* ===== GIF picker modal + search ===== */
const gifBtn = document.getElementById('gifBtn');
const gifModal = document.getElementById('gifModal');
const gifSearch = document.getElementById('gifSearch');
const gifSearchBtn = document.getElementById('gifSearchBtn');
const gifResults = document.getElementById('gifResults');
const gifCloseBtn = document.getElementById('gifCloseBtn');

gifBtn.addEventListener('click', () => {
  if(!GIPHY_API_KEY || GIPHY_API_KEY.includes("PUT_YOUR")) {
    alert("Please set GIPHY_API_KEY in the code to use GIF search (free key at developers.giphy.com).");
    return;
  }
  gifModal.style.display = 'flex';
  gifModal.setAttribute('aria-hidden','false');
  gifResults.innerHTML = '';
  gifSearch.value = '';
  // show trending by default
  searchGiphy('trending');
});

gifCloseBtn.addEventListener('click', () => {
  gifModal.style.display = 'none';
  gifModal.setAttribute('aria-hidden','true');
});

gifSearchBtn.addEventListener('click', () => {
  const q = gifSearch.value.trim();
  if(!q) return;
  searchGiphy(q);
});

async function searchGiphy(query){
  gifResults.innerHTML = 'Loading…';
  try {
    let url;
    if (query === 'trending') {
      url = `https://api.giphy.com/v1/gifs/trending?api_key=${GIPHY_API_KEY}&limit=25&rating=pg`;
    } else {
      url = `https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(query)}&limit=25&rating=pg`;
    }
    const res = await fetch(url);
    const json = await res.json();
    gifResults.innerHTML = '';
    (json.data || []).forEach(g => {
      // use fixed_width_small url for thumbnails
      const thumb = g.images && (g.images.fixed_width_small || g.images.fixed_width) ;
      const full = g.images && (g.images.fixed_width || g.images.original);
      if(!thumb) return;
      const img = document.createElement('img');
      img.className = 'gif-thumb';
      img.src = thumb.url;
      img.alt = g.title || 'gif';
      img.addEventListener('click', () => {
        // When user selects a GIF -> send as message
        const gifUrl = full.url || thumb.url;
        sendMediaMessage({ type: 'gif', url: gifUrl });
        gifModal.style.display = 'none';
      });
      gifResults.appendChild(img);
    });
    if((json.data||[]).length===0) gifResults.innerHTML = 'No GIFs found.';
  } catch(err){
    console.error(err);
    gifResults.innerHTML = 'Search failed.';
  }
}

/* ===== Attach/file input (optional) ===== */
const attachBtn = document.getElementById('attachBtn');
const attachFile = document.getElementById('attachFile');

attachBtn.addEventListener('click', () => attachFile.click());
attachFile.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if(!f) return;
  // Simple client-side preview / send as base64 (not recommended for big files)
  const reader = new FileReader();
  reader.onload = function(ev){
    // send as image message with data URL (if small). Ideally upload to Firebase Storage and send storage URL.
    const dataUrl = ev.target.result;
    sendMediaMessage({ type: 'image', url: dataUrl });
  };
  reader.readAsDataURL(f);
  attachFile.value = '';
});

/* ===== Paste handler for image/GIF URLs or direct images ===== */
document.addEventListener('paste', (e) => {
  // If clipboard contains an image file, or URL
  const items = e.clipboardData && e.clipboardData.items;
  if(!items) return;
  for (const it of items) {
    if (it.kind === 'file') {
      const blob = it.getAsFile();
      if (blob) {
        // File pasted -> read and send as dataURL (or upload to Storage in production)
        const reader = new FileReader();
        reader.onload = (ev) => sendMediaMessage({ type: 'image', url: ev.target.result });
        reader.readAsDataURL(blob);
        e.preventDefault();
        return;
      }
    }
    if (it.kind === 'string' && it.type === 'text/plain') {
      it.getAsString(str => {
        // if user pasted a giphy or image URL, send as gif/image
        if (str.match(/\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || str.includes('giphy.com')) {
          sendMediaMessage({ type: 'gif', url: str });
        }
      });
    }
  }
});

/* ===== sendMediaMessage helper =====
   Sends a chat message object to your DB with type and url.
*/
function sendMediaMessage(payload){
  // payload = { type: 'gif' | 'image', url: '...' }
  if(!currentKey) { alert('Open a chat first'); return; }
  const timestamp = Date.now();
  const message = { from: 'brother', type: payload.type, url: payload.url };
  // optionally include replyTo
  if(replyToText){ message.replyTo = replyToText.msgKey; replyToText=null; replyPreviewContainer.innerHTML=''; }
  db.ref('chats/' + currentKey + '/' + timestamp).set(message);
  document.getElementById("sendSound").play().catch(()=>{});
}

/* ===== Override send button to allow sending text or GIF/image URLs typed in ===== */
document.getElementById('sendBtn').addEventListener('click', sendReply);

const originalSendReply = window.sendReply || function(){};
window.sendReply = function(){
  const txtEl = document.getElementById('replyInput');
  const text = (txtEl.value || '').trim();
  if(!currentKey) return;
  if(!text && !replyToText) return; // nothing to send
  // if text is a direct image/GIF URL, send as media
  if(text.match(/^https?:\/\/.*\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || text.includes('giphy.com')) {
    sendMediaMessage({ type: 'gif', url: text });
    txtEl.value = '';
    return;
  }
  // else send as regular text
  const timestamp = Date.now();
  const message = { text, from:'brother' };
  if(replyToText){message.replyTo = replyToText.msgKey; replyToText=null; replyPreviewContainer.innerHTML='';}
  db.ref('chats/'+currentKey+'/'+timestamp).set(message);
  db.ref("status/brother/typing").set(false);
  try{ document.getElementById("sendSound").play(); }catch(e){}
  txtEl.value='';
  txtEl.style.height="auto";
  txtEl.focus();
};

/* ===== Render GIF / image in message bubble =====
   Modify your existing buildMessageBubble to handle `val.type === 'gif'` or `val.type === 'image'`.
   If you already have buildMessageBubble defined above, replace the rendering part with the snippet below.
*/
const originalBuildMessageBubble = window.buildMessageBubble;
window.buildMessageBubble = function(msgKey, val){
  // call original to preserve reply/tails etc, but then adjust content if type present
  // If originalBuildMessageBubble exists and uses messageStore, we can recreate here for clarity.
  const div = document.createElement('div');
  div.className = 'bubble ' + (val.from==='user' ? 'from-user':'from-brother');
  const arrow = document.createElement('div');
  arrow.className = 'reply-arrow';
  arrow.innerHTML = '↩';
  div.appendChild(arrow);
  attachSwipeHandlers(div,msgKey,val.text || '');

  if(val.replyTo && messageStore[val.replyTo]){
    const replyDiv = document.createElement('div');
    replyDiv.className = 'reply-box';
    replyDiv.textContent = messageStore[val.replyTo] && messageStore[val.replyTo].text ? messageStore[val.replyTo].text : '';
    div.prepend(replyDiv);
  }

  if(val.type === 'gif' || val.type === 'image'){
    const media = document.createElement('img');
    media.style.maxWidth = '260px';
    media.style.maxHeight = '260px';
    media.style.borderRadius = '8px';
    media.style.display = 'block';
    media.style.marginBottom = '6px';
    media.src = val.url;
    media.alt = val.type;
    div.appendChild(media);
    if(val.text) {
      const textNode = document.createElement('div');
      textNode.textContent = val.text;
      div.appendChild(textNode);
    }
  } else {
    const textNode = document.createElement('div');
    textNode.textContent = val.text || '';
    div.appendChild(textNode);
  }

  const timeNode = document.createElement('div');
  timeNode.className = 'msg-time';
  timeNode.textContent = new Date(Number(msgKey)).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', hour12:true});
  div.appendChild(timeNode);
  return div;
};

/* ===== Make sure messages area resizes text area rows automatically (optional helper) ===== */
const ta = document.getElementById('replyInput');
ta.addEventListener('input', () => {
  ta.style.height = 'auto';
  ta.style.height = Math.min(120, ta.scrollHeight) + 'px';
  // typing status to DB
  db.ref("status/brother/typing").set( ta.value.trim().length > 0 );
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => { db.ref("status/brother/typing").set(false); }, 1500);
});
</script>

</body>
</html>