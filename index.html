<!DOCTYPE html>
<html>
<head>
  <link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#ffffff" id="theme-color-meta">
<meta charset="utf-8">
  <title>Brother Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, interactive-widget=resizes-content">

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <script src="firebase-config.js"></script>

  <!-- Preload images for faster UI -->
  <link rel="preload" as="image" href="chat_logo.png">
  <link rel="preload" as="image" href="chat.png">
<!-- Emoji picker -->
<script src="https://cdn.jsdelivr.net/npm/@joeattardi/emoji-button@4.6.2/dist/index.min.js"></script>

  <!--for bottom gesture navigation bar removing-->
  <style>
  /* Dark mode HR color */
body.dark #settingsMenu hr {
  border-color: #031813 !important;
  
}



  /* Enhanced Animation System */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { 
    opacity: 0;
    transform: translateY(20px);
  }
  to { 
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInLeft {
  from {
    opacity: 0;
    transform: translateX(-30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes bounce {
  0%, 20%, 53%, 80%, 100% {
    animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    transform: translate3d(0,0,0);
  }
  40%, 43% {
    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
    transform: translate3d(0, -15px, 0);
  }
  70% {
    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
    transform: translate3d(0, -8px, 0);
  }
  90% {
    transform: translate3d(0,-2px,0);
  }
}

@keyframes flip {
  from {
    transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
    animation-timing-function: ease-out;
  }
  40% {
    transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
    animation-timing-function: ease-out;
  }
  50% {
    transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
    animation-timing-function: ease-in;
  }
  80% {
    transform: perspective(400px) scale3d(.95, .95, .95);
    animation-timing-function: ease-in;
  }
  to {
    transform: perspective(400px);
    animation-timing-function: ease-in;
  }
}

@keyframes zoom {
  from {
    opacity: 0;
    transform: scale3d(.3, .3, .3);
  }
  50% {
    opacity: 1;
  }
}

@keyframes typewriter {
  from { width: 0; }
  to { width: 100%; }
}

@keyframes wave {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
  20%, 40%, 60%, 80% { transform: translateX(5px); }
}

@keyframes swing {
  20% { transform: rotate3d(0, 0, 1, 15deg); }
  40% { transform: rotate3d(0, 0, 1, -10deg); }
  60% { transform: rotate3d(0, 0, 1, 5deg); }
  80% { transform: rotate3d(0, 0, 1, -5deg); }
  to { transform: rotate3d(0, 0, 1, 0deg); }
}

@keyframes tada {
  0% { transform: scale3d(1, 1, 1); }
  10%, 20% { transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg); }
  30%, 50%, 70%, 90% { transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg); }
  40%, 60%, 80% { transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg); }
  100% { transform: scale3d(1, 1, 1); }
}

@keyframes wobble {
  0% { transform: none; }
  15% { transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg); }
  30% { transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg); }
  45% { transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg); }
  60% { transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg); }
  75% { transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg); }
  100% { transform: none; }
}

@keyframes jello {
  0%, 11.1%, 100% { transform: none; }
  22.2% { transform: skewX(-12.5deg) skewY(-12.5deg); }
  33.3% { transform: skewX(6.25deg) skewY(6.25deg); }
  44.4% { transform: skewX(-3.125deg) skewY(-3.125deg); }
  55.5% { transform: skewX(1.5625deg) skewY(1.5625deg); }
  66.6% { transform: skewX(-0.78125deg) skewY(-0.78125deg); }
  77.7% { transform: skewX(0.390625deg) skewY(0.390625deg); }
  88.8% { transform: skewX(-0.1953125deg) skewY(-0.1953125deg); }
}

@keyframes heartbeat {
  0% { transform: scale(1); }
  14% { transform: scale(1.1); }
  28% { transform: scale(1); }
  42% { transform: scale(1.1); }
  70% { transform: scale(1); }
}

@keyframes rubberBand {
  0% { transform: scale(1); }
  30% { transform: scaleX(1.25) scaleY(0.75); }
  40% { transform: scaleX(0.75) scaleY(1.25); }
  60% { transform: scaleX(1.15) scaleY(0.85); }
  100% { transform: scale(1); }
}

@keyframes lightSpeed {
  from {
    transform: translate3d(100%, 0, 0) skewX(-30deg);
    opacity: 0;
  }
  60% {
    transform: skewX(20deg);
    opacity: 1;
  }
  80% {
    transform: skewX(-5deg);
  }
  to {
    transform: none;
    opacity: 1;
  }
}

@keyframes rollIn {
  from {
    opacity: 0;
    transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
  }
  to {
    opacity: 1;
    transform: none;
  }
}

@keyframes rotateIn {
  from {
    transform-origin: center;
    transform: rotate3d(0, 0, 1, -200deg);
    opacity: 0;
  }
  to {
    transform-origin: center;
    transform: none;
    opacity: 1;
  }
}

/* Chat List Animations */
@keyframes chatItemFadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes chatItemSlideIn {
  from { opacity: 0; transform: translateX(-20px); }
  to { opacity: 1; transform: translateX(0); }
}

@keyframes chatItemBounceIn {
  0% { opacity: 0; transform: scale(0.3); }
  50% { opacity: 1; transform: scale(1.05); }
  70% { transform: scale(0.9); }
  100% { opacity: 1; transform: scale(1); }
}

/* Special Effects */
@keyframes ripple {
  0% {
    transform: scale(0);
    opacity: 1;
  }
  100% {
    transform: scale(4);
    opacity: 0;
  }
}

@keyframes glow {
  0%, 100% { box-shadow: 0 0 5px rgba(0, 123, 255, 0.5); }
  50% { box-shadow: 0 0 20px rgba(0, 123, 255, 0.8); }
}

@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

@keyframes unreadPulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

/* Animation Classes */
.bubble.animate-fadeIn { animation-name: fadeIn; }
.bubble.animate-slideUp { animation-name: slideUp; }
.bubble.animate-slideInLeft { animation-name: slideInLeft; }
.bubble.animate-slideInRight { animation-name: slideInRight; }
.bubble.animate-bounce { animation-name: bounce; }
.bubble.animate-flip { animation-name: flip; }
.bubble.animate-zoom { animation-name: zoom; }
.bubble.animate-wave { animation-name: wave; }
.bubble.animate-pulse { animation-name: pulse; }
.bubble.animate-shake { animation-name: shake; }
.bubble.animate-swing { animation-name: swing; }
.bubble.animate-tada { animation-name: tada; }
.bubble.animate-wobble { animation-name: wobble; }
.bubble.animate-jello { animation-name: jello; }
.bubble.animate-heartbeat { animation-name: heartbeat; }
.bubble.animate-rubberBand { animation-name: rubberBand; }
.bubble.animate-lightSpeed { animation-name: lightSpeed; }
.bubble.animate-rollIn { animation-name: rollIn; }
.bubble.animate-rotateIn { animation-name: rotateIn; }

.chat-item.animate-fadeIn { animation-name: chatItemFadeIn; }
.chat-item.animate-slideIn { animation-name: chatItemSlideIn; }
.chat-item.animate-bounceIn { animation-name: chatItemBounceIn; }

.bubble.ripple-effect::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 5px;
  height: 5px;
  background: rgba(255, 255, 255, 0.5);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  animation: ripple 0.6s linear;
}

.bubble.glow-effect {
  animation: glow 2s infinite;
}

.bubble.float-effect {
  animation: float 3s ease-in-out infinite;
}

.unread-badge.pulse-effect {
  animation: unreadPulse 1.5s infinite;
}
  /* Remove gesture navigation bar border */
body {
  overscroll-behavior-y: none !important;
}



/* SVG Color Variables */
:root {
  --svg-color: #3A4F4A; /* Light mode color */
}

body.dark {
  --svg-color: #B7CAC6; /* Dark mode color */
}

/* Apply to ALL SVGs */
svg {
  stroke: var(--svg-color) !important;
  
}
/* Custom color ONLY for call button in light mode */
body:not(.dark) #chatHeader a[href="videocall.html"] svg {
  fill:#3A4F4A !important; /* Custom blue color for call button in light mode */
}


/* For Android Chrome/Samsung Internet */
#inputArea {
  border-top: none !important;
}

/* Hide the navigation bar line */
html {
  scrollbar-width: none !important; /* Firefox */
}

body::-webkit-scrollbar {
  display: none !important; /* Chrome, Safari, Edge */
}


</style>

<style>



.lightbox {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.9);
  z-index: 9999;
}
.lightbox.open { display: flex; }
.lightbox img {
  max-width: 90vw;
  max-height: 90vh;
}
.lightbox .btn {
  position: absolute;
  background: rgba(0,0,0,0.5);
  color: #fff;
  border: none;

  border-radius: 4px;
  cursor: pointer;
}
.lightbox .close { top: 10px; right: 10px; }
.lightbox .prev { left: 10px; top: 14%; transform: translateY(-50%); }
.lightbox .next { right: 5%;
left:70%; top: 14%; transform: translateY(-50%); }
.lightbox .download { bottom: 10px; right: 10px; }
.lightbox .counter { bottom: 10px; left: 10px; color:#fff; font-size:14px; }
/* Keep input area fully transparent */
#inputArea {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 10px;
  background: transparent;
  border-top: none;
  display: flex;
  flex-direction: column;
  z-index: 30;
}

/* RCS Input Area */
/* Modern messenger-style input area */
/* Send button - positioned outside the input area */
#sendBtn {
  position: fixed; /* Changed from absolute to fixed */
  right: 15px;
  bottom: 13px;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #DDF2ED;
  border: none!important;
  cursor: pointer;
  color: white;
  
  transition: all 0.2s ease;
  z-index: 1001;
}

/* Light mode send button */
body:not(.dark) #sendBtn {
  background: #DDF2ED;

}
body.dark #sendBtn {
  background: #202C28;
  
}
/* Send button states */
#sendBtn:not(.active) {
  opacity: 1;
  transform: scale(0.9);
}

#sendBtn.active {
  opacity: 1;
  transform: scale(1);
}

#sendBtn:hover {
  transform: scale(1.05);

}


/* Adjust input controls to not overlap with send button */
#inputControls {
  display: flex;
  align-items: flex-end;
  gap: 8px;
  background: #1f2c28;
  padding: 8px 12px;
  border-radius: 24px;
  min-height: 52px;
  transition: all 0.2s ease;
  margin-right: 60px; /* Add space for the send button */
}

/* Light mode */
body:not(.dark) #inputControls {
  background: #DDF2ED;
  border: none;
  margin-right: 60px; /* Add space for the send button */
}

/* Remove the margin from inputArea since we're using fixed positioning */
#inputArea {
  margin-right: 0;
}

/* Light mode send button */
body:not(.dark) #sendBtn {
  background: #DDF2ED;
  
}




/* Hide GIF and emoji buttons when typing */
#inputControls:has(#replyInput:not(:placeholder-shown)) #gifBtn,
#inputControls:has(#replyInput:not(:placeholder-shown)) #emojiBtn {
  display: none;
}

/* Adjust messages padding to account for floating send button */
#messages {
  padding-bottom: 120px !important;
}



/* GIF picker modal */
#gifModal {
  position: fixed;
  left: 0; right: 0; top: 0; bottom: 0;
  display: none;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(4px);
  z-index: 9999;
}
#gifModal .panel {
  width: 92%;
  max-width: 720px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 12px 40px rgba(0,0,0,0.25);
  padding: 12px;
  max-height: 80vh;
  overflow: auto;
}
#gifModal .search {
  display:flex;
  gap:8px;
  margin-bottom:10px;
}
#gifResults {
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}
.gif-thumb {
  width: 30%;
  max-width: 160px;
  border-radius: 8px;
  cursor: pointer;
  object-fit: cover;
}
@media (max-width:480px){ .gif-thumb{ width: 48%; } }
</style>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html { height: 100%; font-family: 'Segoe UI', sans-serif; background: #f2f3f7; overflow-x: hidden; }

    #list, #chat {
  display: none; 
  height: 100%; 
  width: 100%;
  background: #DDF2ED; /* Same as messages background for light mode */
}


    #list.active, 
    
    #chat.active {
  display: flex;
  flex-direction: column;
  height: 100%;
}



body.dark #chat{
  background: #13221F; /* Same as dark mode messages background */
}
    #messages { overflow-x: hidden; }

   #inboxHeader {
  padding: 25px 20px 10px;
  font-size: 28px;
  font-weight: 700;
  color: #2563eb; /* Solid blue color for light mode */
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
}

body.dark #inboxHeader {
  color: #9333ea; /* Solid purple color for dark mode */
}
    #searchBox {
      background: #EAFDF9;
      margin: 12px 20px 0;
      padding: 10px 15px;
      border-radius: 30px;
      border: none;
      outline: none;
      font-size: 15px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.04);
    }
    


    #list {
      background:#DFF2EC;
      overflow-y: auto;
    }
    
    
    

    .chat-item {
      position: relative;
      background: #EAFDF9;
      padding: 15px 20px;
      margin: 12px 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .chat-item:hover { background: #e0ecff; transform: translateY(-2px); }
    .chat-name { font-size: 16px; font-weight: 600; color: #333; }
    .chat-preview { font-size: 14px; color: #666; margin-top: 4px; }
    .chat-time {
      position: absolute; right: 20px; top: 18px;
      font-size: 12px; color: #888;
    }
    
/* Bubble pop animation */
@keyframes bubblePop {
  0% {
    transform: scale(0.8);
    opacity: 0;
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

.bubble {
  animation: bubblePop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  transform-origin: bottom;
}

/* For user bubbles (left) */
.from-user {
  transform-origin: bottom left;
}

/* For brother bubbles (right) */
.from-brother {
  transform-origin: bottom right;
}

    #chatHeader {
      height:70px;
  border: none !important;
  flex-shrink: 0;
  background: #DDF2ED;
  color: #000000;
  padding: 4px;
  font-weight: 400;
  font-size: 18px;
  display: flex;
  
  align-items: center;
  box-shadow: none !important;
  outline: none !important;
}

    #messages {
      border-top-left-radius: 33px;
      border-top-right-radius: 33px;
      flex: 1; padding: 10px; overflow-y: auto; display: flex; flex-direction: column;
      background-color: #E9FEF9;
      background-size: 110% 110%;
      background-repeat: no-repeat;
      background-position: center;
    }





/* Common bubble style */
.bubble {
  
  white-space: pre-wrap; 
  position: relative;
  margin: 6px 0;
  padding: 12px 16px;
  border-radius: 16px;
  max-width: 75%;
  font-size: 18px;
  line-height: 1.4;
  word-wrap: break-word;
}

/* User bubble (left) */
.from-user {
  background: #DDF2ED;
  align-self: flex-start;
  border-bottom-left-radius: 4px; /* smaller radius for tail corner */
}

/* Brother bubble (right) */
.from-brother {
  background: #006B61;
  align-self: flex-end;
  color:white;
  
  border-bottom-right-radius: 4px; /* smaller radius for tail corner */
}

/* Tail for user bubble (left) */
.from-user::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0; /* start from left corner */
  width: 12px;
  height: 12px;
  background: #DDF2ED;
  border-bottom-left-radius: 4px;
  clip-path: polygon(0 0, 0% 100%, 100% 100%);
}

/* Tail for brother bubble (right) */
.from-brother::after {
  content: '';
  position: absolute;
  bottom: 0;
  right: 0; /* start from right corner */
  width: 12px;
  height: 12px;
  background: #006B61;
  border-bottom-right-radius: 4px;
  clip-path: polygon(100% 0, 0% 100%, 100% 100%);
}





/* Brother bubble timestamp - */
.from-brother .msg-time {
  color: white !important;
}


    .msg-time {
      font-size: 10px; color: black; margin-top: 4px; align-self: flex-end;
    }

.reply-box {
  min-width: 0px;
  font-size: 15px;
  color: #555;
  background: #E9FEF9;
  width: calc(100%);
border: 10px solid #DDF2ED;
}
body.dark .reply-box{
  border: 10px solid #13221F !important;
}

/* Remove all padding from bubbles with replies */
.bubble:has(.reply-box) {
  padding: 0 !important;
}

/* Top part (reply box) - no padding */
.reply-box {
  margin: 0 !important;
  padding: 8px 12px !important;
  border-radius: 16px 16px 0 0 !important;
  
}

/* Message text area - minimal bottom padding */
.bubble:has(.reply-box) > div:not(.reply-box):not(.msg-time) {
  padding: 12px 16px 4px 16px !important; /* Very small bottom padding */
  border-radius: 0 0 16px 16px !important;
}

/* Timestamp - remove all top margin and stick to message */
.bubble:has(.reply-box) .msg-time {
  margin-top: 0px !important;
  padding: 0px 16px 8px 16px !important; /* Padding only at bottom */
}

  #inputArea {
  flex-shrink: 0;
  display: flex;
  padding: 10px;
  background: transparent; /* ✅ transparent background */
  border-top: none;        /* ✅ no border */
  flex-direction: column;
  backdrop-filter: none;   /* ✅ no blur, fully clear */
}

    .reply-preview {
      
      
  background: rgba(255, 255, 255, 0.2); /* translucent layer */
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-radius: 10px;
  padding: 20px;

      display: flex;
      justify-content: space-between;
      align-items: center;
      
      padding: 6px 10px;
      border-left: 4px solid #005047;
      border-radius: 6px;
      font-size: 13px;
      margin-bottom: 6px;
      color: #333;
    }
    .reply-preview-text {
      flex: 1;
      white-space: normal;
      overflow: hidden;
      max-height: 3.2em;
    }
    .reply-preview button {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: #888;
    }
    
    .date-divider {
  text-align: center;
  margin: 10px auto;
  padding: 6px 14px;
  border-radius: 14px;
  font-size: 13px;
  font-weight: 600;
  color: #555;
  background: #DDF2ED;
  display: inline-block;
}

/* Dark mode divider */
body.dark .date-divider {
  background: #13221F;
  color: #B7CAC6;
}
  
  body.dark .from-user::after {
  background: #13221F; /*tail matches dark bubble */
}
body.dark .from-brother::after {
  background: #005047; /*tail matches dark brother bubble */
}
    
  
    #inputControls textarea {
      flex: 1;
      padding: 8px 12px;
  border:none!important;
  background: transparent;
      border-radius: 20px;
      resize: none;
      outline: none!important;
      overflow: hidden;
      font-size: 15px;
      line-height: 1.3;
      max-height: 80px;
    
    }
    
    /* Light mode input area text color */
body:not(.dark) #inputControls textarea {
  color: #666666;
}
body.dark #inputControls textarea {
  color: #DDF2ED;
}

    #inputControls button {
      margin-left: 5px;
      border: none;
      background: transparent; 
      color: #fff; 
      
      border-radius: 50px;
    }

    .reply-arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      transition: opacity 0.2s ease;
      font-size: 18px;
      color: #4caf50;
    }
    .from-user .reply-arrow { left: -28px; }
    .from-brother .reply-arrow { right: -28px; }
    .bubble.show-arrow .reply-arrow { opacity: 1; }
    
    
    
    
    /* 🌙 DARK MODE FIX */
body.dark {
  background: #121212 !important;
  color: #B7CAC6 !important;
}



/* 🌙 Dark mode for search bar */
body.dark #searchBox {
  background: #061613 !important;
  color: #B7CAC6 !important;

}

body.dark #searchBox::placeholder {
  color: #B7CAC6 !important;
}






/* Inbox chat items (dark mode) */
body.dark .chat-item {
  background: #2a2a2a;          /* dark gray card */
  color: #B7CAC6;                  /* default text = white */
}

body.dark .chat-item .chat-name {
  color: #B7CAC6;               /* pure white for names */
}

body.dark .chat-item .chat-preview {
  color: #B7CAC6;               /* softer gray for preview */
}

body.dark .chat-item .chat-time {
  color: #B7CAC6;               /* dim gray for timestamp */
}


/* Chat list */
body.dark #list {
  background: #12221F !important;
}

body.dark .chat-item {
  background: #061613 !important;
  color: #B7CAC6 !important;   /* chat list names = pure white */
}

body.dark .chat-item:hover {
  background: #333 !important;
}

body.dark .chat-item small,
body.dark .chat-item .preview {
  color: #B7CAC6 !important; /* slightly brighter gray */
}

/* Chat header */
body.dark #chatHeader {
  background: #13221F;
  color: #B7CAC6 !important;
}

/* Messages area */
body.dark #messages {
  background: #031813!important;
}

/* User bubbles */
body.dark .from-user {
  background: #13221F;
  color: #B7CAC6 !important;
}

/* Brother bubbles */
body.dark .from-brother {
  background: #005047;
  color: #B7CAC6 !important;
}

/* Chat bubble timestamp */
body.dark .msg-time {
  font-size: 11px !important;
  color: #B7CAC6 !important;   /* full white */
  text-align: right !important;
  margin-top: 4px !important;
  display: block !important;
}


/* Reply box (dark mode) */
body.dark .reply-box {
  color: #e5e5e5;
  background:#031813;
}


    /* Reply preview (dark mode) */
body.dark .reply-preview {
  background: rgba(255, 255, 255, 0.08);  /* soft overlay on dark */
  border-left: 
  4px solid #005047; /* blue accent */
  color: #e5e5e5;
}

    /* Toggle button base */
#darkModeToggle {
  margin-left: auto;
  margin-right: 10px;
  padding: 6px 14px;
  border-radius: 20px;
  border: none;
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  transition: all 0.3s ease;
}

/* Light mode toggle */
body:not(.dark) #darkModeToggle {
background: #DDF2ED;   /* light gray */
  color: #111;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);

  
}


/* Dark mode toggle */
body.dark #darkModeToggle {
  background: #13221F;   /* dark gray */
  color: #facc15;        /* warm yellow (sun icon) */
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

/* Hover effect */
#darkModeToggle:hover {
  transform: scale(1.05);
}
    
    
    
/* Change this: */
.bubble.message-highlight {
  background-color: #A1B790 !important;
}

/* To this: */
body:not(.dark) .bubble.message-highlight {
  background-color: #A1B790 !important;
}

body:not(.dark) .bubble.message-highlight.from-user::after,
body:not(.dark) .bubble.message-highlight.from-brother::after {
  background-color: #A1B790 !important;
}

/* Keep dark mode as is */
body.dark .bubble.message-highlight {
  background-color: #E6A23ECC !important;
}

body.dark .bubble.message-highlight.from-user::after,
body.dark .bubble.message-highlight.from-brother::after {
  background-color: #E6A23ECC !important;
}
    .loading-indicator {
  text-align: center;
  padding: 10px;
  color: #666;
  font-style: italic;
  background: rgba(255, 255, 255, 0.8);
  border-radius: 8px;
  margin: 10px;
}

body.dark .loading-indicator {
  background: rgba(42, 42, 42, 0.8);
  color: #B7CAC6;
}
    
    /* Styles for clickable links in messages */
.message-link {
  pointer-events: auto;
  color: deepskyblue;
  text-decoration: underline;
  word-break: break-all;
}

body.dark .message-link {
  color: deepskyblue;
  text-decoration: underline ;
}

.message-link:hover {
  text-decoration: underline;
}

/* For reply previews */
.reply-box a,
.reply-preview-text a {
  color: #069;
  text-decoration: none;
}

body.dark .reply-box a,
body.dark .reply-preview-text a {
  color: #5ac8fa;
}

.reply-box a:hover,
.reply-preview-text a:hover {
  text-decoration: underline;
}
  </style>
</head>
<body>

  

  
  
  <audio id="sendSound" src="send.mp3" preload="auto"></audio>
<audio id="receiveSound" src="receive.mp3" preload="auto"></audio>

  <div id="list" class="active">
    <div id="inboxHeader" style="margin-left: 10px;">S talk</div>
  <input type="text" id="searchBox" placeholder="Search chats..." oninput="filterChats()" />
    <div id="chatList"></div>
  </div>

  <div id="chat">
    <div id="chatHeader">
<button type="button" onclick="goBackToList()"
style="
margin-left:17px;
background: transparent;
border:none"
>
  <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <line x1="19" y1="12" x2="5" y2="12"/>
    <polyline points="12 19 5 12 12 5"/>
  </svg>
  
</button>
<img id="userLogo" src="chat_logo.png" style="width:45px; height:45px; border-radius:50%; margin-left: 10px;" />

      
<div style="margin-left:10px; display:flex; flex-direction:column;">
  <div id="chatTitle">Bubu😘</div>
  <div id="typingIndicator" style="font-size:12px; color:gray; display:none;">
    typing…
  </div>
</div>

<a href="videocall.html"
style="margin-left: auto;
margin-right: 8px;
margin-top: 8px;
">
<!-- WhatsApp-like call icon (transparent background) -->
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#B7CAC6">
  <path d="M6.62 10.79a15.05 15.05 0 0 0 6.59 6.59l2.2-2.2a1 1 0 0 1 1.11-.21c1.2.48 2.53.73 3.88.73a1 1 0 0 1 1 1v3.5a1 1 0 0 1-1 1C12.07 22 2 11.93 2 3.5a1 1 0 0 1 1-1H6.5a1 1 0 0 1 1 1c0 1.35.25 2.68.73 3.88a1 1 0 0 1-.21 1.11l-2.2 2.2z" />
</svg></a>
<!-- Replace the existing dark mode toggle button with this -->
<div style="position: relative;">
  <button id="settingsToggle" title="Settings" style="
    margin-left: auto;
    margin-right: 10px;
    padding: 6px 14px;
    border-radius: 20px;
    border: none;
    cursor: pointer;
    font-size: 26px;
    font-weight: 600;
    background: transparent;
    color: #111;
  ">
    
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 6 20"
     width="6" height="18"
     preserveAspectRatio="xMidYMid meet"
     role="img" aria-label="Tiny vertical three dots">
  <!-- Tiny dots using stroke for fill -->
  <circle cx="3" cy="3"  r="1" fill="none" stroke="" stroke-width="2" stroke-linecap="round"/>
  <circle cx="3" cy="10"  r="1" fill="none" stroke="" stroke-width="2" stroke-linecap="round"/>
  <circle cx="3" cy="18" r="1" fill="none" stroke="" stroke-width="2" stroke-linecap="round"/>
</svg>
  </button>
  
  <!-- Settings dropdown menu -->
  <div id="settingsMenu" style="
    position: absolute;
    top: 100%;
    right: 10px;
    background :#DDF2ED;
    border-radius: 12px;
    margin-top: 18px;
    color: black;
    padding: 8px 0;
    min-width: 200px;
    z-index: 1000;
    display: none;
  
  ">
    
    <style>
  body.dark #settingsMenu{
 color: #B7CAC6!important;
  background: #13221F!important;
}

.menu-item {
  padding: 10px 12px;
  cursor: pointer;
  transition: background 0.2s;
  font-size: 15.2px;
  display: flex;
  align-items: center;
  gap: 8px;
}


/* Color customization modal */
.color-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.color-modal.open {
  display: flex;
}



body.dark .color-modal-content {
  background: #13221F;
  color: #B7CAC6;
}

.color-option {
  margin-bottom: 15px;
  display: flex;
  align-items: center;
  gap: 10px;
  min-width: 0; /* Prevents flex items from overflowing */
}

.color-option label {
  min-width: 140px; /* Reduced from 180px */
  font-weight: 500;
  font-size: 14px;
  flex-shrink: 0; /* Prevents label from shrinking */
}

.color-input {
  flex: 1;
  min-width: 0; /* Allows input to shrink properly */
  padding: 8px 12px;
  border-radius: 8px;
  background: #DDF2ED;
  border: 1px solid #ccc;
  font-size: 14px;
  box-sizing: border-box;
}



/* For dark mode */
body.dark .color-input {
  background: #061613;
  color: #B7CAC6;
  border-color: #2A3A36;
}

/* Ensure modal content doesn't cause horizontal scroll */
.color-modal-content {
  background: #E9FEF9;
  border-radius: 16px;
  padding: 20px;
  width: 90%;
  max-width: 500px;
  max-height: 80vh;
  overflow-y: auto;
  overflow-x: hidden; /* Prevent horizontal scroll */
  box-sizing: border-box; /* Include padding in width calculation */
}

body.dark .color-modal-content {
  background: #13221F;
  color: #B7CAC6;
}
body.dark .color-input {
  background: #061613;
  color: #B7CAC6;
  border-color: #2A3A36;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
}

.modal-btn {
  padding: 8px 16px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.2s;
}

.modal-btn.primary {
  background: #2563eb;
  color: white;
}

.modal-btn.secondary {
  background: #DDF2ED;
  color: #374151;
}

body.dark .modal-btn.secondary {
  background: #2A3A36;
  color: #B7CAC6;
}


.modal-btn:hover {
  opacity: 0.9;
  transform: translateY(-1px);
}
    </style>
    <div class="menu-item" data-action="toggle-dark">🌙 Dark Mode</div>
    <div class="menu-item" data-action="toggle-light">☀️ Light Mode</div>
    <div class="menu-item" data-action="customize-dark">🎨 Customize Dark Mode</div>
    <div class="menu-item" data-action="customize-light">🎨 Customize Light Mode</div>
    <div class="menu-item" data-action="reset-colors">🔄 Reset to Default</div>
    <div class="menu-item" data-action="advanced-settings">⚙️ Setting</div>
    <hr color=#E9FEF9  />
    <div class="menu-item" data-action="advanced-settings">Also from San</div>
    <hr color=#E9FEF9  />
    <a href="user.html" style="text-decoration: none;
    color: inherit;"> <div class="menu-item">
       <img height="20px" width="20px" style="border:0px solid black;
       transform: scale(1.6);" src="logo.png" alt="" />chat</div></a>
       
    <a href="https://limitleslibrty.github.io/sanhub4u/" style="text-decoration: none;
    color: inherit;"><div class="menu-item"><img height="20px" width="20px" style="border:0px solid black;transform: scale(1.5)" src="sanhub4u.png" alt="" /> Sanhub4u</div></a>
       <a href="https://limitleslibrty.github.io/Image-compressor/" style="text-decoration: none;
    color: inherit;"> <div class="menu-item"><img height="20px" width="20px" style="border:0px solid black;transform: scale(1.1)" src="pix.png" alt="" /> sanhubpix</div></a>
    
  </div>
</div>

    </div>
    <div id="messages"></div>
<div id="inputArea">
  <div id="replyPreviewContainer"></div>
  <div id="inputControls">
    
    <button id="gifBtn" title="GIF" style="height:35px;">
      
      
      
      
   <svg xmlns="http://www.w3.org/2000/svg" 
     width="24" height="24" 
     fill="none" 
     stroke="" 
     stroke-width="2" 
     stroke-linecap="round" 
     stroke-linejoin="round">

  <!-- outer rounded square -->
  <rect x="3" y="3" width="18" height="18" rx="6" ry="6"/>

  <!-- eyes -->
  <circle cx="9" cy="10" r="1"/>
  <circle cx="15" cy="10" r="1"/>

  <!-- mouth with folded corner -->
  <path d="M8 15h4c1.5 0 3 1 3 2v1l3-3"/>
</svg>
      
      
    </button>
    <!-- optional file attach (works locally; to upload to Firebase Storage add storage SDK) -->
    <input id="attachFile" type="file" accept="image/*,video/gif" style="display:none" />
    <button id="attachBtn" title="Attach"
    style="height:35px;">
  <svg xmlns="http://www.w3.org/2000/svg" 
       width="24" height="24" 
       fill="none" 
       stroke="" 
       stroke-width="2" 
       stroke-linecap="round" 
       stroke-linejoin="round">
    <path d="M21.44 11.05l-9.19 9.19a5 5 0 0 1-7.07-7.07l9.19-9.19a3.5 3.5 0 0 1 4.95 4.95l-9.19 9.19a2 2 0 0 1-2.83-2.83l8.48-8.48" />
  </svg>

      
      
    </button>
    
    <textarea id="replyInput" placeholder="Type" rows="1" style="flex:1"></textarea>
    <button id="sendBtn">
      
  <!-- Up Arrow Icon -->
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="26" fill="none" stroke="" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
    <path d="M12 19V5"></path>
    <path d="M5 12l7-7 7 7"></path>
  </svg>

    </button>
  </div>
</div>

<!-- GIF modal -->
<div id="gifModal" aria-hidden="true">
  <div class="panel">
    <div class="search">
            <button style="
      background: rgba(255, 255, 255, 0.9);
border: 1px solid rgba(0,0,0,0.1);
border-radius: 50%;
width: 36px;
height: 36px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
color: grey;
      
      " id="gifCloseBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="128" height="128" aria-hidden="true">
  <!-- circle background -->
  <circle cx="50" cy="50" r="44" fill="#CFCFF3" />
  <!-- left arrow (shaft + head). adjust stroke-width to change thickness -->
  <g fill="none" stroke="#2F3140" stroke-width="8" stroke-linecap="round" stroke-linejoin="round">
    <!-- shaft -->
    <path d="M70 50 H35" />
    <!-- head -->
    <path d="M45 33 L25 50 L45 67" />
  </g>
</svg></button>
   
      <input id="gifSearch" placeholder="Search GIFs (Tenor)" style="flex:1;padding:8px;border-radius:8px;border:1px solid #ccc" />
      <button id="gifSearchBtn" style="
      background: rgba(255, 255, 255, 0.9);
border: 1px solid rgba(0,0,0,0.1);
border-radius: 50%;
width: 36px;
height: 36px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
color: grey;
padding: 3px;
;"
      >
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="11" cy="11" r="8" />
  <line x1="21" y1="21" x2="16.65" y2="16.65" />
</svg>
      </button>
 </div>
    <div id="gifResults"></div>
  </div>
</div>
  </div>
  
  
  
  <script>
  document.addEventListener("DOMContentLoaded", function() {
    if (!localStorage.getItem("authenticated")) {
      document.body.style.filter = "blur(8px)";
      
      setTimeout(() => {
        const raw = prompt("Enter password to access:");
        const entered = raw === null ? '' : raw.trim();
        
        // CORRECT encoded value for this scheme:
        // scheme: reverse the real password, then Base64-encode that reversed string.
        // For real password "8990" -> reversed "0998" -> base64 => "MDk5OA=="
        const encoded = "MDk5OA==";
        
        function decodePassword(enc) {
          try {
            const decoded = atob(enc); // Base64 decode -> "0998"
            return decoded.split('').reverse().join(''); // reverse -> "8990"
          } catch (e) {
            return null;
          }
        }
        
        const expected = decodePassword(encoded);
        
        if (entered && expected && entered === expected) {
          localStorage.setItem("authenticated", "true");
          alert("Access granted ✅");
          document.body.style.filter = "none";
        } else {
          alert("Wrong password ❌");
          location.reload();
        }
      }, 50);
    }
  });
</script>
 
 

<script>
const db = firebase.database();

const listEl = document.getElementById('list');
const chatEl = document.getElementById('chat');
const chatList = document.getElementById('chatList');
const messagesEl = document.getElementById('messages');
const replyInput = document.getElementById('replyInput');


// ---- Presence in the SAME typingIndicator div ----
let statusListener = null; // holds { ref, callback } for cleanup

function formatLastSeen(ts) {
  if (!ts) return 'Last seen: unknown';
  const d = new Date(Number(ts));
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today); yesterday.setDate(today.getDate() - 1);

  const timeStr = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });

  if (d.toDateString() === today.toDateString()) return 'today at ' + timeStr;
  if (d.toDateString() === yesterday.toDateString()) return 'yesterday at ' + timeStr;
  return '' + d.toLocaleDateString([], { day: 'numeric', month: 'short', year: 'numeric' }) + ' at ' + timeStr;
}


function subscribeToPresenceFor(chatKey) {
  // remove previous listener
  if (statusListener && statusListener.ref) {
    try { statusListener.ref.off('value', statusListener.callback); } catch(e) {}
    statusListener = null;
  }

  const typingEl = document.getElementById('typingIndicator');
  const userLogo = document.getElementById('userLogo');
  if (!typingEl) return;

  const statusRef = db.ref('status/' + chatKey);
  const callback = snap => {
    const statusObj = snap.val();
    let typing = false;
    let state = 'offline';
    let last_changed = null;

    if (statusObj) {
      if (typeof statusObj === 'object') {
        typing = !!statusObj.typing;
        state = statusObj.state || state;
        last_changed = statusObj.last_changed || null;
      } else if (typeof statusObj === 'string') {
        state = statusObj;
      }
    }

    // Show in same div
    // Show in same div
if (typing) {
  typingEl.style.display = 'block';
  typingEl.textContent = 'typing…';
  updateProfilePictureBorder(true); // Typing implies online
} else {
  // not typing: online or last seen
  typingEl.style.display = 'block';
  if (state === 'online') {
    typingEl.textContent = 'online';
    updateProfilePictureBorder(true);
  } else {
    typingEl.textContent = formatLastSeen(last_changed);
    updateProfilePictureBorder(false);
  }
}
  };

  statusListener = { ref: statusRef, callback };
  statusRef.on('value', callback);
}

// Ensure we subscribe when opening a chat
const oldOpenChat_forPresence = openChat;
openChat = function(key) {
  oldOpenChat_forPresence(key);
  // key in your app is the DB key (looks like you already use underscores)
  subscribeToPresenceFor(key);
};

// Optional: cleanup listener when going back to inbox
const oldPop = window.onpopstate;
// Simple fix - replace your current popstate listener with this:
window.addEventListener('popstate', function(event) {
  if (chatEl.classList.contains('active')) {
    chatEl.classList.remove('active');
    listEl.classList.add('active');
    currentKey = null;
    
    // Clean up any active listeners
    if (childListener) {
      db.ref('chats/' + currentKey).off('value', childListener);
      childListener = null;
    }
  }
});

// And ensure your goBackToList function calls history.back():
function goBackToList() {
  history.back();
}

/* ===== improved presence helper =====
   Replace your current setPresence(...) function with this.
*/




let _presenceHeartbeat = null;


function adjustMessagesPadding(){
  const input = document.getElementById('inputArea');
  const messages = document.getElementById('messages');
  if(!input || !messages) return;
  // add extra spacing for safe area
  const extra = 16;
  messages.style.paddingBottom = (input.offsetHeight + extra) + 'px';
}

// run on load and whenever window resizes or input changes
window.addEventListener('load', adjustMessagesPadding);
window.addEventListener('resize', adjustMessagesPadding);

// if your textarea auto-resizes, call adjustMessagesPadding on input
const txt = document.getElementById('replyInput');
if(txt){
  txt.addEventListener('input', function(){ 
    // if you have an auto-height script, run it first then adjust
    setTimeout(adjustMessagesPadding, 60);
  });
}


function linkify(text) {
  if (!text) return '';
  
  // Regular expression to match URLs
  const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
  
  // Replace URLs with anchor tags
  return text.replace(urlRegex, function(url) {
    // Shorten display text for long URLs (like WhatsApp does)
    const displayUrl = url.length > 30 ? url.substring(0, 27) + '...' : url;
    return '<a href="' + url + '" target="_blank" rel="noopener noreferrer" class="message-link">' + displayUrl + '</a>';
  });
}


function setPresence(userKey) {
  if (!userKey) return;
  const userStatusRef = db.ref('status/' + userKey);

  const makeOffline = () => ({
    state: 'offline',
    last_changed: Date.now(),
  });
  const makeOnline = () => ({
    state: 'online',
    last_changed: Date.now(),
  });

  // Clear any previous heartbeat
  if (_presenceHeartbeat) {
    clearInterval(_presenceHeartbeat);
    _presenceHeartbeat = null;
  }

  // Listen for connection status to RTDB servers
  db.ref('.info/connected').on('value', (snap) => {
    if (snap.val() === true) {
      // Ensure server will set offline when this client truly disconnects
      userStatusRef.onDisconnect().set(makeOffline()).catch(()=>{});

      // Immediately mark online
      userStatusRef.set(makeOnline()).catch(()=>{});

      // Start heartbeat to continually update last_changed so server
      // will not mark connection idle. 10s is a good compromise.
      if (!_presenceHeartbeat) {
        _presenceHeartbeat = setInterval(() => {
          userStatusRef.update({ last_changed: Date.now(), state: 'online' }).catch(()=>{});
        }, 5000);
      }
    } else {
      // not connected -> clear heartbeat
      if (_presenceHeartbeat) {
        clearInterval(_presenceHeartbeat);
        _presenceHeartbeat = null;
      }
    }
  });

  // Best-effort attempt to mark offline on page unload using beacon
  window.addEventListener('unload', () => {
    try {
      // Try to use onDisconnect as main line; sendBeacon is fallback
      const payload = JSON.stringify(makeOffline());
      // Using REST endpoint would be ideal, but as a fallback use sendBeacon to a small cloud function
      // Here we attempt a tiny write via navigator.sendBeacon to a special endpoint if you have one.
      // Fallback: attempt a synchronous set (sometimes fails)
      userStatusRef.set(makeOffline());
    } catch (e) {
      // ignore
    }
  });
}

// Call it like this:
setPresence("brother");




let typingTimeout;

replyInput.addEventListener("input", () => {
  // Mark brother as typing
  db.ref("status/brother/typing").set(true);
  
  // Reset after 2 seconds of no input
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    db.ref("status/brother/typing").set(false);
  }, 900);
});
const searchBox = document.getElementById('searchBox');
const replyPreviewContainer = document.getElementById('replyPreviewContainer');

// Instead of listening to your own typing status:
const typingIndicator = document.getElementById('typingIndicator');

// use a single place to derive the DB key from the email
const currentUserEmail = "mahekj05@gmail.com";
const currentUserKey = currentUserEmail.replace(/\./g, '_');

// listen for typing under the same key used elsewhere
db.ref('status/' + currentUserKey + '/typing').on('value', (snapshot) => {
  const isTyping = snapshot.val();
  typingIndicator.style.display = isTyping ? 'block' : 'none';
});

let currentKey = null;
let childListener = null;
let allChats = [];
let replyToText = null;
let searchTimeout;

// Fix for system back button functionality
let isInChatView = false;
// --- Infinite scroll variables ---
let isLoadingOlderMessages = false;
let hasMoreMessages = true;
let oldestLoadedTimestamp = null;

// --- Infinite scroll ---
let oldestLoadedKey = null;
let isLoadingOlder = false;
let reachedBeginning = false;

// --- Store messages ---
let messageStore = {};
let lastRenderedDate = null; 
let lastRenderedMsgTime = 0;
let initialLoadDone = false;
// global tracker// *** FIX: Track last date divider ***

// --- Cache helpers ---





function getCachedMessages(chatKey) { const c = localStorage.getItem('chat_' + chatKey); return c ? JSON.parse(c) : null; }

// --- Load cached chats ---
// --- Load cached chat list (optimized) ---
function getCachedChatList() {
  const c = localStorage.getItem('cachedChatList');
  return c ? JSON.parse(c) : null;
}

function cacheChatList(chatListData) {
  localStorage.setItem('cachedChatList', JSON.stringify(chatListData));
}

// Optimized: Only cache last message for each chat
function renderChatsOptimized(chatListData) {
  chatList.innerHTML = '';
  allChats = [];
  
  const sortedKeys = Object.keys(chatListData).sort((a, b) =>
    chatListData[b].lastTimestamp - chatListData[a].lastTimestamp
  );
  
  sortedKeys.forEach(chatKey => {
    const { lastMessage, lastTimestamp } = chatListData[chatKey];
    const lastTime = new Date(lastTimestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
    
    const item = document.createElement('div');
    item.className = 'chat-item';
    item.onclick = () => openChat(chatKey);
    
    const name = document.createElement('div');
    name.className = 'chat-name';
    name.textContent = chatKey.replace(/_/g, '.');
    
    const preview = document.createElement('div');
    preview.className = 'chat-preview';
    preview.textContent = lastMessage.text || '[Media]';
    
    const time = document.createElement('div');
    time.className = 'chat-time';
    time.textContent = lastTime;
    
    item.appendChild(name);
    item.appendChild(preview);
    item.appendChild(time);
    chatList.appendChild(item);
    
    allChats.push({ key: chatKey, element: item, preview: lastMessage.text });
  });
}

// Load optimized chat list
const cachedChatList = getCachedChatList();
if (cachedChatList) renderChatsOptimized(cachedChatList);

// Only cache last messages for chat list, not all messages
db.ref('chats').on('value', snapshot => {
  const chats = snapshot.val();
  if (!chats) return;
  
  const chatListData = {};
  
  Object.keys(chats).forEach(chatKey => {
    const messages = chats[chatKey];
    const messageKeys = Object.keys(messages).map(Number);
    
    if (messageKeys.length > 0) {
      const lastKey = Math.max(...messageKeys);
      chatListData[chatKey] = {
        lastMessage: messages[lastKey],
        lastTimestamp: lastKey
      };
    }
  });
  
  cacheChatList(chatListData);
  renderChatsOptimized(chatListData);
});

// use the correct brotherKey
function renderChats(chats) {
  chatList.innerHTML = '';
  allChats = [];
  const sortedKeys = Object.keys(chats).sort((a,b)=>{
    const lastA = Math.max(...Object.keys(chats[a]).map(Number));
    const lastB = Math.max(...Object.keys(chats[b]).map(Number));
    return lastB - lastA;
  });
  sortedKeys.forEach(key=>{
    const messages = chats[key];
    const timestamps = Object.keys(messages).map(Number).sort((a,b)=>a-b);
    const lastMsg = messages[timestamps[timestamps.length-1]];
    const lastTime = new Date(timestamps[timestamps.length-1]).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', hour12:true});
    
    
    const item = document.createElement('div');
    item.className = 'chat-item';
    item.onclick = ()=>openChat(key);
    const name = document.createElement('div'); name.className = 'chat-name'; name.textContent = key.replace(/_/g,'.');
    const preview = document.createElement('div'); preview.className = 'chat-preview'; preview.textContent = lastMsg.text;
    
    const event = new CustomEvent('chatOpened', { detail: key });
window.dispatchEvent(event);
    
    const time = document.createElement('div'); time.className = 'chat-time'; time.textContent = lastTime;
    item.appendChild(name); item.appendChild(preview); item.appendChild(time);
    chatList.appendChild(item);
    allChats.push({ key, element:item, preview:lastMsg.text });
  });
}

// --- Search ---
function filterChats() {
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(() => {
    const term = searchBox.value.toLowerCase();
    allChats.forEach(chat => {
      chat.element.style.display =
        chat.key.toLowerCase().includes(term) || chat.preview.toLowerCase().includes(term) ? '' : 'none';
    });
  }, 200);
}



// --- Date dividers ---
function formatDateSeparator(ts){
  const msgDate = new Date(Number(ts));
  const today = new Date();
  const yesterday = new Date(); yesterday.setDate(today.getDate()-1);
  if(msgDate.toDateString()===today.toDateString()) return "Today";
  else if(msgDate.toDateString()===yesterday.toDateString()) return "Yesterday";
  else return msgDate.toLocaleDateString([], { day:"numeric", month:"short", year:"numeric" });
}

function createDateDivider(label){
  const div = document.createElement("div");
  div.className = "date-divider";
  div.textContent = label;
  return div;
}


function highlightAndScrollTo(msgKey) {
  if (!msgKey) return;
  // prefer id format first
  const id = 'msg_' + msgKey;
  let target = document.getElementById(id);
  if (!target) {
    // fallback to data attribute
    target = document.querySelector('[data-msg-key="' + msgKey + '"]');
  }
  if (!target) {
    // If message not rendered yet, try small retry (best-effort)
    let tries = 0;
    const retry = setInterval(() => {
      tries++;
      let t = document.getElementById(id) || document.querySelector('[data-msg-key="' + msgKey + '"]');
      if (t) {
        clearInterval(retry);
        t.scrollIntoView({ behavior: 'smooth', block: 'center' });
        t.classList.add('message-highlight');
        setTimeout(() => t.classList.remove('message-highlight'), 2200);
      } else if (tries > 8) {
        clearInterval(retry);
        console.warn('Referenced message not found in DOM:', msgKey);
      }
    }, 150);
    return;
  }
  
  // scroll and highlight
  try {
    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
  } catch (e) {
    target.scrollIntoView();
  }
  target.classList.add('message-highlight');
  // remove highlight after a short while
  setTimeout(() => {
    target && target.classList.remove('message-highlight');
  }, 2200);
}

function buildMessageBubble(msgKey, val) {
  // create bubble wrapper & classes
  const div = document.createElement('div');
  div.className = 'bubble ' + (val.from === 'user' ? 'from-user' : 'from-brother');
  
  
  // Apply enhanced animation to new messages
  if (isNewMessage) {
    div.classList.add('enhanced-pop');
  }

  
  // reply arrow (swipe UI)
  const arrow = document.createElement('div');
  arrow.className = 'reply-arrow';
  arrow.innerHTML = '↩';
  div.appendChild(arrow);
  
  // attach swipe/reply behavior (re-uses your helper)
  attachSwipeHandlers(div, msgKey, val.text || val.url || '');
  
  // reply preview if present
  if (val.replyTo && messageStore[val.replyTo]) {
    const replyDiv = document.createElement('div');
    replyDiv.className = 'reply-box';
    // if the referenced message had text use it, otherwise if media show type
    const ref = messageStore[val.replyTo];
    replyDiv.textContent = ref && ref.text ? ref.text : (ref && ref.type ? '[' + (ref.type || 'media') + ']' : '');
    div.prepend(replyDiv);
  }
  
  // If media (gif/image) -> render image tag, allow optional text underneath
  if (val.type === 'gif' || val.type === 'image' || val.url) {
    const media = document.createElement('img');
    media.style.maxWidth = '260px';
    media.style.maxHeight = '260px';
    media.style.borderRadius = '8px';
    media.style.display = 'block';
    media.style.marginBottom = '6px';
    // prefer val.url; some payloads may include url or mediaUrl
    media.src = val.url || val.mediaUrl || '';
    media.alt = val.type || 'media';
    // add error handler to help debug CORS/missing URL
    media.addEventListener('error', () => {
      const err = document.createElement('div');
      err.style.fontSize = '12px';
      err.style.color = '#b00';
      err.textContent = '[Unable to load media]';
      div.insertBefore(err, media.nextSibling);
    });
    div.appendChild(media);
    if (val.text) {
  const textNode = document.createElement('div');
  textNode.innerHTML = linkify(val.text);
  div.appendChild(textNode);
}
  } else {
    // regular text-only message
    // text message
const textNode = document.createElement('div');
textNode.innerHTML = linkify(val.text || '');
div.appendChild(textNode);
  }
  
  // timestamp
  const timeNode = document.createElement('div');
  timeNode.className = 'msg-time';
  timeNode.textContent = new Date(Number(msgKey)).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
  div.appendChild(timeNode);
  
  return div;
}


// ensure the local name points to the same function used in renderMessages
buildMessageBubble = window.buildMessageBubble;

// --- Render messages (fixed) ---




// Replace your entire openChat function with this optimized version
function openChat(key) {
  listEl.classList.remove('active');
  chatEl.classList.add('active');
  
  // Reset state
  currentKey = key;
  document.getElementById('chatTitle').textContent = "Bubu😘";
  history.pushState({screen: "chat"}, "Chat");

  messageStore = {};
  lastRenderedDate = null;
  lastRenderedMsgTime = 0;
  messagesEl.innerHTML = '';
  initialLoadDone = false;
  
  // Reset infinite scroll variables
  isLoadingOlderMessages = false;
  hasMoreMessages = true;
  oldestLoadedTimestamp = null;

  // Show loading indicator
  messagesEl.innerHTML = '<div class="loading-indicator">Loading messages...</div>';
  
  // Load cached messages first for immediate display
  const cachedMsgs = getCachedMessages(key);
  if (cachedMsgs) {
    processAndRenderMessages(cachedMsgs);
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
  
  // Set up real-time listener with optimized query
  if (childListener) {
    db.ref('chats/' + currentKey).off('value', childListener);
  }
  
  childListener = db.ref('chats/' + currentKey)
    .orderByKey()
    .limitToLast(100) // Only get the most recent 100 messages initially
    .on('value', snap => {
      const msgs = snap.val();
      if (msgs) {
        cacheMessages(currentKey, msgs);
        processAndRenderMessages(msgs);
        
        // Remove loading indicator if it exists
        const loadingIndicator = messagesEl.querySelector('.loading-indicator');
        if (loadingIndicator) {
          messagesEl.removeChild(loadingIndicator);
        }
      }
    });
    
  // Add scroll event listener for infinite scroll
  messagesEl.addEventListener('scroll', handleScroll);
}

// Replace your renderMessages function with this optimized version
function processAndRenderMessages(messages) {
  if (!messages) return;
  
  // Convert to array and sort by timestamp
  const messageArray = Object.entries(messages)
    .map(([key, value]) => ({ key: Number(key), value }))
    .sort((a, b) => a.key - b.key); // Sort by timestamp (ascending order)
  
  const fragment = document.createDocumentFragment();
  let addedNewMessages = false;
  
  messageArray.forEach(({ key, value }) => {
    const msgKey = String(key);
    const val = value;
    
    if (!val || (!val.text && !val.type && !val.url)) return;
    
    // Check if this message is already rendered
    const existingMsg = document.getElementById('msg_' + msgKey) || 
                       document.querySelector('[data-msg-key="' + msgKey + '"]');
    if (existingMsg) return;
    
    // Add to messageStore
    messageStore[msgKey] = val;
    
    const msgDate = new Date(key);
    const dateLabel = formatDateSeparator(msgKey);
    
    // Date divider
    if (lastRenderedDate !== msgDate.toDateString()) {
      fragment.appendChild(createDateDivider(dateLabel));
      lastRenderedDate = msgDate.toDateString();
    }
    
    const div = buildMessageBubble(msgKey, val);
    fragment.appendChild(div);
    addedNewMessages = true;
    
    // Play sound only for new incoming messages
    if (initialLoadDone && val.from === "user" && key > lastRenderedMsgTime) {
      const snd = document.getElementById("receiveSound");
      if (snd) snd.play().catch(() => {});
    }
    
    // Update last seen
    if (key > lastRenderedMsgTime) {
      lastRenderedMsgTime = key;
    }
  });
  
  if (addedNewMessages) {
    messagesEl.appendChild(fragment);
    
 // Only scroll to bottom if we're not loading older messages and it's a new message
if (!isLoadingOlderMessages) {
  messagesEl.scrollTop = messagesEl.scrollHeight;
}
    
  }
  
  // Mark first load as done
  initialLoadDone = true;
}

// Update your cacheMessages function to maintain proper order
function cacheMessages(chatKey, data) {
  if (!data) return;
  
  // Get all message keys and sort them (newest first)
  const keys = Object.keys(data).map(Number).sort((a, b) => b - a);
  
  // Take only the latest 300 messages but maintain order
  if (keys.length > 300) {
    const limitedData = {};
    
    // Get the 300 newest messages but store them in chronological order
    keys.slice(0, 300)
      .sort((a, b) => a - b) // Sort in ascending order for proper caching
      .forEach(key => {
        limitedData[key] = data[key];
      });
      
    localStorage.setItem('chat_' + chatKey, JSON.stringify(limitedData));
  } else {
    localStorage.setItem('chat_' + chatKey, JSON.stringify(data));
  }
}

// Optimized function to load older messages
async function loadOlderMessages() {
  if (!currentKey || isLoadingOlderMessages || !hasMoreMessages) return;
  
  isLoadingOlderMessages = true;
  
  try {
    // Show loading indicator at the top
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'loading-indicator';
    loadingDiv.textContent = 'Loading older messages...';
    messagesEl.insertBefore(loadingDiv, messagesEl.firstChild);
    
    // Get the oldest timestamp we have loaded
    const messageKeys = Object.keys(messageStore).map(Number);
    const oldestKey = oldestLoadedTimestamp || Math.min(...messageKeys);
    
    // Query Firebase for older messages
    const snapshot = await db.ref('chats/' + currentKey)
      .orderByKey()
      .endBefore(String(oldestKey))
      .limitToLast(50)
      .once('value');
    
    const olderMessages = snapshot.val();
    
    if (!olderMessages || Object.keys(olderMessages).length === 0) {
      hasMoreMessages = false;
      loadingDiv.textContent = 'No older messages';
      setTimeout(() => {
        if (loadingDiv.parentNode === messagesEl) {
          messagesEl.removeChild(loadingDiv);
        }
      }, 2000);
      return;
    }
    
    // Add older messages to messageStore
    Object.assign(messageStore, olderMessages);
    
    // Render older messages at the top
    renderOlderMessages(olderMessages);
    
    // Update oldest loaded timestamp
    const olderKeys = Object.keys(olderMessages).map(Number);
    oldestLoadedTimestamp = Math.min(...olderKeys);
    
    // Remove loading indicator
    if (loadingDiv.parentNode === messagesEl) {
      messagesEl.removeChild(loadingDiv);
    }
    
  } catch (error) {
    console.error('Error loading older messages:', error);
    const loadingDiv = messagesEl.querySelector('.loading-indicator');
    if (loadingDiv && loadingDiv.parentNode === messagesEl) {
      loadingDiv.textContent = 'Error loading messages';
      setTimeout(() => {
        if (loadingDiv.parentNode === messagesEl) {
          messagesEl.removeChild(loadingDiv);
        }
      }, 2000);
    }
  } finally {
    isLoadingOlderMessages = false;
  }
}


// Optimized function to render older messages
function renderOlderMessages(messages) {
  // Convert to array and sort by timestamp
  const messageArray = Object.entries(messages)
    .map(([key, value]) => ({ key: Number(key), value }))
    .sort((a, b) => a.key - b.key); // Sort by timestamp (ascending order)
  
  const fragment = document.createDocumentFragment();
  let currentDate = null;
  
  messageArray.forEach(({ key, value }) => {
    const msgKey = String(key);
    const val = value;
    
    if (!val || (!val.text && !val.type && !val.url)) return;
    
    const msgDate = new Date(key);
    const dateLabel = formatDateSeparator(msgKey);
    
    // Date divider
    if (currentDate !== msgDate.toDateString()) {
      fragment.appendChild(createDateDivider(dateLabel));
      currentDate = msgDate.toDateString();
    }
    
    const div = buildMessageBubble(msgKey, val);
    fragment.appendChild(div);
  });
  
  // Get first child to insert before
  const firstChild = messagesEl.firstChild;
  messagesEl.insertBefore(fragment, firstChild);
}
//script set 






// --- Send reply ---
function sendReply(){
  const text = replyInput.value.trim();
  if(text==='' || !currentKey) return;
  const timestamp = Date.now();
  const message = {text,from:'brother'};
  if(replyToText){message.replyTo = replyToText.msgKey; replyToText=null;}
  
  db.ref('chats/'+currentKey+'/'+timestamp).set(message);
  db.ref("status/brother/typing").set(false); // stop typing

  document.getElementById("sendSound").play();
  
  replyInput.value='';
  replyInput.style.height="auto";
  replyInput.focus();
  replyPreviewContainer.innerHTML='';
}



// --- Swipe & reply handlers ---
function attachSwipeHandlers(bubbleEl,msgKey,text){
  let startX=0,startY=0,currentX=0,dragging=false,vibrated=false;
  bubbleEl.addEventListener('touchstart',e=>{
    // Don't start swipe if clicking on a link
    if (e.target.closest('.message-link')) return;
    
    startX=e.touches[0].clientX; 
    startY=e.touches[0].clientY; 
    dragging=true; 
    vibrated=false; 
    bubbleEl.style.transition="none";
  });
  bubbleEl.addEventListener('touchmove', e => {
      if (!dragging) return;
      
      // Don't process swipe if clicking on a link
      if (e.target.closest('.message-link')) {
        dragging = false;
        return;
      }
      
      currentX = e.touches[0].clientX - startX;
      const dy = e.touches[0].clientY - startY;
      if (Math.abs(dy) > 30) return;  
      const offset=Math.sign(currentX)*Math.min(Math.abs(currentX),120);
    bubbleEl.style.transform=`translateX(${offset}px)`;
    if(Math.abs(offset)>50 && !bubbleEl.classList.contains("show-arrow")){
      bubbleEl.classList.add("show-arrow");
      if(!vibrated && navigator.vibrate){navigator.vibrate([80,50,80]);vibrated=true;}
    } else bubbleEl.classList.remove("show-arrow");
  });
  bubbleEl.addEventListener('touchend',()=>{
    dragging=false; bubbleEl.style.transition="transform 0.2s ease"; bubbleEl.classList.remove("show-arrow");
    if(Math.abs(currentX)>80){
      replyToText={msgKey,text};
      replyPreviewContainer.innerHTML=`<div class="reply-preview"><div class="reply-preview-text">${text}</div><button onclick="cancelReply()">✖</button></div>`;
      replyInput.focus();
    }
    bubbleEl.style.transform="translateX(0px)"; currentX=0;
  });
}

function cancelReply(){replyToText=null; replyPreviewContainer.innerHTML=''; replyInput.placeholder='Type a message…';}
replyInput.addEventListener('blur',()=>{if(!replyInput.value && !replyToText) cancelReply();});

// --- Dark mode ---
// --- Dark mode ---
const darkModeToggle = document.getElementById("darkModeToggle");
const themeMeta = document.getElementById("theme-color-meta");

function updateThemeColor() {
  if (document.body.classList.contains("dark")) {
    themeMeta.setAttribute("content", "#13221F"); // dark mode color
  } else {
    themeMeta.setAttribute("content", "#DDF2ED"); // light mode color
  }
}




// On load, check saved mode
if (localStorage.getItem("darkMode") === "enabled") {
  document.body.classList.add("dark");
  darkModeToggle.textContent = "☀️";
}
updateThemeColor();

// Toggle button click
darkModeToggle.addEventListener("click", () => {
  document.body.classList.toggle("dark");
  if (document.body.classList.contains("dark")) {
    localStorage.setItem("darkMode", "enabled");
    darkModeToggle.textContent = "☀️";
  } else {
    localStorage.setItem("darkMode", "disabled");
    darkModeToggle.textContent = "🌙";
  }
  updateThemeColor();
});




window.addEventListener("popstate", function(event) {
  if (chatEl.classList.contains('active')) {
    chatEl.classList.remove('active');
    listEl.classList.add('active');
    currentKey = null;
  } else {
    history.back();
  }
});
</script>




<script>
  // ensure this runs after firebase.initializeApp(...) and after "const db = firebase.database();"
  const userEmail = "mahekj05@gmail.com";
  const userKey = userEmail.replace(/\./g, '_');
  
  // debug helper
  db.ref('.info/connected').on('value', snap => {
    console.log('DEBUG: .info/connected =>', snap.val());
  });
  
  // call setPresence that you already defined (or add below if missing)
  
  
  // For UI: update avatar border on status changes (you already have similar code)
  db.ref('status/' + userKey).on('value', snapshot => {
    const status = snapshot.val();
    console.log('DEBUG: status snapshot', status);
    const userLogo = document.getElementById('userLogo');
    if (!userLogo) return;
    let state = null;
    if (status && typeof status === 'object') state = status.state;
    else state = status;
    userLogo.style.border = (state === 'online') ? '3px solid green' : '3px solid orange';
  });
</script>
<style>
.chat-item {
  position: relative; /* Important for absolute badge positioning */
}
.unread-badge {
  position: absolute;
  top: 40px;
  right: 20px;
  background: #25D366; /* WhatsApp green */
  color: white;
  font-size: 12px;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 12px;
  min-width: 18px;
  text-align: center;
  display: inline-block; /* Show by default for testing */
}
</style>
<script>
// --- UNREAD BADGES & LAST SEEN TRACKING ---
let unreadCounts = {}; // store counts per chat key
let lastSeen = {};     // store last seen timestamp per chat

// --- Load/Save last seen from localStorage ---
function saveLastSeen() {
  localStorage.setItem('lastSeen', JSON.stringify(lastSeen));
}
function loadLastSeen() {
  const data = localStorage.getItem('lastSeen');
  if (data) lastSeen = JSON.parse(data);
}
loadLastSeen();

// --- Render chats and show badges ---
const oldRenderChats = renderChats;
renderChats = function(chats) {
  oldRenderChats(chats); // call original renderChats
  Object.keys(chats).forEach(key => {
    const item = allChats.find(c => c.key === key)?.element;
    if (item) {
      let badge = item.querySelector('.unread-badge');
      if (!badge) {
        badge = document.createElement('span');
        badge.className = 'unread-badge';
        item.appendChild(badge);
      }
      badge.textContent = unreadCounts[key] || 0;
      badge.style.display = (unreadCounts[key] || 0) > 0 ? 'inline-block' : 'none';
    }
  });
};

// --- Reset unread count when opening a chat ---
const oldOpenChat = openChat;
openChat = function(key) {
  unreadCounts[key] = 0;
  lastSeen[key] = Date.now();
  saveLastSeen();
  renderChatsOptimized(getCachedChatList() || {});
  oldOpenChat(key);
};

// --- Listen for new messages (child_added and child_changed) ---
db.ref('chats').on('child_added', snap => {
  const chatKey = snap.key;
  const msgs = snap.val();
  const lastKey = Math.max(...Object.keys(msgs).map(Number));
  const lastMsg = msgs[lastKey];
  const seenTime = lastSeen[chatKey] || 0;

  if (lastMsg.from === 'user' && lastKey > seenTime && chatKey !== currentKey) {
    unreadCounts[chatKey] = (unreadCounts[chatKey] || 0) + 1;
    renderChatsOptimized(getCachedChatList() || {});
  }
});

db.ref('chats').on('child_changed', snap => {
  const chatKey = snap.key;
  const msgs = snap.val();
  const lastKey = Math.max(...Object.keys(msgs).map(Number));
  const lastMsg = msgs[lastKey];
  const seenTime = lastSeen[chatKey] || 0;

  if (lastMsg.from === 'user' && lastKey > seenTime && chatKey !== currentKey) {
    unreadCounts[chatKey] = (unreadCounts[chatKey] || 0) + 1;
    renderChatsOptimized(getCachedChatList() || {});
  }
});
  // When going back to inbox, badges will already be updated
</script>
<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker
        .register("./service-worker.js")
        .then((reg) => console.log("Service Worker registered:", reg.scope))
        .catch((err) => console.error("Service Worker failed:", err));
    });
  }
</script>
  <script>
    // Prevent pinch zoom
    document.addEventListener('touchmove', function(event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
    }, { passive: false });
    
    // Prevent double-tap zoom
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, { passive: false });
  </script>

<script>
/* ===== Configuration ===== */
// Add your GIPHY API key here:
/* ===== Tenor configuration ===== */
// Get a Tenor API key: (Google Cloud Console -> enable Tenor API & create key)
const TENOR_API_KEY = "AIzaSyB_R_WfxdRYAnMCykNpxDAAJRqKkjpgUTs"; // <-- replace with your key
const TENOR_CLIENT_KEY = "brother dashboard"; // optional string identifying your app (use same value for all calls) // <-- get one at https://developers.giphy.com/ (free)

/* ===== Emoji picker setup using emoji-button ===== */
const { EmojiButton } = window;
let picker;
try{
  picker = new EmojiButton({ position: 'top-end', zIndex: 99999 });
  const emojiBtn = document.getElementById('emojiBtn');
  const replyInput = document.getElementById('replyInput');

  emojiBtn.addEventListener('click', () => {
    picker.togglePicker(emojiBtn);
  });

  picker.on('emoji', selection => {
    // Insert emoji at cursor position in textarea
    insertAtCursor(replyInput, selection.emoji);
    replyInput.focus();
  });
} catch(e){
  console.warn("Emoji picker failed to load:", e);
}

/* helper: insert at cursor for textarea */
function insertAtCursor(input, text) {
  const start = input.selectionStart || 0;
  const end = input.selectionEnd || 0;
  const value = input.value || '';
  input.value = value.slice(0, start) + text + value.slice(end);
  // move cursor after inserted text
  const newPos = start + text.length;
  input.selectionStart = input.selectionEnd = newPos;
  input.dispatchEvent(new Event('input'));
}

/* ===== GIF picker modal + search ===== */
const gifBtn = document.getElementById('gifBtn');
const gifModal = document.getElementById('gifModal');
const gifSearch = document.getElementById('gifSearch');
const gifSearchBtn = document.getElementById('gifSearchBtn');
const gifResults = document.getElementById('gifResults');
const gifCloseBtn = document.getElementById('gifCloseBtn');

gifBtn.addEventListener('click', () => {
  console.log("GIF button clicked");
  gifModal.style.display = 'flex';
  searchTenor('trending');
});

gifCloseBtn.addEventListener('click', () => {
  gifModal.style.display = 'none';
  gifModal.setAttribute('aria-hidden','true');
});

gifSearchBtn.addEventListener('click', () => {
  const q = gifSearch.value.trim();
  if (!q) return;
  searchTenor(q);
});

async function searchTenor(query) {
  gifResults.innerHTML = 'Loading…';
  try {
    let url;
    const encoded = encodeURIComponent(query || '');
    // Trending / featured
    if (query === 'trending' || !query) {
      url = `https://tenor.googleapis.com/v2/featured?key=${TENOR_API_KEY}&client_key=${TENOR_CLIENT_KEY}&limit=25&contentfilter=low`;
    } else {
      // Search endpoint
      url = `https://tenor.googleapis.com/v2/search?q=${encoded}&key=${TENOR_API_KEY}&client_key=${TENOR_CLIENT_KEY}&limit=25&contentfilter=low`;
    }
    
    const res = await fetch(url);
    if (!res.ok) throw new Error('Tenor fetch failed: ' + res.status);
    const json = await res.json();
    
    gifResults.innerHTML = '';
    
    const results = json.results || [];
    results.forEach(r => {
      // defensive: pick a small preview format first (nanogif / tinygif), then fallback
      const mf = r.media_formats || {};
      const preview =
        (mf.nanogif && mf.nanogif.url) ||
        (mf.tinygif && mf.tinygif.url) ||
        (mf.nanowebp && mf.nanowebp.url) ||
        (mf.gif && mf.gif.url) ||
        null;
      
      // pick the share/full url (prefer full gif)
      const full =
        (mf.gif && mf.gif.url) ||
        (mf.mediumgif && mf.mediumgif.url) ||
        (mf.nanowebp && mf.nanowebp.url) ||
        preview;
      
      if (!preview) return; // no usable preview -> skip
      
      const img = document.createElement('img');
      img.className = 'gif-thumb';
      img.src = preview;
      img.alt = r.content_description || r.id || 'gif';
      
      img.addEventListener('click', () => {
        // send selected GIF as media message (your existing helper)
        sendMediaMessage({ type: 'gif', url: full });
        
        // optional: register the share with Tenor to improve search relevancy
        // (don't block UI on this; fire-and-forget)
        try {
          fetch(`https://tenor.googleapis.com/v2/registershare?id=${r.id}&key=${TENOR_API_KEY}&client_key=${TENOR_CLIENT_KEY}&q=${encoded}`)
            .catch(() => {});
        } catch (e) {}
        
        gifModal.style.display = 'none';
      });
      
      gifResults.appendChild(img);
    });
    
    if (results.length === 0) gifResults.innerHTML = 'No GIFs found.';
  } catch (err) {
    console.error('Tenor search error', err);
    gifResults.innerHTML = 'Search failed.';
  }
}

/* ===== Attach/file input (optional) ===== */
const attachBtn = document.getElementById('attachBtn');
const attachFile = document.getElementById('attachFile');

attachBtn.addEventListener('click', () => attachFile.click());


/* ===== Image compression helper (compress to approx target size and return dataURL) ===== */

function blobToDataURL(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

function imageBitmapOrImgFromFile(file) {
  // returns a Promise that resolves with an object {bitmap, width, height}
  if (window.createImageBitmap) {
    return createImageBitmap(file).then(bitmap => ({ bitmap, width: bitmap.width, height: bitmap.height }));
  } else {
    // fallback for older browsers
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        // draw into an offscreen canvas to create an ImageBitmap equivalent
        resolve({ img, width: img.naturalWidth, height: img.naturalHeight });
      };
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }
}

function canvasToBlob(canvas, quality) {
  return new Promise((resolve) => {
    canvas.toBlob(blob => resolve(blob), 'image/jpeg', quality);
  });
}

/**
 * Compress a File/Blob image to an approximate target size (KB).
 * Returns a Promise<string> resolving to a dataURL (JPEG).
 *
 * @param {File|Blob} file - source image file
 * @param {number} targetKb - desired max size in kilobytes (e.g. 200)
 * @param {object} opts - optional { maxWidth, maxHeight, minQuality }
 */
async function compressImageFile(file, targetKb = 200, opts = {}) {
  const maxWidth = opts.maxWidth || 1920;
  const maxHeight = opts.maxHeight || 1920;
  const minQuality = (opts.minQuality !== undefined) ? opts.minQuality : 0.45;
  
  // Load image (bitmap or img)
  const imgObj = await imageBitmapOrImgFromFile(file);
  let srcWidth = imgObj.width;
  let srcHeight = imgObj.height;
  
  // compute initial scale to fit maxWidth/maxHeight
  let scale = Math.min(1, maxWidth / srcWidth, maxHeight / srcHeight);
  let targetWidth = Math.round(srcWidth * scale);
  let targetHeight = Math.round(srcHeight * scale);
  
  // create canvas
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // helper to draw (bitmap or img) into canvas with current dims
  function drawToCanvas() {
    canvas.width = targetWidth;
    canvas.height = targetHeight;
    // if we have a bitmap use drawImage(bitmap,...)
    if (imgObj.bitmap) {
      ctx.drawImage(imgObj.bitmap, 0, 0, targetWidth, targetHeight);
    } else if (imgObj.img) {
      ctx.drawImage(imgObj.img, 0, 0, targetWidth, targetHeight);
    }
  }
  
  // iterative quality reduction loop, optionally downscale if quality floor hits
  let quality = 0.92;
  let blob = null;
  let dataUrl = null;
  const targetBytes = targetKb * 1024;
  
  // try multiple attempts: reduce quality first, then scale down if needed
  for (let attempt = 0; attempt < 8; attempt++) {
    drawToCanvas();
    blob = await canvasToBlob(canvas, quality);
    if (!blob) break;
    if (blob.size <= targetBytes || quality <= minQuality) {
      dataUrl = await blobToDataURL(blob);
      if (blob.size <= targetBytes) return dataUrl;
      // if we hit minQuality but still too big — we'll scale down image and try again
    }
    
    // if blob is too big, reduce quality
    if (blob.size > targetBytes) {
      // lower quality step
      quality = quality - 0.12;
      if (quality < minQuality) quality = minQuality;
    }
    
    // if at minimum quality and still large, scale down the dimensions by 0.85 and retry
    if (quality <= minQuality && blob.size > targetBytes) {
      targetWidth = Math.max(200, Math.round(targetWidth * 0.85));
      targetHeight = Math.max(200, Math.round(targetHeight * 0.85));
      // reset quality to a reasonable value for next loop
      quality = Math.max(minQuality, 0.82);
    }
  }
  
  // final fallback: return the last generated dataURL even if slightly larger than target
  if (blob) dataUrl = await blobToDataURL(blob);
  return dataUrl;
}

/* ===== Replace attachFile handling to compress before sending ===== */
attachFile.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  // Only compress images (not gifs/videos). GIFs you may want to pass through as-is.
  if (!f.type.startsWith('image/')) {
    // fallback: send as-is (or handle video differently)
    const reader = new FileReader();
    reader.onload = function(ev) {
      sendMediaMessage({ type: 'image', url: ev.target.result });
    };
    reader.readAsDataURL(f);
    attachFile.value = '';
    return;
  }
  
  try {
    // compress to ~200 KB
    const compressedDataUrl = await compressImageFile(f, 200, { maxWidth: 1600, maxHeight: 1600 });
    if (compressedDataUrl) {
      sendMediaMessage({ type: 'image', url: compressedDataUrl });
    } else {
      // fallback if compression failed
      const reader = new FileReader();
      reader.onload = function(ev) {
        sendMediaMessage({ type: 'image', url: ev.target.result });
      };
      reader.readAsDataURL(f);
    }
  } catch (err) {
    console.error('Image compression failed', err);
    // fallback send original as dataURL (beware of DB size)
    const reader = new FileReader();
    reader.onload = function(ev) {
      sendMediaMessage({ type: 'image', url: ev.target.result });
    };
    reader.readAsDataURL(f);
  }
  attachFile.value = '';
});

/* ===== Paste handler: compress pasted image blob before sending ===== */
document.addEventListener('paste', async (e) => {
  const items = e.clipboardData && e.clipboardData.items;
  if (!items) return;
  for (const it of items) {
    if (it.kind === 'file') {
      const blob = it.getAsFile();
      if (blob && blob.type.startsWith('image/')) {
        try {
          const compressed = await compressImageFile(blob, 200, { maxWidth: 1600, maxHeight: 1600 });
          if (compressed) sendMediaMessage({ type: 'image', url: compressed });
        } catch (err) {
          console.error('Paste compression failed', err);
          // fallback to sending original
          const reader = new FileReader();
          reader.onload = (ev) => sendMediaMessage({ type: 'image', url: ev.target.result });
          reader.readAsDataURL(blob);
        }
        e.preventDefault();
        return;
      }
    }
    if (it.kind === 'string' && it.type === 'text/plain') {
      it.getAsString(str => {
        if (str.match(/\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || str.includes('giphy.com')) {
          // unchanged for URLs
          sendMediaMessage({ type: 'gif', url: str });
        }
      });
    }
  }
});


/* ===== Paste handler for image/GIF URLs or direct images ===== */
document.addEventListener('paste', (e) => {
  // If clipboard contains an image file, or URL
  const items = e.clipboardData && e.clipboardData.items;
  if(!items) return;
  for (const it of items) {
    if (it.kind === 'file') {
      const blob = it.getAsFile();
      if (blob) {
        // File pasted -> read and send as dataURL (or upload to Storage in production)
        const reader = new FileReader();
        reader.onload = (ev) => sendMediaMessage({ type: 'image', url: ev.target.result });
        reader.readAsDataURL(blob);
        e.preventDefault();
        return;
      }
    }
    if (it.kind === 'string' && it.type === 'text/plain') {
      it.getAsString(str => {
        // if user pasted a giphy or image URL, send as gif/image
        if (str.match(/\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || str.includes('giphy.com')) {
          sendMediaMessage({ type: 'gif', url: str });
        }
      });
    }
  }
});

/* ===== sendMediaMessage helper =====
   Sends a chat message object to your DB with type and url.
*/
function sendMediaMessage(payload){
  // payload = { type: 'gif' | 'image', url: '...' }
  if(!currentKey) { alert('Open a chat first'); return; }
  const timestamp = Date.now();
  const message = { from: 'brother', type: payload.type, url: payload.url };
  // optionally include replyTo
  if(replyToText){ message.replyTo = replyToText.msgKey; replyToText=null; replyPreviewContainer.innerHTML=''; }
  db.ref('chats/' + currentKey + '/' + timestamp).set(message);
  document.getElementById("sendSound").play().catch(()=>{});
}

/* ===== Override send button to allow sending text or GIF/image URLs typed in ===== */
document.getElementById('sendBtn').addEventListener('click', sendReply);

const originalSendReply = window.sendReply || function(){};
window.sendReply = function(){
  const txtEl = document.getElementById('replyInput');
  const text = (txtEl.value || '').trim();
  if(!currentKey) return;
  if(!text && !replyToText) return; // nothing to send
  // if text is a direct image/GIF URL, send as media
  if(text.match(/^https?:\/\/.*\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || text.includes('giphy.com')) {
    sendMediaMessage({ type: 'gif', url: text });
    txtEl.value = '';
    return;
  }
  // else send as regular text
  const timestamp = Date.now();
  const message = { text, from:'brother' };
  if(replyToText){message.replyTo = replyToText.msgKey; replyToText=null; replyPreviewContainer.innerHTML='';}
  db.ref('chats/'+currentKey+'/'+timestamp).set(message);
  db.ref("status/brother/typing").set(false);
  try{ document.getElementById("sendSound").play(); }catch(e){}
  txtEl.value='';
  txtEl.style.height="auto";
  txtEl.focus();
};

/* ===== Render GIF / image in message bubble =====
   Modify your existing buildMessageBubble to handle `val.type === 'gif'` or `val.type === 'image'`.
   If you already have buildMessageBubble defined above, replace the rendering part with the snippet below.
*/
window.buildMessageBubble = function(msgKey, val) {
  const div = document.createElement('div');
  div.className = 'bubble ' + (val.from === 'user' ? 'from-user' : 'from-brother');
  div.setAttribute('data-msg-key', String(msgKey));
  div.id = 'msg_' + String(msgKey);
  div.style.position = 'relative'; // needed for media menu
  
  // reply arrow
  const arrow = document.createElement('div');
  arrow.className = 'reply-arrow';
  arrow.innerHTML = '↩';
  div.appendChild(arrow);
  attachSwipeHandlers(div, msgKey, val.text || '');
  
  // reply preview
  if (val.replyTo && messageStore[val.replyTo]) {
    const replyDiv = document.createElement('div');
    replyDiv.className = 'reply-box';
    const referenced = messageStore[val.replyTo];
    if (referenced && referenced.text) {
  const truncatedText = referenced.text.length > 120 ?
    referenced.text.slice(0, 120) + '…' : referenced.text;
  replyDiv.innerHTML = linkify(truncatedText);
} else {
  replyDiv.textContent = '[media]';
}
    
    replyDiv.addEventListener('click', (e) => {
      e.stopPropagation();
      e.stopImmediatePropagation(); // prevent long-press interference
      highlightAndScrollTo(val.replyTo);
    });
    
    div.prepend(replyDiv);
  }
  
  // media (image/gif)
  if (val.type === 'gif' || val.type === 'image') {
    const media = document.createElement('img');
    media.style.maxWidth = '100%';
    media.style.maxHeight = '260px';
    media.style.borderRadius = '8px';
    media.style.display = 'block';
    media.style.marginBottom = '6px';
    media.src = val.url;
    media.alt = val.type;
    div.appendChild(media);
    
    // ⋮ menu for media
    const menuBtn = document.createElement('button');
    menuBtn.innerHTML = '⋮';
    menuBtn.className = 'menu-btn';
    menuBtn.style.position = 'absolute';
    menuBtn.style.top = '6px';
    menuBtn.style.right = '6px';
    menuBtn.style.background = 'transparent';
    menuBtn.style.border = 'none';
    menuBtn.style.fontSize = '18px';
    menuBtn.style.cursor = 'pointer';
    
    const menu = createDeleteMenu(msgKey);
    div.appendChild(menu);
    
    menuBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      menu.style.display = (menu.style.display === 'none') ? 'block' : 'none';
    });
    
    document.addEventListener('click', () => { menu.style.display = 'none'; });
    div.appendChild(menuBtn);
    
    if (val.text) {
  const textNode = document.createElement('div');
  textNode.innerHTML = linkify(val.text);
  div.appendChild(textNode);
}
    
} else {
  // text message
  const textNode = document.createElement('div');
  textNode.innerHTML = linkify(val.text || '');
  div.appendChild(textNode);
  
  // long press support - modified to ignore link clicks
  let pressTimer;
  const startPress = (e) => {
    // Don't start long press if clicking on a link or reply box
    if (e.target.closest('.message-link') || e.target.closest('.reply-box')) return;
    
    e.preventDefault();
    pressTimer = setTimeout(() => {
      if (confirm('Delete this message?')) {
        const chatKey = currentKey;
        db.ref('chats/' + chatKey + '/' + msgKey).remove()
          .then(() => console.log('Text deleted:', msgKey))
          .catch(err => console.error('Failed to delete text:', err));
      }
    }, 700);
  };
    const cancelPress = () => clearTimeout(pressTimer);
    
    div.addEventListener('mousedown', startPress);
    div.addEventListener('mouseup', cancelPress);
    div.addEventListener('mouseleave', cancelPress);
    div.addEventListener('touchstart', startPress);
    div.addEventListener('touchend', cancelPress);
    div.addEventListener('touchmove', cancelPress);
  }
  
  // timestamp
  const timeNode = document.createElement('div');
  timeNode.className = 'msg-time';
  timeNode.textContent = new Date(Number(msgKey)).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
  div.appendChild(timeNode);
  
  return div;
};

// helper to create delete menu for media
function createDeleteMenu(msgKey) {
  const menu = document.createElement('div');
  menu.className = 'menu-popup';
  menu.style.position = 'absolute';
  menu.style.top = '28px';
  menu.style.right = '6px';
  menu.style.background = 'grey';
  menu.style.border = '1px solid #ccc';
  menu.style.borderRadius = '6px';
  menu.style.padding = '4px 0';
  menu.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
  menu.style.display = 'none';
  menu.style.zIndex = 100;
  
  const delOption = document.createElement('div');
  delOption.textContent = 'Delete';
  delOption.style.padding = '6px 12px';
  delOption.style.cursor = 'pointer';
  delOption.addEventListener('mouseover', () => { delOption.style.background = '#f0f0f0'; });
  delOption.addEventListener('mouseout', () => { delOption.style.background = 'transparent'; });
  
  delOption.addEventListener('click', (e) => {
    e.stopPropagation();
    menu.style.display = 'none';
    if (!confirm('Delete this message?')) return;
    const chatKey = currentKey;
    db.ref('chats/' + chatKey + '/' + msgKey).remove()
      .then(() => console.log('Deleted:', msgKey))
      .catch(err => console.error('Failed to delete:', err));
  });
  
  menu.appendChild(delOption);
  return menu;
}
</script>
<script>
  //highlight reply bubble 
  
  
  function highlightAndScrollTo(msgKey) {
  if (!msgKey) return;
  const id = 'msg_' + msgKey;
  let target = document.getElementById(id) || document.querySelector('[data-msg-key="'+msgKey+'"]');
  if (!target) return;

  target.scrollIntoView({ behavior: 'smooth', block: 'center' });

  // Apply grey/orange highlight temporarily
  target.classList.add('message-highlight');
  setTimeout(() => {
    target.classList.remove('message-highlight');
  }, 2000);
}
</script>
<!-- your existing page content -->



  <!-- LIGHTBOX MARKUP -->
  <div id="lightbox" class="lightbox" aria-hidden="true" style="background: black;">
    <div class="inner" role="dialog" aria-modal="true">
      <button class="btn close" aria-label="Close"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"
     xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Back">
  <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round"/>
</svg></button>
      <button class="btn prev" aria-label="Previous">
        
        <svg width="130" height="44" viewBox="0 0 160 44" xmlns="http://www.w3.org/2000/svg"
     role="img" aria-label="Download">
  <g fill="none">
    <rect x="1" y="1" width="108" height="42" rx="22" fill="currentColor" opacity="0.08" stroke="currentColor"/>


    <!-- Text -->
    <text x="20" y="27" font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial" font-size="18"
          fill="currentColor">Previous</text>
  </g>
</svg></button>
      <div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center;">
        <img id="lightboxImg" src="" alt="" />
      </div>
      <button class="btn next" aria-label="Next">
              <svg width="130" height="44" viewBox="0 0 160 44" xmlns="http://www.w3.org/2000/svg"
     role="img" aria-label="Download">
  <g fill="none">
    <rect x="1" y="1" width="108" height="42" rx="22" fill="currentColor" opacity="0.08" stroke="currentColor"/>
    <!-- Text -->
    <text x="35" y="27" font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial" font-size="18"
          fill="currentColor">Next</text>
  </g>
</svg>
      </button>
      <a id="lightboxDownload" class="btn download" aria-label="Download" target="_blank" rel="noopener"><!-- Download button -->
<svg width="130" height="44" viewBox="0 0 160 44" xmlns="http://www.w3.org/2000/svg"
     role="img" aria-label="Download">
  <g fill="none">
    <rect x="1" y="1" width="158" height="42" rx="22" fill="currentColor" opacity="0.08" stroke="currentColor"/>
    <!-- Icon -->
    <g transform="translate(18,10)" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 0v10"/>
      <path d="m7 6 5 5 5-5"/>
      <path d="M3 20h18"/>
    </g>
    <!-- Text -->
    <text x="64" y="27" font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial" font-size="18"
          fill="currentColor">Download</text>
  </g>
</svg></a>
      <div class="counter" id="lightboxCounter"></div>
    </div>
  </div>

  <!-- LIGHTBOX SCRIPT -->
  <script>
  (function(){
    const messagesEl = document.getElementById('messages');
    const lightbox = document.getElementById('lightbox');
    const lImg = document.getElementById('lightboxImg');
    const btnClose = lightbox.querySelector('.close');
    const btnPrev = lightbox.querySelector('.prev');
    const btnNext = lightbox.querySelector('.next');
    const btnDownload = document.getElementById('lightboxDownload');
    const counter = document.getElementById('lightboxCounter');

    let gallery = [], idx = 0;

    function buildGallery(){
      gallery = Array.from(messagesEl.querySelectorAll('img')).map(i=>i.src);
    }
    function openAt(src){
      buildGallery();
      idx = gallery.indexOf(src);
      if(idx === -1) { gallery.unshift(src); idx = 0; }
      show();
    }
    function show(){
      lImg.src = gallery[idx];
      lightbox.classList.add('open');
      btnDownload.href = gallery[idx];
      btnDownload.setAttribute('download','image');
      counter.textContent = (gallery.length>1) ? (idx+1)+' / '+gallery.length : '';
    }
    function close(){ lightbox.classList.remove('open'); }
    function prev(){ idx=(idx-1+gallery.length)%gallery.length; show(); }
    function next(){ idx=(idx+1)%gallery.length; show(); }

    messagesEl.addEventListener('click', e=>{
      const img=e.target.closest('img');
      if(img) openAt(img.src);
    });
    btnClose.addEventListener('click', close);
    btnPrev.addEventListener('click', prev);
    btnNext.addEventListener('click', next);
    document.addEventListener('keydown', e=>{
      if(!lightbox.classList.contains('open')) return;
      if(e.key==='Escape') close();
      if(e.key==='ArrowLeft') prev();
      if(e.key==='ArrowRight') next();
    });
  })();
  
  
  // Handle scroll events for infinite scroll
function handleScroll() {
  if (isLoadingOlderMessages || !hasMoreMessages) return;
  
  // Load more messages when scrolled to top
  if (messagesEl.scrollTop < 100) {
    loadOlderMessages();
  }
}

// Function for back button of chat header 

// Improved back button function
// Improved back button function
function goBackToList() {
  console.log('Back button clicked');
  
  // Hide chat, show list
  chatEl.classList.remove('active');
  listEl.classList.add('active');
  
  // Clear current chat state
  currentKey = null;
  isInChatView = false;
  
  // Clean up listeners
  if (childListener) {
    db.ref('chats/' + currentKey).off('value', childListener);
    childListener = null;
  }
  
  // Remove scroll listener
  messagesEl.removeEventListener('scroll', handleScroll);
  
  // Clear presence listener
  if (statusListener && statusListener.ref) {
    try {
      statusListener.ref.off('value', statusListener.callback);
    } catch (e) {}
    statusListener = null;
  }
  
  // Hide typing indicator
  const typingEl = document.getElementById('typingIndicator');
  if (typingEl) typingEl.style.display = 'none';
  
  // Use history management
  history.back();
  
  console.log('Returned to list view');
}
// Improved history state management
window.addEventListener('popstate', function(event) {
  console.log('Popstate event triggered', event.state);
  
  // If going back to list view
  if (!event.state || event.state.screen === "list") {
    listEl.classList.add('active');
    chatEl.classList.remove('active');
    currentKey = null;
    
    // Clean up listeners
    if (childListener) {
      db.ref('chats/' + currentKey).off('value', childListener);
      childListener = null;
    }
    
    // Remove scroll listener
    messagesEl.removeEventListener('scroll', handleScroll);
    
    // Clear presence listener
    if (statusListener && statusListener.ref) {
      try {
        statusListener.ref.off('value', statusListener.callback);
      } catch (e) {}
      statusListener = null;
    }
    
    // Hide typing indicator
    const typingEl = document.getElementById('typingIndicator');
    if (typingEl) typingEl.style.display = 'none';
  }
});

// Update the openChat function to properly manage history
// Override the openChat function to properly manage state
const originalOpenChat = openChat;
openChat = function(key) {
  originalOpenChat(key);
  isInChatView = true;
  
  // Push state to history when opening a chat
  history.pushState({ screen: "chat", chatKey: key }, "Chat", "");
  console.log('Opened chat, history state pushed');
};
function renderOlderMessages(messages) {
  const sortedKeys = Object.keys(messages).map(Number).sort((a, b) => a - b).map(String);
  const fragment = document.createDocumentFragment();
  
  let currentDate = null;
  
  sortedKeys.forEach(msgKey => {
    const val = messages[msgKey];
    if (!val || (!val.text && !val.type && !val.url)) return;
    
    const msgDate = new Date(Number(msgKey));
    const dateLabel = formatDateSeparator(msgKey);
    
    // Date divider
    if (currentDate !== msgDate.toDateString()) {
      fragment.appendChild(createDateDivider(dateLabel));
      currentDate = msgDate.toDateString();
    }
    
    const div = buildMessageBubble(msgKey, val);
    fragment.appendChild(div);
  });
  
  // Get first child to insert before
  const firstChild = messagesEl.firstChild;
  messagesEl.insertBefore(fragment, firstChild);
}

// Clean up scroll listener when changing chats
const originalOnPopState = window.onpopstate;
window.onpopstate = function(event) {
  messagesEl.removeEventListener('scroll', handleScroll);
  if (originalOnPopState) originalOnPopState(event);
};
  </script>
  
  <script>
    // Add active state to send button when there's text
replyInput.addEventListener('input', function() {
  const sendBtn = document.getElementById('sendBtn');
  if (this.value.trim() !== '') {
    sendBtn.classList.add('active');
  } else {
    sendBtn.classList.remove('active');
  }
});

// Initialize send button state
document.addEventListener('DOMContentLoaded', function() {
  const sendBtn = document.getElementById('sendBtn');
  const replyInput = document.getElementById('replyInput');
  
  if (replyInput.value.trim() !== '') {
    sendBtn.classList.add('active');
  } else {
    sendBtn.classList.remove('active');
  }
});
  </script>

    <!-- Color Customization Modal -->
<div id="colorModal" class="color-modal" aria-hidden="true">
  <div class="color-modal-content">
    <h3 id="colorModalTitle" style="margin-bottom: 20px;">Customize Colors</h3>
    
    <div id="colorOptions">
      <!-- Color options will be dynamically inserted here -->
    </div>
    
    <div class="modal-actions">
      <button class="modal-btn secondary" id="cancelColorBtn">Cancel</button>
      <button class="modal-btn primary" id="saveColorBtn">Save Changes</button>
    </div>
  </div>
</div>
<script>
  // Settings menu functionality
const settingsToggle = document.getElementById('settingsToggle');
const settingsMenu = document.getElementById('settingsMenu');
const colorModal = document.getElementById('colorModal');
const colorModalTitle = document.getElementById('colorModalTitle');
const colorOptions = document.getElementById('colorOptions');
const cancelColorBtn = document.getElementById('cancelColorBtn');
const saveColorBtn = document.getElementById('saveColorBtn');

let currentMode = 'light'; // Track which mode we're customizing

// Default color schemes
// Default color schemes
// Default color schemes
const defaultColors = {
  light: {
    userBubble: '#DDF2ED',
    brotherBubble: '#006B61',
    chatHeader: '#DDF2ED',
    inputArea: '#DDF2ED',
    messagesBg: '#E9FEF9',
    chatListBg: '#DFF2EC',
    chatItemBg: '#EAFDF9',
    textColor: '#000000',
    previewText: '#666666',
    // NEW COLOR OPTIONS
    stalkColor: '#2563eb',
    bubuTextColor: '#000000',
    lastSeenColor: '#666666',
    onlineColor: '#25D366',
    typingColor: '#25D366',
    picBorderOnline: '#25D366',
    picBorderOffline: '#FFA500',
    svgColor: '#3A4F4A',
    brotherTextColor: '#FFFFFF',
    brotherTimeColor: '#E5E5E5',
    brotherPreviewColor: '#E5E5E5',
    userTextColor: '#000000',
    userTimeColor: '#666666',
    userPreviewColor: '#666666'
  },
  dark: {
    userBubble: '#13221F',
    brotherBubble: '#005047',
    chatHeader: '#13221F',
    inputArea: '#13221F',
    messagesBg: '#031813',
    chatListBg: '#12221F',
    chatItemBg: '#061613',
    textColor: '#B7CAC6',
    previewText: '#B7CAC6',
    // NEW COLOR OPTIONS
    stalkColor: '#B7CAC6',
    bubuTextColor: '#B7CAC6',
    lastSeenColor: '#B7CAC6',
    onlineColor: '#25D366',
    typingColor: '#25D366',
    picBorderOnline: '#25D366',
    picBorderOffline: '#FFA500',
    svgColor: '#B7CAC6',
    brotherTextColor: '#FFFFFF',
    brotherTimeColor: '#E5E5E5',
    brotherPreviewColor: '#E5E5E5',
    userTextColor: '#B7CAC6',
    userTimeColor: '#B7CAC6',
    userPreviewColor: '#B7CAC6'
  }
};
let customColors = JSON.parse(localStorage.getItem('customColors')) || {
  light: {...defaultColors.light},
  dark: {...defaultColors.dark}
};

// Toggle settings menu
settingsToggle.addEventListener('click', (e) => {
  e.stopPropagation();
  settingsMenu.style.display = settingsMenu.style.display === 'block' ? 'none' : 'block';
});

// Close settings menu when clicking outside
document.addEventListener('click', () => {
  settingsMenu.style.display = 'none';
});

// Settings menu actions
document.querySelectorAll('.menu-item').forEach(item => {
  item.addEventListener('click', (e) => {
    const action = e.target.dataset.action;
    
    switch(action) {
      case 'toggle-dark':
        enableDarkMode();
        break;
      case 'toggle-light':
        disableDarkMode();
        break;
      case 'customize-dark':
        openColorCustomization('dark');
        break;
      case 'customize-light':
        openColorCustomization('light');
        break;
      case 'reset-colors':
        resetColorsToDefault();
        break;
    }
    
    settingsMenu.style.display = 'none';
  });
});

// Dark mode functions
function enableDarkMode() {
  document.body.classList.add('dark');
  localStorage.setItem('darkMode', 'enabled');
  applyCustomColors('dark');
}

function disableDarkMode() {
  document.body.classList.remove('dark');
  localStorage.setItem('darkMode', 'disabled');
  applyCustomColors('light');
}

// Open color customization modal
function openColorCustomization(mode) {
  currentMode = mode;
  colorModalTitle.textContent = `Customize ${mode === 'dark' ? 'Dark' : 'Light'} Mode Colors`;
  
  // Clear previous options
  colorOptions.innerHTML = '';
  
  // Create color options based on mode
  const colors = customColors[mode];
  const colorLabels = {
  userBubble: 'Your Messages Color',
  brotherBubble: 'Brother Messages Color',
  chatHeader: 'Header & Chat Background',
  inputArea: 'Input Area Color',
  messagesBg: 'Messages Background',
  chatListBg: 'Chat List Background',
  chatItemBg: 'Chat Item Background',
  textColor: 'Main Text Color',
  previewText: 'Preview Text Color',
  // NEW LABELS
  stalkColor: 'S talk Text Color',
  bubuTextColor: 'Bubu Text Color',
  lastSeenColor: 'Last Seen Text Color',
  onlineColor: 'Online Text Color',
  typingColor: 'Typing Text Color',
  picBorderOnline: 'Pic Border (Online)',
  picBorderOffline: 'Pic Border (Offline)',
  svgColor: 'SVG Icons Color',
  brotherTextColor: 'Brother Messages Text',
  brotherTimeColor: 'Brother Messages Time',
  brotherPreviewColor: 'Brother Preview Text',
  userTextColor: 'Your Messages Text',
  userTimeColor: 'Your Messages Time',
  userPreviewColor: 'Your Preview Text'
};
  Object.keys(colors).forEach(key => {
    const optionDiv = document.createElement('div');
    optionDiv.className = 'color-option';
    
    const label = document.createElement('label');
    label.textContent = colorLabels[key] || key;
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'color-input';
    input.value = colors[key];
    input.dataset.colorKey = key;
    input.placeholder = 'Enter color name or hex';
    
    optionDiv.appendChild(label);
    optionDiv.appendChild(input);
    colorOptions.appendChild(optionDiv);
  });
  
  colorModal.classList.add('open');
}

// Close color modal
cancelColorBtn.addEventListener('click', () => {
  colorModal.classList.remove('open');
});

// Save color changes
saveColorBtn.addEventListener('click', () => {
  // Collect all color values
  const inputs = colorOptions.querySelectorAll('.color-input');
  inputs.forEach(input => {
    const key = input.dataset.colorKey;
    const value = input.value.trim();
    
    // Only update if value is not empty
    if (value) {
      customColors[currentMode][key] = value;
    }
  });
  
  // Save to localStorage
  localStorage.setItem('customColors', JSON.stringify(customColors));
  
  // Apply the changes
  applyCustomColors(currentMode);
  
  // Close modal
  colorModal.classList.remove('open');
});
// Helper function to update pseudo-element styles
// Helper function to update pseudo-element styles
// Helper function to update pseudo-element styles
// Helper function to update pseudo-element styles - FIXED VERSION
function updatePseudoElementStyles(mode, colors) {
  // Remove existing style element if it exists
  const existingStyle = document.getElementById('custom-colors-style');
  if (existingStyle) {
    existingStyle.remove();
  }
  
  // Create new style element
  const style = document.createElement('style');
  style.id = 'custom-colors-style';
  
  // Add comprehensive styles for all elements
  style.textContent = `
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #inboxHeader {
      color: ${colors.stalkColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #chatTitle {
      color: ${colors.bubuTextColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #typingIndicator {
      color: ${colors.lastSeenColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .from-user {
      background: ${colors.userBubble} !important;
      color: ${colors.userTextColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .from-user::after {
      background: ${colors.userBubble} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .from-brother {
      background: ${colors.brotherBubble} !important;
      color: ${colors.brotherTextColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .from-brother::after {
      background: ${colors.brotherBubble} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #chatHeader {
      background: ${colors.chatHeader} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #chat {
      background: ${colors.chatHeader} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #inputControls {
      background: ${colors.inputArea} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #sendBtn {
      background: ${colors.inputArea} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #messages {
      background: ${colors.messagesBg} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #list {
      background: ${colors.chatListBg} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .chat-item {
      background: ${colors.chatItemBg} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} body {
      color: ${colors.textColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .chat-preview {
      color: ${colors.previewText} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} svg {
      stroke: ${colors.svgColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .from-user .msg-time {
      color: ${colors.userTimeColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .from-brother .msg-time {
      color: ${colors.brotherTimeColor} !important;
    }
    
    /* Light mode specific overrides */
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #inboxHeader {
      color: ${colors.stalkColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #chatTitle {
      color: ${colors.bubuTextColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #typingIndicator {
      color: ${colors.lastSeenColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .from-user {
      background: ${colors.userBubble} !important;
      color: ${colors.userTextColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .from-user::after {
      background: ${colors.userBubble} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .from-brother {
      background: ${colors.brotherBubble} !important;
      color: ${colors.brotherTextColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .from-brother::after {
      background: ${colors.brotherBubble} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #chatHeader {
      background: ${colors.chatHeader} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #chat {
      background: ${colors.chatHeader} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #inputControls {
      background: ${colors.inputArea} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #sendBtn {
      background: ${colors.inputArea} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #messages {
      background: ${colors.messagesBg} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #list {
      background: ${colors.chatListBg} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .chat-item {
      background: ${colors.chatItemBg} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} body {
      color: ${colors.textColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .chat-preview {
      color: ${colors.previewText} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} svg {
      stroke: ${colors.svgColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .from-user .msg-time {
      color: ${colors.userTimeColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .from-brother .msg-time {
      color: ${colors.brotherTimeColor} !important;
    }
  `;
  
  document.head.appendChild(style);
}
// Function to update profile picture border based on status
// Function to update profile picture border based on status
function updateProfilePictureBorder(isOnline) {
  const userLogo = document.getElementById('userLogo');
  if (userLogo) {
    const currentMode = document.body.classList.contains('dark') ? 'dark' : 'light';
    const colors = customColors[currentMode];
    userLogo.style.border = `3px solid ${isOnline ? colors.picBorderOnline : colors.picBorderOffline}`;
  }
}
// Apply custom colors to the UI
// Apply custom colors to the UI - FIXED VERSION
// Apply custom colors to the UI - SIMPLIFIED VERSION
function applyCustomColors(mode) {
  const colors = customColors[mode];
  
  // Set dark mode class
  if (mode === 'dark') {
    document.body.classList.add('dark');
  } else {
    document.body.classList.remove('dark');
  }
  
  // Update all styles via CSS
  updatePseudoElementStyles(mode, colors);
  
  // Update theme color meta tag
  updateThemeColor();
  
  // Force a re-render of any existing messages
  if (currentKey && Object.keys(messageStore).length > 0) {
    const tempStore = { ...messageStore };
    messageStore = {};
    messagesEl.innerHTML = '';
    lastRenderedDate = null;
    processAndRenderMessages(tempStore);
  }
}

// Reset all colors to default
function resetColorsToDefault() {
  if (confirm('Are you sure you want to reset all colors to default?')) {
    customColors = {
      light: {...defaultColors.light},
      dark: {...defaultColors.dark}
    };
    
    localStorage.setItem('customColors', JSON.stringify(customColors));
    
    // Apply default colors based on current mode
    const currentMode = document.body.classList.contains('dark') ? 'dark' : 'light';
    applyCustomColors(currentMode);
    
    alert('Colors have been reset to default.');
  }
}

// Update theme color meta tag
function updateThemeColor() {
  const themeMeta = document.getElementById('theme-color-meta');
  const currentMode = document.body.classList.contains('dark') ? 'dark' : 'light';
  
  if (currentMode === 'dark') {
    themeMeta.setAttribute('content', customColors.dark.chatHeader);
  } else {
    themeMeta.setAttribute('content', customColors.light.chatHeader);
  }
}

// Initialize colors on page load
document.addEventListener('DOMContentLoaded', () => {
  // Check if dark mode is enabled
  if (localStorage.getItem('darkMode') === 'enabled') {
    document.body.classList.add('dark');
  }
  
  // Apply custom colors
  const currentMode = document.body.classList.contains('dark') ? 'dark' : 'light';
  applyCustomColors(currentMode);
});

// Initialize profile picture border on page load
document.addEventListener('DOMContentLoaded', function() {
  // Set initial border color (offline by default)
  updateProfilePictureBorder(false);
});
</script>
  <!-- Add this to your existing HTML, preferably near the other modals -->
<div id="advancedSettingsModal" class="color-modal" aria-hidden="true">
  <div class="color-modal-content">
    <h3 id="advancedSettingsTitle" style="margin-bottom: 20px;">Advanced Settings</h3>
    
    <div class="settings-tabs">
      <button class="tab-btn active" data-tab="sizes">Sizes</button>
      <button class="tab-btn" data-tab="animations">Animations</button>
      <button class="tab-btn" data-tab="layout">Layout</button>
    </div>
    
    <div id="sizesTab" class="tab-content active">
      <div class="settings-group">
        <h4>Header Text Sizes</h4>
        <div class="setting-item">
          <label>Stalk Text Size</label>
          <input type="number" id="stalkSize" min="10" max="40" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Bubu Text Size</label>
          <input type="number" id="bubuSize" min="10" max="30" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Status Text Size</label>
          <input type="number" id="statusSize" min="8" max="20" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
      </div>
      
      <div class="settings-group">
        <h4>Message Text Sizes</h4>
        <div class="setting-item">
          <label>User Message Text</label>
          <input type="number" id="userTextSize" min="12" max="24" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>User Message Time</label>
          <input type="number" id="userTimeSize" min="8" max="16" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Brother Message Text</label>
          <input type="number" id="brotherTextSize" min="12" max="24" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Brother Message Time</label>
          <input type="number" id="brotherTimeSize" min="8" max="16" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
      </div>
      
      <div class="settings-group">
        <h4>Chat List Sizes</h4>
        <div class="setting-item">
          <label>Chat Name Size</label>
          <input type="number" id="chatNameSize" min="12" max="24" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Chat Preview Size</label>
          <input type="number" id="chatPreviewSize" min="10" max="20" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
      </div>
    </div>
    
<div id="animationsTab" class="tab-content">
  <div class="settings-group">
    <h4>Message Animations</h4>
    <div class="setting-item">
      <label>Animation Duration</label>
      <input type="number" id="animationDuration" min="0.1" max="2" step="0.1" class="size-input">
      <span class="unit">s</span>
    </div>
    <div class="setting-item">
      <label>Animation Type</label>
      <select id="animationType">
        <option value="bubblePop">Bubble Pop</option>
        <option value="fadeIn">Fade In</option>
        <option value="slideUp">Slide Up</option>
        <option value="slideInLeft">Slide In Left</option>
        <option value="slideInRight">Slide In Right</option>
        <option value="bounce">Bounce</option>
        <option value="flip">Flip</option>
        <option value="zoom">Zoom</option>
        <option value="typewriter">Typewriter</option>
        <option value="wave">Wave Effect</option>
        <option value="pulse">Pulse</option>
        <option value="shake">Shake</option>
        <option value="swing">Swing</option>
        <option value="tada">Tada</option>
        <option value="wobble">Wobble</option>
        <option value="jello">Jello</option>
        <option value="heartbeat">Heartbeat</option>
        <option value="rubberBand">Rubber Band</option>
        <option value="lightSpeed">Light Speed</option>
        <option value="rollIn">Roll In</option>
        <option value="rotateIn">Rotate In</option>
        <option value="none">None</option>
      </select>
    </div>
    <div class="setting-item">
      <label>Highlight Duration</label>
      <input type="number" id="highlightDuration" min="0.5" max="5" step="0.5" class="size-input">
      <span class="unit">s</span>
    </div>
    <div class="setting-item">
      <label>Stagger Messages</label>
      <input type="checkbox" id="staggerMessages">
    </div>
    <div class="setting-item">
      <label>Stagger Delay</label>
      <input type="number" id="staggerDelay" min="0.05" max="0.5" step="0.05" class="size-input">
      <span class="unit">s</span>
    </div>
  </div>
  
  <div class="settings-group">
    <h4>Special Effects</h4>
    <div class="setting-item">
      <label>Enable Particle Effects</label>
      <input type="checkbox" id="particleEffects">
    </div>
    <div class="setting-item">
      <label>Enable Ripple Effect</label>
      <input type="checkbox" id="rippleEffect">
    </div>
    <div class="setting-item">
      <label>Enable Glow Effect</label>
      <input type="checkbox" id="glowEffect">
    </div>
    <div class="setting-item">
      <label>Enable Floating Animation</label>
      <input type="checkbox" id="floatingAnimation">
    </div>
  </div>
  
  <div class="settings-group">
    <h4>Chat List Animations</h4>
    <div class="setting-item">
      <label>Chat Item Animation</label>
      <select id="chatItemAnimation">
        <option value="none">None</option>
        <option value="fadeIn">Fade In</option>
        <option value="slideIn">Slide In</option>
        <option value="bounceIn">Bounce In</option>
      </select>
    </div>
    <div class="setting-item">
      <label>Unread Pulse Effect</label>
      <input type="checkbox" id="unreadPulse">
    </div>
  </div>
</div>
    <div id="layoutTab" class="tab-content">
      <div class="settings-group">
        <h4>Border Radius</h4>
        <div class="setting-item">
          <label>Messages Container</label>
          <input type="number" id="messagesRadius" min="0" max="50" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Message Bubbles</label>
          <input type="number" id="bubbleRadius" min="0" max="30" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Input Area</label>
          <input type="number" id="inputRadius" min="0" max="30" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Chat Items</label>
          <input type="number" id="chatItemRadius" min="0" max="30" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
      </div>
      
      <div class="settings-group">
        <h4>Message Width</h4>
        <div class="setting-item">
          <label>Max Message Width</label>
          <input type="number" id="messageMaxWidth" min="50" max="90" step="1" class="size-input">
          <span class="unit">%</span>
        </div>
      </div>
      
      <div class="settings-group">
        <h4>Spacing</h4>
        <div class="setting-item">
          <label>Message Spacing</label>
          <input type="number" id="messageSpacing" min="2" max="20" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Input Area Height</label>
          <input type="number" id="inputHeight" min="40" max="120" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
      </div>
    </div>
    
    <div class="modal-actions">
      <button class="modal-btn secondary" id="cancelAdvancedBtn">Cancel</button>
      <button class="modal-btn secondary" id="resetAdvancedBtn">Reset to Default</button>
      <button class="modal-btn primary" id="saveAdvancedBtn">Save Changes</button>
    </div>
  </div>
</div>
<style>
  /* Settings Tabs */
.settings-tabs {
  display: flex;
  border-bottom: 1px solid #ccc;
  margin-bottom: 20px;
}

.tab-btn {

  flex: 1;
  padding: 10px;
  background: none;
  border: none;
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.2s;
}

.tab-btn.active {
  border-bottom: 2px solid #2563eb;
  font-weight: bold;
}

.tab-content {
  display: none;
  max-height: 50vh;
  overflow-y: auto;
}

.tab-content.active {
  display: block;
}

/* Settings Groups */
.settings-group {
  margin-bottom: 25px;
  padding-bottom: 15px;
  border-bottom: 1px solid #eee;
}

.settings-group h4 {
  margin-bottom: 15px;
  color: #2563eb;
  font-size: 16px;
}

.setting-item {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
  gap: 10px;
}

.setting-item label {
  flex: 1;
  min-width: 160px;
  font-size: 14px;
}

.size-input, .setting-item select {
  background: #DDF2ED;
  width: 80px;
  padding: 6px 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
}

.unit {
  width: 30px;
  font-size: 14px;
  color: #666;
}

/* Dark mode adjustments */
body.dark .settings-group {
  border-bottom-color: #2A3A36;
}

body.dark .settings-group h4 {
  color: #5ac8fa;
}
body.dark .tab-btn{
  color:#B7CAC6;
}

body.dark .size-input, 
body.dark .setting-item select {
  background: #061613;
  color: #B7CAC6;
  border-color: #2A3A36;
}

body.dark .unit {
  color: #B7CAC6;
}
</style>
<script>
// Advanced settings functionality
const advancedSettingsModal = document.getElementById('advancedSettingsModal');
const cancelAdvancedBtn = document.getElementById('cancelAdvancedBtn');
const saveAdvancedBtn = document.getElementById('saveAdvancedBtn');
const resetAdvancedBtn = document.getElementById('resetAdvancedBtn');

// Default settings values
const defaultSettings = {
  // Sizes
  stalkSize: 28,
  bubuSize: 18,
  statusSize: 12,
  userTextSize: 18,
  userTimeSize: 10,
  brotherTextSize: 18,
  brotherTimeSize: 10,
  chatNameSize: 16,
  chatPreviewSize: 14,
  
  // Animations
  animationDuration: 0.3,
  animationType: 'bubblePop',
  highlightDuration: 2.2,
  
  // Layout
  messagesRadius: 33,
  bubbleRadius: 16,
  inputRadius: 24,
  chatItemRadius: 16,
  messageMaxWidth: 75,
  messageSpacing: 6,
  inputHeight: 52
};

// Load settings from localStorage or use defaults
let currentSettings = JSON.parse(localStorage.getItem('advancedSettings')) || {...defaultSettings};

// Tab functionality
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    // Remove active class from all tabs and contents
    document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    // Add active class to clicked tab and corresponding content
    btn.classList.add('active');
    const tabId = btn.dataset.tab + 'Tab';
    document.getElementById(tabId).classList.add('active');
  });
});

// Open advanced settings
function openAdvancedSettings() {
  // Populate form with current settings
  populateSettingsForm();
  advancedSettingsModal.classList.add('open');
}

// Populate form with current settings
function populateSettingsForm() {
  // Sizes
  document.getElementById('stalkSize').value = currentSettings.stalkSize;
  document.getElementById('bubuSize').value = currentSettings.bubuSize;
  document.getElementById('statusSize').value = currentSettings.statusSize;
  document.getElementById('userTextSize').value = currentSettings.userTextSize;
  document.getElementById('userTimeSize').value = currentSettings.userTimeSize;
  document.getElementById('brotherTextSize').value = currentSettings.brotherTextSize;
  document.getElementById('brotherTimeSize').value = currentSettings.brotherTimeSize;
  document.getElementById('chatNameSize').value = currentSettings.chatNameSize;
  document.getElementById('chatPreviewSize').value = currentSettings.chatPreviewSize;
  
  // Animations
  document.getElementById('animationDuration').value = currentSettings.animationDuration;
  document.getElementById('animationType').value = currentSettings.animationType;
  document.getElementById('highlightDuration').value = currentSettings.highlightDuration;
  
  // Layout
  document.getElementById('messagesRadius').value = currentSettings.messagesRadius;
  document.getElementById('bubbleRadius').value = currentSettings.bubbleRadius;
  document.getElementById('inputRadius').value = currentSettings.inputRadius;
  document.getElementById('chatItemRadius').value = currentSettings.chatItemRadius;
  document.getElementById('messageMaxWidth').value = currentSettings.messageMaxWidth;
  document.getElementById('messageSpacing').value = currentSettings.messageSpacing;
  document.getElementById('inputHeight').value = currentSettings.inputHeight;
}

// Save advanced settings
function saveAdvancedSettings() {
  // Collect all settings from form
  const newSettings = {
    // Sizes
    stalkSize: parseInt(document.getElementById('stalkSize').value) || defaultSettings.stalkSize,
    bubuSize: parseInt(document.getElementById('bubuSize').value) || defaultSettings.bubuSize,
    statusSize: parseInt(document.getElementById('statusSize').value) || defaultSettings.statusSize,
    userTextSize: parseInt(document.getElementById('userTextSize').value) || defaultSettings.userTextSize,
    userTimeSize: parseInt(document.getElementById('userTimeSize').value) || defaultSettings.userTimeSize,
    brotherTextSize: parseInt(document.getElementById('brotherTextSize').value) || defaultSettings.brotherTextSize,
    brotherTimeSize: parseInt(document.getElementById('brotherTimeSize').value) || defaultSettings.brotherTimeSize,
    chatNameSize: parseInt(document.getElementById('chatNameSize').value) || defaultSettings.chatNameSize,
    chatPreviewSize: parseInt(document.getElementById('chatPreviewSize').value) || defaultSettings.chatPreviewSize,
    
    // Animations
    animationDuration: parseFloat(document.getElementById('animationDuration').value) || defaultSettings.animationDuration,
    animationType: document.getElementById('animationType').value || defaultSettings.animationType,
    highlightDuration: parseFloat(document.getElementById('highlightDuration').value) || defaultSettings.highlightDuration,
    
    // Layout
    messagesRadius: parseInt(document.getElementById('messagesRadius').value) || defaultSettings.messagesRadius,
    bubbleRadius: parseInt(document.getElementById('bubbleRadius').value) || defaultSettings.bubbleRadius,
    inputRadius: parseInt(document.getElementById('inputRadius').value) || defaultSettings.inputRadius,
    chatItemRadius: parseInt(document.getElementById('chatItemRadius').value) || defaultSettings.chatItemRadius,
    messageMaxWidth: parseInt(document.getElementById('messageMaxWidth').value) || defaultSettings.messageMaxWidth,
    messageSpacing: parseInt(document.getElementById('messageSpacing').value) || defaultSettings.messageSpacing,
    inputHeight: parseInt(document.getElementById('inputHeight').value) || defaultSettings.inputHeight
  };
  
  // Update current settings
  currentSettings = {...newSettings};
  
  // Save to localStorage
  localStorage.setItem('advancedSettings', JSON.stringify(currentSettings));
  
  // Apply the settings
  applyAdvancedSettings();
  
  // Close modal
  advancedSettingsModal.classList.remove('open');
}

// Reset to default settings
function resetAdvancedSettings() {
  if (confirm('Are you sure you want to reset all advanced settings to default?')) {
    currentSettings = {...defaultSettings};
    localStorage.setItem('advancedSettings', JSON.stringify(currentSettings));
    applyAdvancedSettings();
    populateSettingsForm();
    alert('Advanced settings have been reset to default.');
  }
}

// Apply advanced settings to the UI
function applyAdvancedSettings() {
  // Remove existing style element if it exists
  const existingStyle = document.getElementById('advanced-settings-style');
  if (existingStyle) {
    existingStyle.remove();
  }
  
  // Create new style element
  const style = document.createElement('style');
  style.id = 'advanced-settings-style';
  
  // Build CSS based on current settings
  let css = `
    /* Header Text Sizes */
    #inboxHeader {
      font-size: ${currentSettings.stalkSize}px !important;
    }
    #chatTitle {
      font-size: ${currentSettings.bubuSize}px !important;
    }
    #typingIndicator {
      font-size: ${currentSettings.statusSize}px !important;
    }
    
    /* Message Text Sizes */
    .from-user > div:not(.reply-box):not(.msg-time) {
      font-size: ${currentSettings.userTextSize}px !important;
    }
    .from-user .msg-time {
      font-size: ${currentSettings.userTimeSize}px !important;
    }
    .from-brother > div:not(.reply-box):not(.msg-time) {
      font-size: ${currentSettings.brotherTextSize}px !important;
    }
    .from-brother .msg-time {
      font-size: ${currentSettings.brotherTimeSize}px !important;
    }
    
    /* Chat List Sizes */
    .chat-name {
      font-size: ${currentSettings.chatNameSize}px !important;
    }
    .chat-preview {
      font-size: ${currentSettings.chatPreviewSize}px !important;
    }
    
    /* Layout Settings */
    #messages {
      border-top-left-radius: ${currentSettings.messagesRadius}px !important;
      border-top-right-radius: ${currentSettings.messagesRadius}px !important;
    }
    .bubble {
      border-radius: ${currentSettings.bubbleRadius}px !important;
      max-width: ${currentSettings.messageMaxWidth}% !important;
      margin: ${currentSettings.messageSpacing}px 0 !important;
    }
    #inputControls {
      border-radius: ${currentSettings.inputRadius}px !important;
      min-height: ${currentSettings.inputHeight}px !important;
    }
    .chat-item {
      border-radius: ${currentSettings.chatItemRadius}px !important;
    }
    
    /* Animation Settings */
    .bubble {
      animation-duration: ${currentSettings.animationDuration}s !important;
    }
    .message-highlight {
      animation-duration: ${currentSettings.highlightDuration}s !important;
    }
  `;
  
  // Add animation-specific styles
  if (currentSettings.animationType === 'fadeIn') {
    css += `
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      .bubble {
        animation-name: fadeIn !important;
      }
    `;
  } else if (currentSettings.animationType === 'slideUp') {
    css += `
      @keyframes slideUp {
        from { 
          opacity: 0;
          transform: translateY(20px);
        }
        to { 
          opacity: 1;
          transform: translateY(0);
        }
      }
      .bubble {
        animation-name: slideUp !important;
      }
    `;
  } else if (currentSettings.animationType === 'none') {
    css += `
      .bubble {
        animation: none !important;
      }
    `;
  }
  
  style.textContent = css;
  document.head.appendChild(style);
  
  // Update bubble tail positions based on new radius
  updateBubbleTails();
}

// Update bubble tail positions based on current border radius
function updateBubbleTails() {
  // Remove existing tail styles
  const existingTailStyle = document.getElementById('bubble-tail-style');
  if (existingTailStyle) {
    existingTailStyle.remove();
  }
  
  const tailStyle = document.createElement('style');
  tailStyle.id = 'bubble-tail-style';
  
  const tailSize = 12;
  const borderRadius = currentSettings.bubbleRadius;
  
  tailStyle.textContent = `
    .from-user::after {
      border-bottom-left-radius: ${Math.min(borderRadius / 4, 4)}px !important;
    }
    .from-brother::after {
      border-bottom-right-radius: ${Math.min(borderRadius / 4, 4)}px !important;
    }
  `;
  
  document.head.appendChild(tailStyle);
}

// Event listeners
cancelAdvancedBtn.addEventListener('click', () => {
  advancedSettingsModal.classList.remove('open');
});

saveAdvancedBtn.addEventListener('click', saveAdvancedSettings);

resetAdvancedBtn.addEventListener('click', resetAdvancedSettings);

// Initialize settings on page load
document.addEventListener('DOMContentLoaded', () => {
  applyAdvancedSettings();
});

// Add this menu item to your existing settings menu HTML:
// <div class="menu-item" data-action="advanced-settings">⚙️ Advanced Settings</div>

// And add this event listener to handle the new menu item:
document.addEventListener('click', (e) => {
  if (e.target.dataset.action === 'advanced-settings') {
    openAdvancedSettings();
  }
});
</script>
<script>
// Enhanced Animation System - FIXED VERSION
function applyMessageAnimation(bubble, animationType, duration, isUser) {
  const animationClasses = [
    'animate-fadeIn', 'animate-slideUp', 'animate-slideInLeft', 'animate-slideInRight',
    'animate-bounce', 'animate-flip', 'animate-zoom', 'animate-wave', 'animate-pulse',
    'animate-shake', 'animate-swing', 'animate-tada', 'animate-wobble', 'animate-jello',
    'animate-heartbeat', 'animate-rubberBand', 'animate-lightSpeed', 'animate-rollIn', 'animate-rotateIn'
  ];
  
  bubble.classList.remove(...animationClasses);
  
  if (animationType !== 'none') {
    bubble.classList.add(`animate-${animationType}`);
    bubble.style.animationDuration = `${duration}s`;
    
    // Special handling for directional animations
    if ((animationType === 'slideInLeft' && !isUser) || 
        (animationType === 'slideInRight' && isUser)) {
      bubble.classList.remove(`animate-${animationType}`);
      bubble.classList.add(`animate-${animationType === 'slideInLeft' ? 'slideInRight' : 'slideInLeft'}`);
    }
    
    applySpecialEffects(bubble);
  }
}

function applySpecialEffects(bubble) {
  const settings = getCurrentAnimationSettings();
  
  bubble.classList.remove('ripple-effect', 'glow-effect', 'float-effect');
  
  if (settings.particleEffects) {
    createParticleEffect(bubble);
  }
  
  if (settings.rippleEffect) {
    bubble.classList.add('ripple-effect');
  }
  
  if (settings.glowEffect) {
    bubble.classList.add('glow-effect');
  }
  
  if (settings.floatingAnimation) {
    bubble.classList.add('float-effect');
  }
}

function createParticleEffect(element) {
  const rect = element.getBoundingClientRect();
  const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
  
  for (let i = 0; i < 8; i++) {
    setTimeout(() => {
      const particle = document.createElement('div');
      particle.style.cssText = `
        position: fixed;
        width: 6px;
        height: 6px;
        background: ${colors[Math.floor(Math.random() * colors.length)]};
        border-radius: 50%;
        pointer-events: none;
        z-index: 1000;
        left: ${rect.left + rect.width / 2}px;
        top: ${rect.top + rect.height / 2}px;
      `;
      
      document.body.appendChild(particle);
      
      const angle = Math.random() * Math.PI * 2;
      const distance = 20 + Math.random() * 30;
      const duration = 0.5 + Math.random() * 0.5;
      
      particle.animate([
        { transform: 'translate(0, 0) scale(1)', opacity: 1 },
        { transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`, opacity: 0 }
      ], {
        duration: duration * 1000,
        easing: 'cubic-bezier(0.215, 0.610, 0.355, 1.000)'
      }).onfinish = () => particle.remove();
    }, i * 50);
  }
}

function applyChatItemAnimation(chatItem, animationType, duration) {
  if (animationType !== 'none') {
    chatItem.classList.add(`animate-${animationType}`);
    chatItem.style.animationDuration = `${duration}s`;
  }
}

function applyUnreadPulseEffect(badge) {
  const settings = getCurrentAnimationSettings();
  if (settings.unreadPulse) {
    badge.classList.add('pulse-effect');
  } else {
    badge.classList.remove('pulse-effect');
  }
}

function getCurrentAnimationSettings() {
  return {
    animationType: currentSettings.animationType,
    animationDuration: currentSettings.animationDuration,
    staggerMessages: currentSettings.staggerMessages,
    staggerDelay: currentSettings.staggerDelay,
    particleEffects: currentSettings.particleEffects,
    rippleEffect: currentSettings.rippleEffect,
    glowEffect: currentSettings.glowEffect,
    floatingAnimation: currentSettings.floatingAnimation,
    chatItemAnimation: currentSettings.chatItemAnimation,
    unreadPulse: currentSettings.unreadPulse
  };
}

// Override the buildMessageBubble function to include animations
const originalBuildMessageBubble = window.buildMessageBubble;
window.buildMessageBubble = function(msgKey, val) {
  const div = originalBuildMessageBubble(msgKey, val);
  
  const settings = getCurrentAnimationSettings();
  const isUser = val.from === 'user';
  
  // Apply animation
  if (settings.animationType !== 'none') {
    applyMessageAnimation(div, settings.animationType, settings.animationDuration, isUser);
  }
  
  // Apply stagger effect if enabled
  if (settings.staggerMessages) {
    const index = Object.keys(messageStore).indexOf(msgKey);
    div.style.animationDelay = `${index * settings.staggerDelay}s`;
  }
  
  // Handle typewriter animation
  if (settings.animationType === 'typewriter' && val.text) {
    handleTypewriterAnimation(div, val, settings);
  }
  
  return div;
};

// Override renderChatsOptimized to include chat item animations
const originalRenderChatsOptimized = renderChatsOptimized;
renderChatsOptimized = function(chatListData) {
  originalRenderChatsOptimized(chatListData);
  
  const settings = getCurrentAnimationSettings();
  const chatItems = document.querySelectorAll('.chat-item');
  
  chatItems.forEach((item, index) => {
    if (settings.chatItemAnimation !== 'none') {
      applyChatItemAnimation(item, settings.chatItemAnimation, 0.5);
      item.style.animationDelay = `${index * 0.1}s`;
    }
    
    // Apply unread pulse effect
    const badge = item.querySelector('.unread-badge');
    if (badge) {
      applyUnreadPulseEffect(badge);
    }
  });
};

// Typewriter animation handler
function applyTypewriterAnimation(element, text, duration) {
  const originalText = element.textContent;
  element.textContent = '';
  element.style.overflow = 'hidden';
  element.style.whiteSpace = 'nowrap';
  element.style.borderRight = '2px solid';
  
  const length = text.length;
  const interval = duration / length;
  let i = 0;
  
  const typeInterval = setInterval(() => {
    if (i < length) {
      element.textContent += text.charAt(i);
      i++;
    } else {
      clearInterval(typeInterval);
      setTimeout(() => {
        element.style.borderRight = 'none';
        element.style.whiteSpace = 'normal';
        element.style.overflow = 'visible';
      }, 500);
    }
  }, interval);
}

function handleTypewriterAnimation(div, val, settings) {
  const textElement = div.querySelector('div:not(.reply-box):not(.msg-time)');
  if (textElement) {
    const text = textElement.textContent;
    textElement.textContent = '';
    setTimeout(() => {
      applyTypewriterAnimation(textElement, text, settings.animationDuration);
    }, 100);
  }
}

// Enhanced applyAdvancedSettings function
function applyAdvancedSettings() {
  const existingStyle = document.getElementById('advanced-settings-style');
  if (existingStyle) {
    existingStyle.remove();
  }
  
  const style = document.createElement('style');
  style.id = 'advanced-settings-style';
  
  let css = `
    /* Header Text Sizes */
    #inboxHeader {
      font-size: ${currentSettings.stalkSize}px !important;
    }
    #chatTitle {
      font-size: ${currentSettings.bubuSize}px !important;
    }
    #typingIndicator {
      font-size: ${currentSettings.statusSize}px !important;
    }
    
    /* Message Text Sizes */
    .from-user > div:not(.reply-box):not(.msg-time) {
      font-size: ${currentSettings.userTextSize}px !important;
    }
    .from-user .msg-time {
      font-size: ${currentSettings.userTimeSize}px !important;
    }
    .from-brother > div:not(.reply-box):not(.msg-time) {
      font-size: ${currentSettings.brotherTextSize}px !important;
    }
    .from-brother .msg-time {
      font-size: ${currentSettings.brotherTimeSize}px !important;
    }
    
    /* Chat List Sizes */
    .chat-name {
      font-size: ${currentSettings.chatNameSize}px !important;
    }
    .chat-preview {
      font-size: ${currentSettings.chatPreviewSize}px !important;
    }
    
    /* Layout Settings */
    #messages {
      border-top-left-radius: ${currentSettings.messagesRadius}px !important;
      border-top-right-radius: ${currentSettings.messagesRadius}px !important;
    }
    .bubble {
      border-radius: ${currentSettings.bubbleRadius}px !important;
      max-width: ${currentSettings.messageMaxWidth}% !important;
      margin: ${currentSettings.messageSpacing}px 0 !important;
    }
    #inputControls {
      border-radius: ${currentSettings.inputRadius}px !important;
      min-height: ${currentSettings.inputHeight}px !important;
    }
    .chat-item {
      border-radius: ${currentSettings.chatItemRadius}px !important;
    }
    
    /* Animation Settings */
    .bubble {
      animation-duration: ${currentSettings.animationDuration}s !important;
    }
    
    .message-highlight {
      animation-duration: ${currentSettings.highlightDuration}s !important;
    }
    
    /* Animation-specific styles */
    ${currentSettings.animationType === 'fadeIn' ? `
      .bubble { animation-name: fadeIn !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'slideUp' ? `
      .bubble { animation-name: slideUp !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'slideInLeft' ? `
      .bubble { animation-name: slideInLeft !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'slideInRight' ? `
      .bubble { animation-name: slideInRight !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'bounce' ? `
      .bubble { animation-name: bounce !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'flip' ? `
      .bubble { animation-name: flip !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'zoom' ? `
      .bubble { animation-name: zoom !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'wave' ? `
      .bubble { animation-name: wave !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'pulse' ? `
      .bubble { animation-name: pulse !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'shake' ? `
      .bubble { animation-name: shake !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'swing' ? `
      .bubble { animation-name: swing !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'tada' ? `
      .bubble { animation-name: tada !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'wobble' ? `
      .bubble { animation-name: wobble !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'jello' ? `
      .bubble { animation-name: jello !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'heartbeat' ? `
      .bubble { animation-name: heartbeat !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'rubberBand' ? `
      .bubble { animation-name: rubberBand !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'lightSpeed' ? `
      .bubble { animation-name: lightSpeed !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'rollIn' ? `
      .bubble { animation-name: rollIn !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'rotateIn' ? `
      .bubble { animation-name: rotateIn !important; }
    ` : ''}
    
    /* Stagger animation delays */
    ${currentSettings.staggerMessages ? `
      .bubble:nth-child(n) {
        animation-delay: calc(var(--stagger-index, 0) * ${currentSettings.staggerDelay}s);
      }
    ` : ''}
  `;
  
  style.textContent = css;
  document.head.appendChild(style);
  
  updateBubbleTails();
  
  // Re-render messages to apply new animations
  if (currentKey && Object.keys(messageStore).length > 0) {
    const tempStore = { ...messageStore };
    messageStore = {};
    messagesEl.innerHTML = '';
    lastRenderedDate = null;
    processAndRenderMessages(tempStore);
  }
}

function updateBubbleTails() {
  const existingTailStyle = document.getElementById('bubble-tail-style');
  if (existingTailStyle) {
    existingTailStyle.remove();
  }
  
  const tailStyle = document.createElement('style');
  tailStyle.id = 'bubble-tail-style';
  
  const tailSize = 12;
  const borderRadius = currentSettings.bubbleRadius;
  
  tailStyle.textContent = `
    .from-user::after {
      border-bottom-left-radius: ${Math.min(borderRadius / 4, 4)}px !important;
    }
    .from-brother::after {
      border-bottom-right-radius: ${Math.min(borderRadius / 4, 4)}px !important;
    }
  `;
  
  document.head.appendChild(tailStyle);
}

// Initialize animations on page load
document.addEventListener('DOMContentLoaded', function() {
  // Apply animations to existing messages
  setTimeout(() => {
    const bubbles = document.querySelectorAll('.bubble');
    const settings = getCurrentAnimationSettings();
    
    bubbles.forEach((bubble, index) => {
      const isUser = bubble.classList.contains('from-user');
      if (settings.animationType !== 'none') {
        applyMessageAnimation(bubble, settings.animationType, settings.animationDuration, isUser);
      }
      
      if (settings.staggerMessages) {
        bubble.style.animationDelay = `${index * settings.staggerDelay}s`;
      }
    });
  }, 100);
});
</script>
</body>
</html>
