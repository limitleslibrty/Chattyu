 <!DOCTYPE html>
<html>
<head>
  <link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#ffffff" id="theme-color-meta">

  
  
  <meta charset="utf-8">
  <title>Brother Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, interactive-widget=resizes-content">

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <script src="firebase-config.js"></script>

  <!-- Preload images for faster UI -->
  <link rel="preload" as="image" href="chat_logo.png">
  <link rel="preload" as="image" href="chat.png">

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html { height: 100%; font-family: 'Segoe UI', sans-serif; background: #f2f3f7; overflow-x: hidden; }

    #list, #chat { display: none; height: 100%; width: 100%; }
    #list.active, 
    
    #chat.active {
  display: flex;
  flex-direction: column;
  height: 100%;
}

    #messages { overflow-x: hidden; }

    #inboxHeader {
      padding: 25px 20px 10px;
      font-size: 28px;
      font-weight: 700;
      
      background: #ffffff;
      background-clip: text;
      color: transparent;
      background-image: linear-gradient(to right, #2563eb, #7c3aed);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      border-bottom: 1px solid #e5e7eb;
    }

    #searchBox {
      margin: 12px 20px 0;
      padding: 10px 15px;
      border-radius: 30px;
      border: 1px solid #ccc;
      outline: none;
      font-size: 15px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.04);
    }
    


    #list {
      background: linear-gradient(to bottom right, #f4f6f9, #e2e6ec);
      overflow-y: auto;
    }
    
    
    

    .chat-item {
      position: relative;
      background: #ffffff;
      padding: 15px 20px;
      margin: 12px 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .chat-item:hover { background: #e0ecff; transform: translateY(-2px); }
    .chat-name { font-size: 16px; font-weight: 600; color: #333; }
    .chat-preview { font-size: 14px; color: #666; margin-top: 4px; }
    .chat-time {
      position: absolute; right: 20px; top: 18px;
      font-size: 12px; color: #888;
    }
    


    #chatHeader {
      flex-shrink: 0;
      background: #FFFFFF; color: #000000;
      padding: 4px; font-weight: 400; font-size: 18px;
      border-bottom: 1px solid #D2D0CEEB;
      display: flex; align-items: center;
    }

    #messages {
      flex: 1; padding: 10px; overflow-y: auto; display: flex; flex-direction: column;
      background-color: #BBBBBB;
      background-size: 110% 110%;
      background-repeat: no-repeat;
      background-position: center;
    }





/* Common bubble style */
.bubble {
  
  white-space: pre-wrap; 
  position: relative;
  margin: 6px 0;
  padding: 12px 16px;
  border-radius: 16px;
  max-width: 75%;
  font-size: 16px;
  line-height: 1.4;
  word-wrap: break-word;
}

/* User bubble (left) */
.from-user {
  background: #ffffff;
  align-self: flex-start;
  border-bottom-left-radius: 4px; /* smaller radius for tail corner */
}

/* Brother bubble (right) */
.from-brother {
  background: #dcf8c6;
  align-self: flex-end;
  border-bottom-right-radius: 4px; /* smaller radius for tail corner */
}

/* Tail for user bubble (left) */
.from-user::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0; /* start from left corner */
  width: 12px;
  height: 12px;
  background: #ffffff;
  border-bottom-left-radius: 4px;
  clip-path: polygon(0 0, 0% 100%, 100% 100%);
}

/* Tail for brother bubble (right) */
.from-brother::after {
  content: '';
  position: absolute;
  bottom: 0;
  right: 0; /* start from right corner */
  width: 12px;
  height: 12px;
  background: #dcf8c6;
  border-bottom-right-radius: 4px;
  clip-path: polygon(100% 0, 0% 100%, 100% 100%);
}




    .msg-time {
      font-size: 10px; color: #555; margin-top: 4px; align-self: flex-end;
    }

    .reply-box {
      font-size: 13px;
      color: #555;
      background: rgba(0,0,0,0.05);
      padding: 6px 10px;
      border-left: 4px solid #888;
      margin-bottom: 6px;
      border-radius: 4px;
    }

    #inputArea {
      flex-shrink: 0;
      display: flex; padding: 10px; background: #fff; border-top: 1px solid #ccc;
      flex-direction: column;
    }
    .reply-preview {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f0f0f0;
      padding: 6px 10px;
      border-left: 4px solid #4caf50;
      border-radius: 6px;
      font-size: 13px;
      margin-bottom: 6px;
      color: #333;
    }
    .reply-preview-text {
      flex: 1;
      white-space: normal;
      overflow: hidden;
      max-height: 3.2em;
    }
    .reply-preview button {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: #888;
    }
    
    .date-divider {
  text-align: center;
  margin: 10px auto;
  padding: 6px 14px;
  border-radius: 14px;
  font-size: 13px;
  font-weight: 600;
  color: #555;
  background: #e5e7eb;
  display: inline-block;
}

/* Dark mode divider */
body.dark .date-divider {
  background: #2a2a2a;
  color: #ddd;
}
  
  body.dark .from-user::after {
  background: #2a2a2a; /* matches dark bubble */
}
body.dark .from-brother::after {
  background: #056162; /* matches dark brother bubble */
}
    
    #inputControls { display: flex; align-items: flex-end; }
    #inputControls textarea {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #ccc;
      border-radius: 20px;
      resize: none;
      overflow: hidden;
      font-size: 15px;
      line-height: 1.4;
      max-height: 120px;
    }
    #inputControls textarea:focus {
      border-color: #bbb;
      outline: none;
    }
    #inputControls button {
      margin-left: 10px; padding: 8px 16px;
      background: #075E54; color: #fff; border: none; border-radius: 20px;
    }

    .reply-arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      transition: opacity 0.2s ease;
      font-size: 18px;
      color: #4caf50;
    }
    .from-user .reply-arrow { left: -28px; }
    .from-brother .reply-arrow { right: -28px; }
    .bubble.show-arrow .reply-arrow { opacity: 1; }
    
    
    
    
    /* üåô DARK MODE FIX */
body.dark {
  background: #121212 !important;
  color: #e5e5e5 !important;
}



/* üåô Dark mode for search bar */
body.dark #searchBox {
  background: #2a2a2a !important;
  color: #ffffff !important;
  border: 1px solid #444 !important;
}

body.dark #searchBox::placeholder {
  color: #aaaaaa !important;
}



/* Inbox header */
body.dark #inboxHeader {
  background-image: linear-gradient(to right, #9333ea, #3b82f6) !important;
  color: #ffffff !important;
}




/* Inbox chat items (dark mode) */
body.dark .chat-item {
  background: #2a2a2a;          /* dark gray card */
  color: #fff;                  /* default text = white */
}

body.dark .chat-item .chat-name {
  color: #ffffff;               /* pure white for names */
}

body.dark .chat-item .chat-preview {
  color: #bbbbbb;               /* softer gray for preview */
}

body.dark .chat-item .chat-time {
  color: #888888;               /* dim gray for timestamp */
}


/* Chat list */
body.dark #list {
  background: #1e1e1e !important;
}

body.dark .chat-item {
  background: #2a2a2a !important;
  color: #ffffff !important;   /* chat list names = pure white */
}

body.dark .chat-item:hover {
  background: #333 !important;
}

body.dark .chat-item small,
body.dark .chat-item .preview {
  color: #cccccc !important; /* slightly brighter gray */
}

/* Chat header */
body.dark #chatHeader {
  background: #1e1e1e !important;
  color: #ffffff !important;
}

/* Messages area */
body.dark #messages {
  background: #121212 !important;
}

/* User bubbles */
body.dark .from-user {
  background: #2a2a2a !important;
  color: #ffffff !important;
}

/* Brother bubbles */
body.dark .from-brother {
  background: #056162 !important;
  color: #ffffff !important;
}

/* Chat bubble timestamp */
body.dark .msg-time {
  font-size: 11px !important;
  color: #ffffff !important;   /* full white */
  text-align: right !important;
  margin-top: 4px !important;
  display: block !important;
}


/* Reply box (dark mode) */
body.dark .reply-box {
  color: #e5e5e5;
  background: rgba(255,255,255,0.08);  /* soft white overlay */
  border-left: 3px solid #3b82f6;      /* nice blue accent */
}
/* Input area */
body.dark #inputArea {
  background: #1e1e1e !important;
}

body.dark #inputControls textarea {
  background: #2a2a2a !important;
  color: #ffffff !important;
  border: 1px solid #444 !important;
}

body.dark #inputControls button {
  background: #3b82f6 !important;
  color: #ffffff !important;
}
    /* Reply preview (dark mode) */
body.dark .reply-preview {
  background: rgba(255, 255, 255, 0.08);  /* soft overlay on dark */
  border-left: 4px solid #3b82f6;         /* blue accent */
  color: #e5e5e5;
}

    /* Toggle button base */
#darkModeToggle {
  margin-left: auto;
  margin-right: 10px;
  padding: 6px 14px;
  border-radius: 20px;
  border: none;
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  transition: all 0.3s ease;
}

/* Light mode toggle */
body:not(.dark) #darkModeToggle {
background: #FFFFFF;   /* light gray */
  color: #111;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);

  
}

/* Dark mode toggle */
body.dark #darkModeToggle {
  background: #2a2a2a;   /* dark gray */
  color: #facc15;        /* warm yellow (sun icon) */
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

/* Hover effect */
#darkModeToggle:hover {
  transform: scale(1.05);
}
    

    
    
    
    
    
    
  </style>
</head>
<body>
  
  <audio id="sendSound" src="send.mp3" preload="auto"></audio>
<audio id="receiveSound" src="receive.mp3" preload="auto"></audio>
  <div id="list" class="active">
    <div id="inboxHeader" style="margin-left: 10px;">S talk</div>
    <input type="text" id="searchBox" placeholder="Search chats..." oninput="filterChats()" />
    <div id="chatList"></div>
  </div>

  <div id="chat">
    <div id="chatHeader">
      
<img id="userLogo" src="chat_logo.png"
     style="width:50px; height:50px; border:3px solid orange; border-radius:50%;
     margin-left: 5px;" />

      
<div style="margin-left:10px; display:flex; flex-direction:column;">
  <div id="chatTitle">Babuüòò</div>
  <div id="typingIndicator" style="font-size:12px; color:gray; display:none;">
    typing‚Ä¶
  </div>
</div>
      <button id="darkModeToggle" >
  üåô
</button>
    </div>
    <div id="messages"></div>
    <div id="inputArea">
      <div id="replyPreviewContainer"></div>
      <div id="inputControls">
        <textarea id="replyInput" placeholder="Type a message‚Ä¶" rows="1"></textarea>
        <button onclick="sendReply()">Send</button>
      </div>
    </div>
  </div>
  
  
  
  <script>
  document.addEventListener("DOMContentLoaded", function() {
    if (!localStorage.getItem("authenticated")) {
      document.body.style.filter = "blur(8px)";
      
      setTimeout(() => {
        const raw = prompt("Enter password to access:");
        const entered = raw === null ? '' : raw.trim();
        
        // CORRECT encoded value for this scheme:
        // scheme: reverse the real password, then Base64-encode that reversed string.
        // For real password "8990" -> reversed "0998" -> base64 => "MDk5OA=="
        const encoded = "MDk5OA==";
        
        function decodePassword(enc) {
          try {
            const decoded = atob(enc); // Base64 decode -> "0998"
            return decoded.split('').reverse().join(''); // reverse -> "8990"
          } catch (e) {
            return null;
          }
        }
        
        const expected = decodePassword(encoded);
        
        if (entered && expected && entered === expected) {
          localStorage.setItem("authenticated", "true");
          alert("Access granted ‚úÖ");
          document.body.style.filter = "none";
        } else {
          alert("Wrong password ‚ùå");
          location.reload();
        }
      }, 50);
    }
  });
</script>
 
 

<script>
const db = firebase.database();

const listEl = document.getElementById('list');
const chatEl = document.getElementById('chat');
const chatList = document.getElementById('chatList');
const messagesEl = document.getElementById('messages');
const replyInput = document.getElementById('replyInput');


// ---- Presence in the SAME typingIndicator div ----
let statusListener = null; // holds { ref, callback } for cleanup

function formatLastSeen(ts) {
  if (!ts) return 'Last seen: unknown';
  const d = new Date(Number(ts));
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today); yesterday.setDate(today.getDate() - 1);

  const timeStr = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });

  if (d.toDateString() === today.toDateString()) return 'Last seen today at ' + timeStr;
  if (d.toDateString() === yesterday.toDateString()) return 'Last seen yesterday at ' + timeStr;
  return 'Last seen ' + d.toLocaleDateString([], { day: 'numeric', month: 'short', year: 'numeric' }) + ' at ' + timeStr;
}

function subscribeToPresenceFor(chatKey) {
  // remove previous listener
  if (statusListener && statusListener.ref) {
    try { statusListener.ref.off('value', statusListener.callback); } catch(e) {}
    statusListener = null;
  }

  const typingEl = document.getElementById('typingIndicator');
  const userLogo = document.getElementById('userLogo');
  if (!typingEl) return;

  const statusRef = db.ref('status/' + chatKey);
  const callback = snap => {
    const statusObj = snap.val();
    let typing = false;
    let state = 'offline';
    let last_changed = null;

    if (statusObj) {
      if (typeof statusObj === 'object') {
        typing = !!statusObj.typing;
        state = statusObj.state || state;
        last_changed = statusObj.last_changed || null;
      } else if (typeof statusObj === 'string') {
        state = statusObj;
      }
    }

    // Show in same div
    if (typing) {
      typingEl.style.display = 'block';
      typingEl.textContent = 'typing‚Ä¶';
      typingEl.style.color = ''; // inherit or keep your css
      if (userLogo) userLogo.style.border = '3px solid green';
    } else {
      // not typing: online or last seen
      typingEl.style.display = 'block';
      if (state === 'online') {
        typingEl.textContent = 'online';
        typingEl.style.color = ''; // use CSS color or inline if you like
        if (userLogo) userLogo.style.border = '3px solid green';
      } else {
        typingEl.textContent = formatLastSeen(last_changed);
        typingEl.style.color = '';
        if (userLogo) userLogo.style.border = '3px solid orange';
      }
    }
  };

  statusListener = { ref: statusRef, callback };
  statusRef.on('value', callback);
}

// Ensure we subscribe when opening a chat
const oldOpenChat_forPresence = openChat;
openChat = function(key) {
  oldOpenChat_forPresence(key);
  // key in your app is the DB key (looks like you already use underscores)
  subscribeToPresenceFor(key);
};

// Optional: cleanup listener when going back to inbox
const oldPop = window.onpopstate;
window.addEventListener('popstate', function(event) {
  // remove presence listener when leaving chat view
  if (statusListener && statusListener.ref) {
    try { statusListener.ref.off('value', statusListener.callback); } catch(e) {}
    statusListener = null;
  }
  // also hide the typingIndicator when leaving
  const typingEl = document.getElementById('typingIndicator');
  if (typingEl) typingEl.style.display = 'none';

  if (typeof oldPop === 'function') oldPop(event);
});

/* ===== improved presence helper =====
   Replace your current setPresence(...) function with this.
*/
let _presenceHeartbeat = null;

function setPresence(userKey) {
  if (!userKey) return;
  const userStatusRef = db.ref('status/' + userKey);

  const makeOffline = () => ({
    state: 'offline',
    last_changed: Date.now(),
  });
  const makeOnline = () => ({
    state: 'online',
    last_changed: Date.now(),
  });

  // Clear any previous heartbeat
  if (_presenceHeartbeat) {
    clearInterval(_presenceHeartbeat);
    _presenceHeartbeat = null;
  }

  // Listen for connection status to RTDB servers
  db.ref('.info/connected').on('value', (snap) => {
    if (snap.val() === true) {
      // Ensure server will set offline when this client truly disconnects
      userStatusRef.onDisconnect().set(makeOffline()).catch(()=>{});

      // Immediately mark online
      userStatusRef.set(makeOnline()).catch(()=>{});

      // Start heartbeat to continually update last_changed so server
      // will not mark connection idle. 10s is a good compromise.
      if (!_presenceHeartbeat) {
        _presenceHeartbeat = setInterval(() => {
          userStatusRef.update({ last_changed: Date.now(), state: 'online' }).catch(()=>{});
        }, 5000);
      }
    } else {
      // not connected -> clear heartbeat
      if (_presenceHeartbeat) {
        clearInterval(_presenceHeartbeat);
        _presenceHeartbeat = null;
      }
    }
  });

  // Best-effort attempt to mark offline on page unload using beacon
  window.addEventListener('unload', () => {
    try {
      // Try to use onDisconnect as main line; sendBeacon is fallback
      const payload = JSON.stringify(makeOffline());
      // Using REST endpoint would be ideal, but as a fallback use sendBeacon to a small cloud function
      // Here we attempt a tiny write via navigator.sendBeacon to a special endpoint if you have one.
      // Fallback: attempt a synchronous set (sometimes fails)
      userStatusRef.set(makeOffline());
    } catch (e) {
      // ignore
    }
  });
}

// Call it like this:
setPresence("brother");




let typingTimeout;

replyInput.addEventListener("input", () => {
  // Mark brother as typing
  db.ref("status/brother/typing").set(true);
  
  // Reset after 2 seconds of no input
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    db.ref("status/brother/typing").set(false);
  }, 2000);
});
const searchBox = document.getElementById('searchBox');
const replyPreviewContainer = document.getElementById('replyPreviewContainer');

// Instead of listening to your own typing status:
const typingIndicator = document.getElementById('typingIndicator');

// use a single place to derive the DB key from the email
const currentUserEmail = "mahekj05@gmail.com";
const currentUserKey = currentUserEmail.replace(/\./g, '_');

// listen for typing under the same key used elsewhere
db.ref('status/' + currentUserKey + '/typing').on('value', (snapshot) => {
  const isTyping = snapshot.val();
  typingIndicator.style.display = isTyping ? 'block' : 'none';
});

let currentKey = null;
let childListener = null;
let allChats = [];
let replyToText = null;
let searchTimeout;

// --- Infinite scroll ---
let oldestLoadedKey = null;
let isLoadingOlder = false;
let reachedBeginning = false;

// --- Store messages ---
let messageStore = {};
let lastRenderedDate = null; 
let lastRenderedMsgTime = 0;
let initialLoadDone = false;
// global tracker// *** FIX: Track last date divider ***

// --- Cache helpers ---
function cacheChats(data) { localStorage.setItem('cachedChats', JSON.stringify(data)); }
function getCachedChats() { const c = localStorage.getItem('cachedChats'); return c ? JSON.parse(c) : null; }
function cacheMessages(chatKey, data) { localStorage.setItem('chat_' + chatKey, JSON.stringify(data)); }


function getCachedMessages(chatKey) { const c = localStorage.getItem('chat_' + chatKey); return c ? JSON.parse(c) : null; }

// --- Load cached chats ---
const cached = getCachedChats();
if (cached) renderChats(cached);

db.ref('chats').on('value', snapshot => {
  const chats = snapshot.val();
  if (chats) { cacheChats(chats); renderChats(chats); }
});


// use the correct brotherKey
function renderChats(chats) {
  chatList.innerHTML = '';
  allChats = [];
  const sortedKeys = Object.keys(chats).sort((a,b)=>{
    const lastA = Math.max(...Object.keys(chats[a]).map(Number));
    const lastB = Math.max(...Object.keys(chats[b]).map(Number));
    return lastB - lastA;
  });
  sortedKeys.forEach(key=>{
    const messages = chats[key];
    const timestamps = Object.keys(messages).map(Number).sort((a,b)=>a-b);
    const lastMsg = messages[timestamps[timestamps.length-1]];
    const lastTime = new Date(timestamps[timestamps.length-1]).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', hour12:true});
    
    
    const item = document.createElement('div');
    item.className = 'chat-item';
    item.onclick = ()=>openChat(key);
    const name = document.createElement('div'); name.className = 'chat-name'; name.textContent = key.replace(/_/g,'.');
    const preview = document.createElement('div'); preview.className = 'chat-preview'; preview.textContent = lastMsg.text;
    
    const event = new CustomEvent('chatOpened', { detail: key });
window.dispatchEvent(event);
    
    const time = document.createElement('div'); time.className = 'chat-time'; time.textContent = lastTime;
    item.appendChild(name); item.appendChild(preview); item.appendChild(time);
    chatList.appendChild(item);
    allChats.push({ key, element:item, preview:lastMsg.text });
  });
}

// --- Search ---
function filterChats(){
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(()=>{
    const term = searchBox.value.toLowerCase();
    allChats.forEach(chat=>{
      chat.element.style.display =
        chat.key.toLowerCase().includes(term) || chat.preview.toLowerCase().includes(term) ? '' : 'none';
    });
  },200);
}




// --- Date dividers ---
function formatDateSeparator(ts){
  const msgDate = new Date(Number(ts));
  const today = new Date();
  const yesterday = new Date(); yesterday.setDate(today.getDate()-1);
  if(msgDate.toDateString()===today.toDateString()) return "Today";
  else if(msgDate.toDateString()===yesterday.toDateString()) return "Yesterday";
  else return msgDate.toLocaleDateString([], { day:"numeric", month:"short", year:"numeric" });
}

function createDateDivider(label){
  const div = document.createElement("div");
  div.className = "date-divider";
  div.textContent = label;
  return div;
}




function buildMessageBubble(msgKey, val){
  const div = document.createElement('div');
  div.className = 'bubble ' + (val.from==='user' ? 'from-user':'from-brother');
  const arrow = document.createElement('div');
  arrow.className = 'reply-arrow';
  arrow.innerHTML = '‚Ü©';
  div.appendChild(arrow);
  attachSwipeHandlers(div,msgKey,val.text);
  if(val.replyTo && messageStore[val.replyTo]){
    const replyDiv = document.createElement('div');
    replyDiv.className = 'reply-box';
    replyDiv.textContent = messageStore[val.replyTo].text;
    div.prepend(replyDiv);
  }
  
  
  const textNode = document.createElement('div');
  textNode.textContent = val.text;
  div.appendChild(textNode);
  const timeNode = document.createElement('div');
  timeNode.className = 'msg-time';
  timeNode.textContent = new Date(Number(msgKey)).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', hour12:true});
  
  
  div.appendChild(timeNode);
  return div;
}

// --- Render messages (fixed) ---
function renderMessages(chatKey, messages) {
  const sortedKeys = Object.keys(messages).map(Number).sort((a, b) => a - b).map(String);
  const fragment = document.createDocumentFragment();
  
  sortedKeys.forEach(msgKey => {
    if (messageStore[msgKey]) return; // already rendered
    const val = messages[msgKey];
    if (!val || !val.text) return;
    messageStore[msgKey] = val;
    
    const msgDate = new Date(Number(msgKey));
    const dateLabel = formatDateSeparator(msgKey);
    
    // Date divider
    if (lastRenderedDate !== msgDate.toDateString()) {
      fragment.appendChild(createDateDivider(dateLabel));
      lastRenderedDate = msgDate.toDateString();
    }
    
    const div = buildMessageBubble(msgKey, val);
    fragment.appendChild(div);
    
    // üîä Play sound only for new incoming msgs (not history)
    if (initialLoadDone && val.from === "user" && chatKey === currentKey && Number(msgKey) > lastRenderedMsgTime) {
      const snd = document.getElementById("receiveSound");
      if (snd) snd.play().catch(() => {});
    }
    
    // update last seen
    if (Number(msgKey) > lastRenderedMsgTime) {
      lastRenderedMsgTime = Number(msgKey);
    }
  });
  
  messagesEl.appendChild(fragment);
  messagesEl.scrollTop = messagesEl.scrollHeight;
  
  // Mark first load as done
  initialLoadDone = true;
}

function openChat(key){
  listEl.classList.remove('active'); chatEl.classList.add('active');
  
  
  currentKey = key; document.getElementById('chatTitle').textContent="Babuüòò";
  history.pushState({screen:"chat"},"Chat");

  messageStore = {};
  lastRenderedDate = null; // *** Reset date tracking when opening a new chat ***
  messagesEl.innerHTML = '';

  const cachedMsgs = getCachedMessages(key);
  if(cachedMsgs) renderMessages(key,cachedMsgs);

  if(childListener) db.ref('chats/'+currentKey).off('value',childListener);
  childListener = db.ref('chats/'+currentKey)
    .on('value', snap=>{
      const msgs = snap.val();
      if(msgs){
        cacheMessages(currentKey,msgs);
        renderMessages(currentKey,msgs);
      }
    });
}

// --- Send reply ---
function sendReply(){
  const text = replyInput.value.trim();
  if(text==='' || !currentKey) return;
  const timestamp = Date.now();
  const message = {text,from:'brother'};
  if(replyToText){message.replyTo = replyToText.msgKey; replyToText=null;}
  
  db.ref('chats/'+currentKey+'/'+timestamp).set(message);
  db.ref("status/brother/typing").set(false); // stop typing

  document.getElementById("sendSound").play();
  
  replyInput.value='';
  replyInput.style.height="auto";
  replyInput.focus();
  replyPreviewContainer.innerHTML='';
}



// --- Swipe & reply handlers ---
function attachSwipeHandlers(bubbleEl,msgKey,text){
  let startX=0,startY=0,currentX=0,dragging=false,vibrated=false;
  bubbleEl.addEventListener('touchstart',e=>{startX=e.touches[0].clientX; startY=e.touches[0].clientY; dragging=true; vibrated=false; bubbleEl.style.transition="none";});
  bubbleEl.addEventListener('touchmove',e=>{
    if(!dragging) return; currentX=e.touches[0].clientX-startX; const dy=e.touches[0].clientY-startY; if(Math.abs(dy)>30) return;
    const offset=Math.sign(currentX)*Math.min(Math.abs(currentX),120);
    bubbleEl.style.transform=`translateX(${offset}px)`;
    if(Math.abs(offset)>50 && !bubbleEl.classList.contains("show-arrow")){
      bubbleEl.classList.add("show-arrow");
      if(!vibrated && navigator.vibrate){navigator.vibrate([80,50,80]);vibrated=true;}
    } else bubbleEl.classList.remove("show-arrow");
  });
  bubbleEl.addEventListener('touchend',()=>{
    dragging=false; bubbleEl.style.transition="transform 0.2s ease"; bubbleEl.classList.remove("show-arrow");
    if(Math.abs(currentX)>80){
      replyToText={msgKey,text};
      replyPreviewContainer.innerHTML=`<div class="reply-preview"><div class="reply-preview-text">${text}</div><button onclick="cancelReply()">‚úñ</button></div>`;
      replyInput.focus();
    }
    bubbleEl.style.transform="translateX(0px)"; currentX=0;
  });
}

function cancelReply(){replyToText=null; replyPreviewContainer.innerHTML=''; replyInput.placeholder='Type a message‚Ä¶';}
replyInput.addEventListener('blur',()=>{if(!replyInput.value && !replyToText) cancelReply();});

// --- Dark mode ---
// --- Dark mode ---
const darkModeToggle = document.getElementById("darkModeToggle");
const themeMeta = document.getElementById("theme-color-meta");

function updateThemeColor() {
  if (document.body.classList.contains("dark")) {
    themeMeta.setAttribute("content", "#121212"); // dark mode color
  } else {
    themeMeta.setAttribute("content", "#F2F2F2"); // light mode color
  }
}




// On load, check saved mode
if (localStorage.getItem("darkMode") === "enabled") {
  document.body.classList.add("dark");
  darkModeToggle.textContent = "‚òÄÔ∏è";
}
updateThemeColor();

// Toggle button click
darkModeToggle.addEventListener("click", () => {
  document.body.classList.toggle("dark");
  if (document.body.classList.contains("dark")) {
    localStorage.setItem("darkMode", "enabled");
    darkModeToggle.textContent = "‚òÄÔ∏è";
  } else {
    localStorage.setItem("darkMode", "disabled");
    darkModeToggle.textContent = "üåô";
  }
  updateThemeColor();
});




window.addEventListener("popstate", function(event) {
  if (chatEl.classList.contains('active')) {
    chatEl.classList.remove('active');
    listEl.classList.add('active');
    currentKey = null;
  } else {
    history.back();
  }
});
</script>




<script>
  // ensure this runs after firebase.initializeApp(...) and after "const db = firebase.database();"
  const userEmail = "mahekj05@gmail.com";
  const userKey = userEmail.replace(/\./g, '_');
  
  // debug helper
  db.ref('.info/connected').on('value', snap => {
    console.log('DEBUG: .info/connected =>', snap.val());
  });
  
  // call setPresence that you already defined (or add below if missing)
  
  
  // For UI: update avatar border on status changes (you already have similar code)
  db.ref('status/' + userKey).on('value', snapshot => {
    const status = snapshot.val();
    console.log('DEBUG: status snapshot', status);
    const userLogo = document.getElementById('userLogo');
    if (!userLogo) return;
    let state = null;
    if (status && typeof status === 'object') state = status.state;
    else state = status;
    userLogo.style.border = (state === 'online') ? '3px solid green' : '3px solid orange';
  });
</script>
<style>
.chat-item {
  position: relative; /* Important for absolute badge positioning */
}
.unread-badge {
  position: absolute;
  top: 40px;
  right: 20px;
  background: #25D366; /* WhatsApp green */
  color: white;
  font-size: 12px;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 12px;
  min-width: 18px;
  text-align: center;
  display: inline-block; /* Show by default for testing */
}
</style>
<script>
// --- UNREAD BADGES & LAST SEEN TRACKING ---
let unreadCounts = {}; // store counts per chat key
let lastSeen = {};     // store last seen timestamp per chat

// --- Load/Save last seen from localStorage ---
function saveLastSeen() {
  localStorage.setItem('lastSeen', JSON.stringify(lastSeen));
}
function loadLastSeen() {
  const data = localStorage.getItem('lastSeen');
  if (data) lastSeen = JSON.parse(data);
}
loadLastSeen();

// --- Render chats and show badges ---
const oldRenderChats = renderChats;
renderChats = function(chats) {
  oldRenderChats(chats); // call original renderChats
  Object.keys(chats).forEach(key => {
    const item = allChats.find(c => c.key === key)?.element;
    if (item) {
      let badge = item.querySelector('.unread-badge');
      if (!badge) {
        badge = document.createElement('span');
        badge.className = 'unread-badge';
        item.appendChild(badge);
      }
      badge.textContent = unreadCounts[key] || 0;
      badge.style.display = (unreadCounts[key] || 0) > 0 ? 'inline-block' : 'none';
    }
  });
};

// --- Reset unread count when opening a chat ---
const oldOpenChat = openChat;
openChat = function(key) {
  unreadCounts[key] = 0;
  lastSeen[key] = Date.now();
  saveLastSeen();
  renderChats(getCachedChats() || {});
  oldOpenChat(key);
};

// --- Listen for new messages (child_added and child_changed) ---
db.ref('chats').on('child_added', snap => {
  const chatKey = snap.key;
  const msgs = snap.val();
  const lastKey = Math.max(...Object.keys(msgs).map(Number));
  const lastMsg = msgs[lastKey];
  const seenTime = lastSeen[chatKey] || 0;

  if (lastMsg.from === 'user' && lastKey > seenTime && chatKey !== currentKey) {
    unreadCounts[chatKey] = (unreadCounts[chatKey] || 0) + 1;
    renderChats(getCachedChats() || {});
  }
});

db.ref('chats').on('child_changed', snap => {
  const chatKey = snap.key;
  const msgs = snap.val();
  const lastKey = Math.max(...Object.keys(msgs).map(Number));
  const lastMsg = msgs[lastKey];
  const seenTime = lastSeen[chatKey] || 0;

  if (lastMsg.from === 'user' && lastKey > seenTime && chatKey !== currentKey) {
    unreadCounts[chatKey] = (unreadCounts[chatKey] || 0) + 1;
    renderChats(getCachedChats() || {});
  }
});
  // When going back to inbox, badges will already be updated
</script>
<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker
        .register("./service-worker.js")
        .then((reg) => console.log("Service Worker registered:", reg.scope))
        .catch((err) => console.error("Service Worker failed:", err));
    });
  }
</script>
  <script>
    // Prevent pinch zoom
    document.addEventListener('touchmove', function(event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
    }, { passive: false });
    
    // Prevent double-tap zoom
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, { passive: false });
  </script>



</body>
</html>