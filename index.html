<!DOCTYPE html>
<html>
<head>
  <link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#ffffff" id="theme-color-meta">
<meta charset="utf-8">
  <title>Brother Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, interactive-widget=resizes-content">

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <script src="firebase-config.js"></script>

  <!-- Preload images for faster UI -->
  <link rel="preload" as="image" href="chat_logo.png">
  <link rel="preload" as="image" href="chat.png">
<!-- Emoji picker -->
<script src="https://cdn.jsdelivr.net/npm/@joeattardi/emoji-button@4.6.2/dist/index.min.js"></script>

  <!--for bottom gesture navigation bar removing-->
  <style>
/* Background Picker Styles */
.background-tabs {
  display: flex;
  border-bottom: 1px solid #ccc;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.bg-tab-btn {
  
  flex: 1;
  padding: 10px 8px;
  background: none;
  border: none;
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.2s;
  font-size: 12px;
  min-width: 80px;
}

body.dark .bg-tab-btn {
  color: #DDF2ED;
}

.bg-tab-btn.active {
  border-bottom: 2px solid #2563eb;
  font-weight: bold;
}

.bg-tab-content {
  display: none;
  max-height: 50vh;
  overflow-y: auto;
}

.bg-tab-content.active {
  display: block;
}

/* Color Grid */
.color-grid, .gradient-grid, .image-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
  margin-bottom: 20px;
}

.color-option, .gradient-option, .image-option {
  aspect-ratio: 1;
  border-radius: 8px;
  cursor: pointer;
  border: 2px solid transparent;
  transition: all 0.2s;
}

.color-option:hover, .gradient-option:hover, .image-option:hover {
  transform: scale(1.05);
  border-color: #2563eb;
}

.color-option.selected, .gradient-option.selected, .image-option.selected {
  border-color: #2563eb;
  border-width: 3px;
}

.image-option {
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}

/* Custom Upload */
.custom-upload {
  text-align: center;
  padding: 20px;
}

.upload-btn {
  background: #2563eb;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  margin-bottom: 10px;
  transition: background 0.2s;
}

.upload-btn:hover {
  background: #1d4ed8;
}

.upload-hint {
  color: #666;
  font-size: 14px;
  margin-bottom: 20px;
}

.blur-control, .opacity-control {
  margin: 15px 0;
  text-align: left;
}

.blur-control label, .opacity-control label {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
}

.blur-control input, .opacity-control input {
  width: 100%;
}

/* Dark mode adjustments */
body.dark .background-tabs {
  border-bottom-color: #2A3A36;
}

body.dark .bg-tab-content {
  color: #B7CAC6;
}

body.dark .upload-hint {
  color: #B7CAC6;
}

/* IMPORTANT: Override existing message background with !important */
#messages.custom-background {
  background-size: cover !important;
  background-position: center !important;
  background-repeat: no-repeat !important;
  background-attachment: fixed !important;
}


/* ===== SIMPLIFIED MESSAGE SELECTION STYLES ===== */
.bubble {
  position: relative;
  transition: all 0.2s ease;
}

.bubble.selected {
  position: relative;
  overflow: visible;
}

/* Green border on left */
.bubble.selected::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 4px;
  background: #25D366;
  z-index: 3;
  border-radius: 16px 0 0 16px;
}

/* Color overlay - SIMPLIFIED APPROACH */
.bubble.selected::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(37, 211, 102, 0.15);
  z-index: 1;
  border-radius: inherit;
  pointer-events: none;
}

/* Checkbox */
.bubble .selection-checkbox {
  position: absolute;
  left: -40px;
  top: 50%;
  transform: translateY(-50%);
  width: 20px;
  height: 20px;
  border: 2px solid #ccc;
  border-radius: 50%;
  background: white;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10;
  transition: all 0.2s ease;
}

.bubble.selected .selection-checkbox {
  display: flex;
  left: 10px;
  border-color: #25D366;
  background: #25D366;
}

.bubble.selected .selection-checkbox::after {
  content: '✓';
  color: white;
  font-size: 12px;
  font-weight: bold;
}

/* Ensure bubble content stays above the overlay */
.bubble>* {
  position: relative;
  z-index: 2;
}

/* Selection toolbar - TOP POSITION */
#selectionToolbar {
  position: fixed;
  top: 6px;
  left: 0;
  right: 0;
  background: #DDF2ED;
  color: #3A4F4A;
  padding: 12px 20px;
  display: none;
  align-items: center;
  justify-content: space-between;
  z-index: 1000;
  
}
body:not(.dark) #selectionToolbar .selection-action {
  color: #3A4F4A !important; /* Your desired color for light mode */
  transition: all 0.2s ease;
}

#selectionToolbar .selected-count {
  font-size: 18px;
  font-weight: 400;
}

#selectionToolbar .selection-actions {
  display: flex;
  gap: 15px;
}

#selectionToolbar .selection-action {
  background: none;
  border: none;
  color: white;
  font-size: 20px;
  cursor: pointer;
  padding: 5px;
  border-radius: 4px;
  transition: background 0.2s;
}

#selectionToolbar .selection-action:hover {
  background: rgba(255, 255, 255, 0.1);
}

/* Adjust messages padding when toolbar is visible */
#messages.with-selection-toolbar {
  padding-top: 70px !important;
  padding-bottom: 120px !important;
}

/* Dark mode styles */
body.dark .bubble .selection-checkbox {
  background: #2A2A2A;
  border-color: #666;
}

body.dark .bubble.selected .selection-checkbox {
  background: #25D366;
  border-color: #25D366;
}

body.dark #selectionToolbar {
  color: #DDF2ED;
  background: #13221F;
}



  /* Dark mode HR color */
body.dark #settingsMenu hr {
  border-color: #031813 !important;
  
}



  /* Enhanced Animation System */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { 
    opacity: 0;
    transform: translateY(20px);
  }
  to { 
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInLeft {
  from {
    opacity: 0;
    transform: translateX(-30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes bounce {
  0%, 20%, 53%, 80%, 100% {
    animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    transform: translate3d(0,0,0);
  }
  40%, 43% {
    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
    transform: translate3d(0, -15px, 0);
  }
  70% {
    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
    transform: translate3d(0, -8px, 0);
  }
  90% {
    transform: translate3d(0,-2px,0);
  }
}

@keyframes flip {
  from {
    transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
    animation-timing-function: ease-out;
  }
  40% {
    transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
    animation-timing-function: ease-out;
  }
  50% {
    transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
    animation-timing-function: ease-in;
  }
  80% {
    transform: perspective(400px) scale3d(.95, .95, .95);
    animation-timing-function: ease-in;
  }
  to {
    transform: perspective(400px);
    animation-timing-function: ease-in;
  }
}

@keyframes zoom {
  from {
    opacity: 0;
    transform: scale3d(.3, .3, .3);
  }
  50% {
    opacity: 1;
  }
}

@keyframes typewriter {
  from { width: 0; }
  to { width: 100%; }
}

@keyframes wave {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
  20%, 40%, 60%, 80% { transform: translateX(5px); }
}

@keyframes swing {
  20% { transform: rotate3d(0, 0, 1, 15deg); }
  40% { transform: rotate3d(0, 0, 1, -10deg); }
  60% { transform: rotate3d(0, 0, 1, 5deg); }
  80% { transform: rotate3d(0, 0, 1, -5deg); }
  to { transform: rotate3d(0, 0, 1, 0deg); }
}

@keyframes tada {
  0% { transform: scale3d(1, 1, 1); }
  10%, 20% { transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg); }
  30%, 50%, 70%, 90% { transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg); }
  40%, 60%, 80% { transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg); }
  100% { transform: scale3d(1, 1, 1); }
}

@keyframes wobble {
  0% { transform: none; }
  15% { transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg); }
  30% { transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg); }
  45% { transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg); }
  60% { transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg); }
  75% { transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg); }
  100% { transform: none; }
}

@keyframes jello {
  0%, 11.1%, 100% { transform: none; }
  22.2% { transform: skewX(-12.5deg) skewY(-12.5deg); }
  33.3% { transform: skewX(6.25deg) skewY(6.25deg); }
  44.4% { transform: skewX(-3.125deg) skewY(-3.125deg); }
  55.5% { transform: skewX(1.5625deg) skewY(1.5625deg); }
  66.6% { transform: skewX(-0.78125deg) skewY(-0.78125deg); }
  77.7% { transform: skewX(0.390625deg) skewY(0.390625deg); }
  88.8% { transform: skewX(-0.1953125deg) skewY(-0.1953125deg); }
}

@keyframes heartbeat {
  0% { transform: scale(1); }
  14% { transform: scale(1.1); }
  28% { transform: scale(1); }
  42% { transform: scale(1.1); }
  70% { transform: scale(1); }
}

@keyframes rubberBand {
  0% { transform: scale(1); }
  30% { transform: scaleX(1.25) scaleY(0.75); }
  40% { transform: scaleX(0.75) scaleY(1.25); }
  60% { transform: scaleX(1.15) scaleY(0.85); }
  100% { transform: scale(1); }
}

@keyframes lightSpeed {
  from {
    transform: translate3d(100%, 0, 0) skewX(-30deg);
    opacity: 0;
  }
  60% {
    transform: skewX(20deg);
    opacity: 1;
  }
  80% {
    transform: skewX(-5deg);
  }
  to {
    transform: none;
    opacity: 1;
  }
}

@keyframes rollIn {
  from {
    opacity: 0;
    transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
  }
  to {
    opacity: 1;
    transform: none;
  }
}

@keyframes rotateIn {
  from {
    transform-origin: center;
    transform: rotate3d(0, 0, 1, -200deg);
    opacity: 0;
  }
  to {
    transform-origin: center;
    transform: none;
    opacity: 1;
  }
}

/* Chat List Animations */
@keyframes chatItemFadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes chatItemSlideIn {
  from { opacity: 0; transform: translateX(-20px); }
  to { opacity: 1; transform: translateX(0); }
}

@keyframes chatItemBounceIn {
  0% { opacity: 0; transform: scale(0.3); }
  50% { opacity: 1; transform: scale(1.05); }
  70% { transform: scale(0.9); }
  100% { opacity: 1; transform: scale(1); }
}

/* Special Effects */
@keyframes ripple {
  0% {
    transform: scale(0);
    opacity: 1;
  }
  100% {
    transform: scale(4);
    opacity: 0;
  }
}

@keyframes glow {
  0%, 100% { box-shadow: 0 0 5px rgba(0, 123, 255, 0.5); }
  50% { box-shadow: 0 0 20px rgba(0, 123, 255, 0.8); }
}

@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

@keyframes unreadPulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

/* Animation Classes */
.bubble.animate-fadeIn { animation-name: fadeIn; }
.bubble.animate-slideUp { animation-name: slideUp; }
.bubble.animate-slideInLeft { animation-name: slideInLeft; }
.bubble.animate-slideInRight { animation-name: slideInRight; }
.bubble.animate-bounce { animation-name: bounce; }
.bubble.animate-flip { animation-name: flip; }
.bubble.animate-zoom { animation-name: zoom; }
.bubble.animate-wave { animation-name: wave; }
.bubble.animate-pulse { animation-name: pulse; }
.bubble.animate-shake { animation-name: shake; }
.bubble.animate-swing { animation-name: swing; }
.bubble.animate-tada { animation-name: tada; }
.bubble.animate-wobble { animation-name: wobble; }
.bubble.animate-jello { animation-name: jello; }
.bubble.animate-heartbeat { animation-name: heartbeat; }
.bubble.animate-rubberBand { animation-name: rubberBand; }
.bubble.animate-lightSpeed { animation-name: lightSpeed; }
.bubble.animate-rollIn { animation-name: rollIn; }
.bubble.animate-rotateIn { animation-name: rotateIn; }

.chat-item.animate-fadeIn { animation-name: chatItemFadeIn; }
.chat-item.animate-slideIn { animation-name: chatItemSlideIn; }
.chat-item.animate-bounceIn { animation-name: chatItemBounceIn; }

.bubble.ripple-effect::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 5px;
  height: 5px;
  background: rgba(255, 255, 255, 0.5);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  animation: ripple 0.6s linear;
}

.bubble.glow-effect {
  animation: glow 2s infinite;
}

.bubble.float-effect {
  animation: float 3s ease-in-out infinite;
}

.unread-badge.pulse-effect {
  animation: unreadPulse 1.5s infinite;
}
  /* Remove gesture navigation bar border */
body {
  overscroll-behavior-y: none !important;
}



/* SVG Color Variables */
:root {
  --svg-color: #3A4F4A; /* Light mode color */
}

body.dark {
  --svg-color: #B7CAC6; /* Dark mode color */
}

/* Apply to ALL SVGs */
svg {
  stroke: var(--svg-color) !important;
  
}
/* Custom color ONLY for call button in light mode */
body:not(.dark) #chatHeader a[href="videocall.html"] svg {
  fill:#3A4F4A !important; /* Custom blue color for call button in light mode */
}


/* For Android Chrome/Samsung Internet */
#inputArea {
  border-top: none !important;
}

/* Hide the navigation bar line */
html {
  scrollbar-width: none !important; /* Firefox */
}

body::-webkit-scrollbar {
  display: none !important; /* Chrome, Safari, Edge */
}


</style>

<style>



/* WhatsApp Style Full Screen Lightbox */
.lightbox {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    display: none;
    flex-direction: column;
    z-index: 10001;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.lightbox.active {
    display: flex;
    opacity: 1;
}

.lightbox-header {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 60px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 20px;
    z-index: 10;
}

.lightbox-close {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    backdrop-filter: blur(10px);
    transition: all 0.2s;
}

.lightbox-close:hover {
    background: rgba(255, 255, 255, 0.3);
}

.lightbox-counter {
    color: white;
    font-size: 16px;
    font-weight: 500;
}

.lightbox-content {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
}

.lightbox-image-container {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

.lightbox-image {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    transition: transform 0.3s ease;
    cursor: grab;
}

.lightbox-image.zoomed {
    cursor: grab;
}

.lightbox-image.dragging {
    cursor: grabbing;
}

.lightbox-nav {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    backdrop-filter: blur(10px);
    transition: all 0.2s;
    z-index: 10;
}

.lightbox-nav:hover {
    background: rgba(255, 255, 255, 0.3);
}

.lightbox-prev {
    left: 20px;
}

.lightbox-next {
    right: 20px;
}

.lightbox-footer {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
    padding: 30px 20px 20px;
    display: flex;
    justify-content: center;
    z-index: 10;
}

.lightbox-toolbar {
    display: flex;
    gap: 15px;
    background: rgba(30, 30, 30, 0.8);
    padding: 12px 20px;
    border-radius: 50px;
    backdrop-filter: blur(10px);
}

.lightbox-btn {
    background: rgba(255, 255, 255, 0.1);
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 25px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s;
    text-decoration: none;
}

.lightbox-btn:hover {
    background: rgba(255, 255, 255, 0.2);
}

.lightbox-btn.save-btn {
    background: rgba(37, 211, 102, 0.2);
    color: #25D366;
}

.lightbox-btn.save-btn:hover {
    background: rgba(37, 211, 102, 0.3);
}

/* Notification */

@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

/* Mobile Responsive */
@media (max-width: 768px) {
    .lightbox-header {
        height: 50px;
        padding: 0 15px;
    }
    
    .lightbox-close {
        width: 36px;
        height: 36px;
    }
    
    .lightbox-nav {
        width: 44px;
        height: 44px;
    }
    
    .lightbox-prev {
        left: 10px;
    }
    
    .lightbox-next {
        right: 10px;
    }
    
    .lightbox-footer {
        padding: 25px 15px 15px;
    }
    
    .lightbox-toolbar {
        gap: 10px;
        padding: 10px 16px;
    }
    
    .lightbox-btn {
        padding: 10px 16px;
        font-size: 13px;
    }
}

@media (max-width: 480px) {
    .lightbox-toolbar {
        flex-direction: column;
        gap: 8px;
        border-radius: 20px;
    }
    
    .lightbox-btn {
        justify-content: center;
    }
}
/* Keep input area fully transparent */
#inputArea {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 10px;
  background: transparent;
  border-top: none;
  display: flex;
  flex-direction: column;
  z-index: 30;
}

/* RCS Input Area */
/* Modern messenger-style input area */
/* Send button - positioned outside the input area */
#sendBtn {
  position: fixed; /* Changed from absolute to fixed */
  right: 15px;
  bottom: 13px;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #DDF2ED;
  border: none!important;
  cursor: pointer;
  color: white;
  
  transition: all 0.2s ease;
  z-index: 1001;
}

/* Light mode send button */
body:not(.dark) #sendBtn {
  background: #DDF2ED;

}
body.dark #sendBtn {
  background: #202C28;
  
}
/* Send button states */
#sendBtn:not(.active) {
  opacity: 1;
  transform: scale(0.9);
}

#sendBtn.active {
  opacity: 1;
  transform: scale(1);
}

#sendBtn:hover {
  transform: scale(1.05);

}


/* Adjust input controls to not overlap with send button */
#inputControls {
  display: flex;
  align-items: flex-end;
  gap: 8px;
  background: #1f2c28;
  padding: 8px 12px;
  border-radius: 24px;
  min-height: 52px;
  transition: all 0.2s ease;
  margin-right: 60px; /* Add space for the send button */
}

/* Light mode */
body:not(.dark) #inputControls {
  background: #DDF2ED;
  border: none;
  margin-right: 60px; /* Add space for the send button */
}

/* Remove the margin from inputArea since we're using fixed positioning */
#inputArea {
  margin-right: 0;
}

/* Light mode send button */
body:not(.dark) #sendBtn {
  background: #DDF2ED;
  
}




/* Hide GIF and emoji buttons when typing */
#inputControls:has(#replyInput:not(:placeholder-shown)) #gifBtn,
#inputControls:has(#replyInput:not(:placeholder-shown)) #emojiBtn {
  display: none;
}

/* Adjust messages padding to account for floating send button */
#messages {
  padding-bottom: 120px !important;
}



/* GIF picker modal */
#gifModal {
  position: fixed;
  left: 0; right: 0; top: 0; bottom: 0;
  display: none;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(4px);
  z-index: 9999;
}
#gifModal .panel {
  width: 92%;
  max-width: 720px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 12px 40px rgba(0,0,0,0.25);
  padding: 12px;
  max-height: 80vh;
  overflow: auto;
}
#gifModal .search {
  display:flex;
  gap:8px;
  margin-bottom:10px;
}
#gifResults {
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}
.gif-thumb {
  width: 30%;
  max-width: 160px;
  border-radius: 8px;
  cursor: pointer;
  object-fit: cover;
}
@media (max-width:480px){ .gif-thumb{ width: 48%; } }
</style>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html { height: 100%; font-family: 'Segoe UI', sans-serif; background: #f2f3f7; overflow-x: hidden; }

    #list, #chat {
  display: none; 
  height: 100%; 
  width: 100%;
  background: #DDF2ED; /* Same as messages background for light mode */
}


    #list.active, 
    
    #chat.active {
  display: flex;
  flex-direction: column;
  height: 100%;
}



body.dark #chat{
  background: #13221F; /* Same as dark mode messages background */
}
    #messages { overflow-x: hidden; }

   #inboxHeader {
  padding: 25px 20px 10px;
  font-size: 28px;
  font-weight: 700;
}

    #searchBox {
      background: #EAFDF9;
      margin: 12px 20px 0;
      padding: 10px 15px;
      border-radius: 30px;
      border: none;
      outline: none;
      font-size: 15px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.04);
    }
    


    #list {
      background:#DFF2EC;
      overflow-y: auto;
    }
    
    
    

    .chat-item {
      position: relative;
      background: #EAFDF9;
      padding: 15px 20px;
      margin: 12px 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .chat-item:hover { background: #e0ecff; transform: translateY(-2px); }
    .chat-name { font-size: 16px; font-weight: 600; color: #333; }
    .chat-preview { font-size: 14px; color: #666; margin-top: 4px; }
    .chat-time {
      position: absolute; right: 20px; top: 18px;
      font-size: 12px; color: #888;
    }
    
/* Bubble pop animation */
@keyframes bubblePop {
  0% {
    transform: scale(0.8);
    opacity: 0;
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

.bubble {
  animation: bubblePop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  transform-origin: bottom;
}

/* For user bubbles (left) */
.from-user {
  transform-origin: bottom left;
}

/* For brother bubbles (right) */
.from-brother {
  transform-origin: bottom right;
}

    #chatHeader {
      height:70px;
  border: none !important;
  flex-shrink: 0;
  background: #DDF2ED;
  color: #000000;
  padding: 4px;
  font-weight: 400;
  font-size: 18px;
  display: flex;
  
  align-items: center;
  box-shadow: none !important;
  outline: none !important;
}

    #messages {
      border-top-left-radius: 33px;
      border-top-right-radius: 33px;
      flex: 1; padding: 10px; overflow-y: auto; display: flex; flex-direction: column;
      background-color: #E9FEF9;
      background-size: 110% 110%;
      background-repeat: no-repeat;
      background-position: center;
    }





/* Common bubble style */
.bubble {
  
  white-space: pre-wrap; 
  position: relative;
  margin: 6px 0;
  padding: 12px 16px;
  border-radius: 16px;
  max-width: 75%;
  font-size: 18px;
  line-height: 1.4;
  word-wrap: break-word;
}

/* User bubble (left) */
.from-user {
  background: #DDF2ED;
  align-self: flex-start;
  border-bottom-left-radius: 4px; /* smaller radius for tail corner */
}

/* Brother bubble (right) */
.from-brother {
  background: #006B61;
  align-self: flex-end;
  color:white;
  
  border-bottom-right-radius: 4px; /* smaller radius for tail corner */
}

/* Tail for user bubble (left) */
/* Tail for user bubble (left) */
.from-user::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 14px;
  height: 14px;
  background: #DDF2ED;
  clip-path: polygon(-5% 0, 0% 100%, 100% 100%);
}

/* Tail for brother bubble (right) */
.from-brother::after {
  content: '';
  position: absolute;
  bottom: 0;
  right: 0; /* overlap slightly */
  width: 14px;
  height: 14px;
  background: #006B61;
  clip-path: polygon(100% 0, 0% 100%, 105% 100%);
}



/* Brother bubble timestamp - */
.from-brother .msg-time {
  color: white !important;
}


    .msg-time {
      font-size: 10px; color: black; margin-top: 4px; align-self: flex-end;
    }

.reply-box {
  min-width: 0px;
  font-size: 15px;
  color: #555;
  background: #E9FEF9;
  width: calc(100%);
border: 10px solid #DDF2ED;
}
body.dark .reply-box{
  border: 10px solid #13221F !important;
}

/* Remove all padding from bubbles with replies */
.bubble:has(.reply-box) {
  padding: 0 !important;
}

/* Top part (reply box) - no padding */
.reply-box {
  margin: 0 !important;
  padding: 8px 12px !important;
  border-radius: 16px 16px 0 0 !important;
  
}

/* Message text area - minimal bottom padding */
.bubble:has(.reply-box) > div:not(.reply-box):not(.msg-time) {
  padding: 12px 16px 4px 16px !important; /* Very small bottom padding */
  border-radius: 0 0 16px 16px !important;
}

/* Timestamp - remove all top margin and stick to message */
.bubble:has(.reply-box) .msg-time {
  margin-top: 0px !important;
  padding: 0px 16px 8px 16px !important; /* Padding only at bottom */
}

  #inputArea {
  flex-shrink: 0;
  display: flex;
  padding: 10px;
  background: transparent; /* ✅ transparent background */
  border-top: none;        /* ✅ no border */
  flex-direction: column;
  backdrop-filter: none;   /* ✅ no blur, fully clear */
}

    .reply-preview {
      
      
  background: rgba(255, 255, 255, 0.2); /* translucent layer */
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-radius: 10px;
  padding: 20px;

      display: flex;
      justify-content: space-between;
      align-items: center;
      
      padding: 6px 10px;
      border-left: 4px solid #005047;
      border-radius: 6px;
      font-size: 13px;
      margin-bottom: 6px;
      color: #333;
    }
    .reply-preview-text {
      flex: 1;
      white-space: normal;
      overflow: hidden;
      max-height: 3.2em;
    }
    .reply-preview button {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: #888;
    }
    
    .date-divider {
  text-align: center;
  margin: 10px auto;
  padding: 6px 14px;
  border-radius: 14px;
  font-size: 13px;
  font-weight: 600;
  color: #555;
  background: #DDF2ED;
  display: inline-block;
}

/* Dark mode divider */
body.dark .date-divider {
  background: #13221F;
  color: #B7CAC6;
}
  
  body.dark .from-user::after {
  background: #13221F; /*tail matches dark bubble */
}
body.dark .from-brother::after {
  background: #005047; /*tail matches dark brother bubble */
}
    
  
    #inputControls textarea {
      flex: 1;
      padding: 8px 12px;
  border:none!important;
  background: transparent;
      border-radius: 20px;
      resize: none;
      outline: none!important;
      overflow: hidden;
      font-size: 15px;
      line-height: 1.3;
      max-height: 80px;
    
    }
    
    /* Light mode input area text color */
body:not(.dark) #inputControls textarea {
  color: #666666;
}
body.dark #inputControls textarea {
  color: #DDF2ED;
}

    #inputControls button {
      margin-left: 5px;
      border: none;
      background: transparent; 
      color: #fff; 
      
      border-radius: 50px;
    }

    .reply-arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      transition: opacity 0.2s ease;
      font-size: 18px;
      color: #4caf50;
    }
    .from-user .reply-arrow { left: -28px; }
    .from-brother .reply-arrow { right: -28px; }
    .bubble.show-arrow .reply-arrow { opacity: 1; }
    
    
    
    
    /* 🌙 DARK MODE FIX */
body.dark {
  background: #121212 !important;
  color: #B7CAC6 !important;
}



/* 🌙 Dark mode for search bar */
body.dark #searchBox {
  background: #061613 !important;
  color: #B7CAC6 !important;

}

body.dark #searchBox::placeholder {
  color: #B7CAC6 !important;
}






/* Inbox chat items (dark mode) */
body.dark .chat-item {
  background: #2a2a2a;          /* dark gray card */
  color: #B7CAC6;                  /* default text = white */
}

body.dark .chat-item .chat-name {
  color: #B7CAC6;               /* pure white for names */
}

body.dark .chat-item .chat-preview {
  color: #B7CAC6;               /* softer gray for preview */
}

body.dark .chat-item .chat-time {
  color: #B7CAC6;               /* dim gray for timestamp */
}


/* Chat list */
body.dark #list {
  background: #12221F !important;
}

body.dark .chat-item {
  background: #061613 !important;
  color: #B7CAC6 !important;   /* chat list names = pure white */
}

body.dark .chat-item:hover {
  background: #333 !important;
}

body.dark .chat-item small,
body.dark .chat-item .preview {
  color: #B7CAC6 !important; /* slightly brighter gray */
}

/* Chat header */
body.dark #chatHeader {
  background: #13221F;
  color: #B7CAC6 !important;
}

/* Messages area */
body.dark #messages {
  background: #031813!important;
}

/* User bubbles */
body.dark .from-user {
  background: #13221F;
  color: #B7CAC6 !important;
}

/* Brother bubbles */
body.dark .from-brother {
  background: #005047;
  color: #B7CAC6 !important;
}

/* Chat bubble timestamp */
body.dark .msg-time {
  font-size: 11px !important;
  color: #B7CAC6 !important;   /* full white */
  text-align: right !important;
  margin-top: 4px !important;
  display: block !important;
}


/* Reply box (dark mode) */
body.dark .reply-box {
  color: #e5e5e5;
  background:#031813;
}


    /* Reply preview (dark mode) */
body.dark .reply-preview {
  background: rgba(255, 255, 255, 0.08);  /* soft overlay on dark */
  border-left: 
  4px solid #005047; /* blue accent */
  color: #e5e5e5;
}

    /* Toggle button base */
#darkModeToggle {
  margin-left: auto;
  margin-right: 10px;
  padding: 6px 14px;
  border-radius: 20px;
  border: none;
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  transition: all 0.3s ease;
}

/* Light mode toggle */
body:not(.dark) #darkModeToggle {
background: #DDF2ED;   /* light gray */
  color: #111;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);

  
}


/* Dark mode toggle */
body.dark #darkModeToggle {
  background: #13221F;   /* dark gray */
  color: #facc15;        /* warm yellow (sun icon) */
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

/* Hover effect */
#darkModeToggle:hover {
  transform: scale(1.05);
}
    
    
    
/* Change this: */
.bubble.message-highlight {
  background-color: #A1B790 !important;
}

/* To this: */
body:not(.dark) .bubble.message-highlight {
  background-color: #A1B790 !important;
}

body:not(.dark) .bubble.message-highlight.from-user::after,
body:not(.dark) .bubble.message-highlight.from-brother::after {
  background-color: #A1B790 !important;
}

/* Keep dark mode as is */
body.dark .bubble.message-highlight {
  background-color: #E6A23ECC !important;
}

body.dark .bubble.message-highlight.from-user::after,
body.dark .bubble.message-highlight.from-brother::after {
  background-color: #E6A23ECC !important;
}
    .loading-indicator {
  text-align: center;
  padding: 10px;
  color: #666;
  font-style: italic;
  background: rgba(255, 255, 255, 0.8);
  border-radius: 8px;
  margin: 10px;
}

body.dark .loading-indicator {
  background: rgba(42, 42, 42, 0.8);
  color: #B7CAC6;
}
    
    /* Styles for clickable links in messages */
.message-link {
  pointer-events: auto;
  color: #075E54;
  text-decoration: underline;
  word-break: break-all;
}

body.dark .message-link {
  color: #075E54;
  text-decoration: underline ;
}

.message-link:hover {
  text-decoration: underline;
}

/* For reply previews */
.reply-box a,
.reply-preview-text a {
  color: #075E54;
  text-decoration: none;
}

body.dark .reply-box a,
body.dark .reply-preview-text a {
  color: #075E54;
}

.reply-box a:hover,
.reply-preview-text a:hover {
  text-decoration: underline;
}
  </style>
</head>
<body>



  
  
  <audio id="sendSound" src="send.mp3" preload="auto"></audio>
<audio id="receiveSound" src="receive.mp3" preload="auto"></audio>

  <div id="list" class="active">
    <div id="inboxHeader" style="margin-left: 10px;">S talk</div>
  <input type="text" id="searchBox" placeholder="Search chats..." oninput="filterChats()" />
    <div id="chatList"></div>
  </div>

  <div id="chat">
    <div id="chatHeader">
<button type="button" onclick="goBackToList()"
style="
margin-left:17px;
background: transparent;
border:none"
>
  <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <line x1="19" y1="12" x2="5" y2="12"/>
    <polyline points="12 19 5 12 12 5"/>
  </svg>
  
</button>
<img id="userLogo" src="chat_logo.png" style="width:45px; height:45px; border-radius:50%; margin-left: 10px;" />

      
<div style="margin-left:10px; display:flex; flex-direction:column;">
  <div id="chatTitle"></div>
  <div id="typingIndicator" style="font-size:12px; color:gray; display:none;">
    typing…
  </div>
</div>

<a href="videocall.html"
style="margin-left: auto;
margin-right: 8px;
margin-top: 8px;
">
<!-- WhatsApp-like call icon (transparent background) -->
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#B7CAC6">
  <path d="M6.62 10.79a15.05 15.05 0 0 0 6.59 6.59l2.2-2.2a1 1 0 0 1 1.11-.21c1.2.48 2.53.73 3.88.73a1 1 0 0 1 1 1v3.5a1 1 0 0 1-1 1C12.07 22 2 11.93 2 3.5a1 1 0 0 1 1-1H6.5a1 1 0 0 1 1 1c0 1.35.25 2.68.73 3.88a1 1 0 0 1-.21 1.11l-2.2 2.2z" />
</svg></a>
<!-- Replace the existing dark mode toggle button with this -->
<div style="position: relative;">
  <button id="settingsToggle" title="Settings" style="
    margin-left: auto;
    margin-right: 10px;
    padding: 6px 14px;
    border-radius: 20px;
    border: none;
    cursor: pointer;
    font-size: 26px;
    font-weight: 600;
    background: transparent;
    color: #111;
  ">
    
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 6 20"
     width="6" height="18"
     preserveAspectRatio="xMidYMid meet"
     role="img" aria-label="Tiny vertical three dots">
  <!-- Tiny dots using stroke for fill -->
  <circle cx="3" cy="3"  r="1" fill="none" stroke="" stroke-width="2" stroke-linecap="round"/>
  <circle cx="3" cy="10"  r="1" fill="none" stroke="" stroke-width="2" stroke-linecap="round"/>
  <circle cx="3" cy="18" r="1" fill="none" stroke="" stroke-width="2" stroke-linecap="round"/>
</svg>
  </button>
  
  <!-- Settings dropdown menu -->
  <div id="settingsMenu">
    <style>
  #settingsMenu {
    /* Your existing styles */
    position: absolute;
    top: 100%;
    right: 10px;
    background: #DDF2ED;
    border-radius: 12px;
    margin-top: 18px;
    color: black;
    padding: 8px 0;
    min-width: 200px;
    z-index: 1000;
    display: none;
    max-height: 300px;
    overflow-y: scroll;
    
    /* Animation styles */
    transform-origin: top right;
    transform: scale(0);
    opacity: 0;
    transition: all 0.2s ease-out;
  }
  
  #settingsMenu.show {
    display: block;
    transform: scale(1);
    opacity: 1;
  }
</style>


    
    <style>
  body.dark #settingsMenu{
 color: #B7CAC6!important;
  background: #13221F!important;
}

.menu-item {
  padding: 10px 12px;
  cursor: pointer;
  transition: background 0.2s;
  font-size: 15.2px;
  display: flex;
  align-items: center;
  gap: 8px;
}


/* Color customization modal */
.color-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.color-modal.open {
  display: flex;
}

body.dark .color-modal-content {
  background: #13221F;
  color: #B7CAC6;
}

.color-option1 {
  margin-bottom: 15px;
  display: flex;
  align-items: center;
  gap: 10px;
  min-width: 0;
}

.color-option1 label {
  min-width: 140px;
  font-weight: 500;
  font-size: 14px;
  flex-shrink: 0;
}

/* ENHANCED COLOR INPUT WITH PICKER */
.color-input-container {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  min-width: 0;
}

.color-input {
  flex: 1;
  min-width: 0;
  padding: 8px 12px;
  border-radius: 8px;
  background: #DDF2ED;
  border: 1px solid #ccc;
  font-size: 14px;
  box-sizing: border-box;
  font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
  transition: all 0.2s ease;
}

.color-input:focus {
  outline: none;
  border-color: #2563eb;
  box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
}

.color-picker-toggle {
  width: 40px;
  height: 36px;
  border: 2px solid #e5e7eb;
  border-radius: 8px;
  cursor: pointer;
  background: white;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.color-picker-toggle:hover {
  border-color: #2563eb;
  transform: scale(1.05);
}

.color-preview {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 1px solid rgba(0, 0, 0, 0.1);
  background: currentColor;
}

/* ADVANCED COLOR PICKER DROPDOWN */
/* Color picker dropdown positioning - FIXED */
.color-picker-dropdown {
  position: fixed !important;
  background: #E9FEF9;
  border-radius: 16px;
  padding: 20px;
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
  z-index: 10002; /* Increased from 10000 to 10002 */
  min-width: 320px;
  max-width: 90vw;
  max-height: 80vh;
  overflow-y: auto;
  display: none;
  border: 1px solid #e5e7eb;
  backdrop-filter: blur(20px);
}

.color-picker-dropdown.show {
  display: block;
  animation: slideInUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}




/* Mobile responsiveness */
@media (max-width: 480px) {
  .color-picker-dropdown {
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    width: 95vw !important;
    max-width: 95vw !important;
    margin: 0 !important;
  }
}

@keyframes slideInUp {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.color-picker-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid #f3f4f6;
}

.color-picker-title {
  font-weight: 600;
  font-size: 16px;
  color: #111827;
}

.color-picker-close {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  color: #6b7280;
  padding: 4px 8px;
  border-radius: 6px;
  transition: all 0.2s;
}

.color-picker-close:hover {
  background: #f3f4f6;
  color: #374151;
}

/* Color Wheel Container */
.color-wheel-container {
  position: relative;
  width: 200px;
  height: 200px;
  margin: 0 auto 16px;
  cursor: pointer;
}

.color-wheel {
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: conic-gradient(
    from 0deg,
    #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000
  );
  position: relative;
  border: 2px solid white;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
}

.color-wheel::before {
  content: '';
  position: absolute;
  top: 10%;
  left: 10%;
  right: 10%;
  bottom: 10%;
  background: #DDF2ED;
  border-radius: 50%;
  pointer-events: none;
}

body.dark .color-wheel::before{
  background:#13221F;
}
.wheel-cursor {
  position: absolute;
  width: 16px;
  height: 16px;
  border: 2px solid white;
  border-radius: 50%;
  background: currentColor;
  pointer-events: none;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  transform: translate(-50%, -50%);
  z-index: 10;
}

/* Brightness/Saturation Controls */
.brightness-control {
  width: 100%;
  height: 24px;
  background: linear-gradient(to right, #000, transparent, #fff);
  border-radius: 12px;
  margin: 16px 0;
  position: relative;
  cursor: pointer;
  border: 1px solid #e5e7eb;
}

.brightness-cursor {
  position: absolute;
  width: 20px;
  height: 20px;
  border: 2px solid white;
  border-radius: 50%;
  background: #666;
  top: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
  pointer-events: none;
}

/* Alpha/Opacity Control */
.alpha-control {
  width: 100%;
  height: 24px;
  border-radius: 12px;
  margin: 16px 0;
  position: relative;
  cursor: pointer;
  border: 1px solid #e5e7eb;
  background-image: 
    linear-gradient(45deg, #ccc 25%, transparent 25%),
    linear-gradient(-45deg, #ccc 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, #ccc 75%),
    linear-gradient(-45deg, transparent 75%, #ccc 75%);
  background-size: 8px 8px;
  background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
}

.alpha-gradient {
  width: 100%;
  height: 100%;
  border-radius: 12px;
  position: absolute;
  top: 0;
  left: 0;
}

.alpha-cursor {
  position: absolute;
  width: 20px;
  height: 20px;
  border: 2px solid white;
  border-radius: 50%;
  background: #666;
  top: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
  pointer-events: none;
}

/* Color Inputs Grid */
.color-inputs-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  margin: 16px 0;
}

.color-input-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.color-input-label {
  font-size: 11px;
  font-weight: 600;
  color: #6b7280;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.color-channel-input {
  padding: 6px 8px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 12px;
  font-family: 'SF Mono', Monaco, Consolas, monospace;
  background: #DDF2ED;
}

.color-channel-input:focus {
  outline: none;
  border-color: #3b82f6;
}

/* Current Color Preview */
.current-color-preview {
  display: flex;
  align-items: center;
  gap: 12px;
  margin: 16px 0;
  padding: 12px;
  background: #DDF2ED;
  border-radius: 8px;
}

.color-preview-large {
  width: 48px;
  height: 48px;
  border-radius: 8px;
  border: 2px solid white;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  background: var(--current-color, #000000);
}

.color-values {
  flex: 1;
}

.hex-value {
  font-family: 'SF Mono', Monaco, Consolas, monospace;
  font-size: 14px;
  font-weight: 600;
  color: #111827;
  margin-bottom: 4px;
}

.rgb-value {
  font-family: 'SF Mono', Monaco, Consolas, monospace;
  font-size: 11px;
  color: #6b7280;
}

/* Preset Colors */
.preset-colors {
  margin-top: 16px;
}

.preset-title {
  font-size: 12px;
  font-weight: 600;
  color: #6b7280;
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.preset-grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 6px;
}

.preset-swatch {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  cursor: pointer;
  border: 1px solid rgba(0, 0, 0, 0.1);
  transition: all 0.2s;
}

.preset-swatch:hover {
  transform: scale(1.2);
  border-color: rgba(0, 0, 0, 0.3);
}

/* Action Buttons */
.color-picker-actions {
  display: flex;
  gap: 8px;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid #f3f4f6;
}

.color-picker-btn {
  flex: 1;
  padding: 8px 16px;
  border: none;
  border-radius: 6px;
  background: #DDF2ED;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.color-picker-btn.primary {
  background: #3b82f6;
  color: white;
  border-color: #3b82f6;
}


.color-picker-btn.primary:hover {
  background: #2563eb;
}

/* Dark Mode Adjustments */
body.dark .color-input {
  background: #061613;
  color: #B7CAC6;
  border-color: #2A3A36;
}

body.dark .color-picker-toggle {
  background: #061613;
  border-color: #2A3A36;
}

body.dark .color-picker-dropdown {
  background: #13221F;
  border-color: #374151;
  color: #f9fafb;
}

body.dark .color-picker-header {
  border-bottom-color: #031813;
}

body.dark .color-picker-title {
  color: #f9fafb;
}

body.dark .color-picker-close {
  color: #9ca3af;
}

body.dark .color-picker-close:hover {
  background: #031813;
  color: #f9fafb;
}

body.dark .color-channel-input {
  background: #031813;
  border-color: #4b5563;
  color: #f9fafb;
}

body.dark .color-channel-input:focus {
  background: #031813;
  border-color: #3b82f6;
}

body.dark .current-color-preview {
  background: #031813B0;
}

body.dark .hex-value {
  color: #f9fafb;
}

body.dark .color-picker-btn {
  background: #031813;
  border-color: #4b5563;
  color: #f9fafb;
}


body.dark .alpha-control {
  border-color: #4b5563;
}

/* Responsive Design */
@media (max-width: 480px) {
  .color-picker-dropdown {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90vw;
    max-width: 340px;
    margin: 0;
  }
  
  .color-wheel-container {
    width: 180px;
    height: 180px;
  }
  
  .preset-grid {
    grid-template-columns: repeat(6, 1fr);
  }
  
  .color-inputs-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* Keep existing modal styles */
.color-modal-content {
  background: #E9FEF9;
  border-radius: 16px;
  padding: 20px;
  width: 90%;
  max-width: 500px;
  max-height: 80vh;
  overflow-y: auto;
  overflow-x: hidden;
  box-sizing: border-box;
}

body.dark .color-modal-content {
  background: #13221F;
  color: #B7CAC6;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
}

.modal-btn {
  padding: 8px 16px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.2s;
}

.modal-btn.primary {
  background: #2563eb;
  color: white;
}

.modal-btn.secondary {
  background: #DDF2ED;
  color: #374151;
}

body.dark .modal-btn.secondary {
  background: #2A3A36;
  color: #B7CAC6;
}

.modal-btn:hover {
  opacity: 0.9;
  transform: translateY(-1px);
}


    </style>
    <div class="menu-item" data-action="toggle-dark">🌙 Dark Mode</div>
    <div class="menu-item" data-action="toggle-light">☀️ Light Mode</div>
    <div class="menu-item" data-action="customize-dark">🎨 Customize Dark Mode</div>
    <div class="menu-item" data-action="customize-light">🎨 Customize Light Mode</div>
    <div class="menu-item" data-action="reset-colors">🔄 Reset all colours</div>
    <div class="menu-item" data-action="advanced-settings">⚙️ Setting</div>
    <!-- Add these menu items in your settings menu -->
<div class="menu-item" data-action="chat-background">🎨 Chat Background</div>


        <hr color=#E9FEF9 />
    <div class="menu-item">Extras</div>
    <hr color=#E9FEF9 />
   <a href="https://retail.sbi.bank.in/retail/login.htm" style="text-decoration: none;
    color: inherit;"> <div class="menu-item">
       <img height="20px" width="20px" style="border:0px solid black;" src="sbi.png" alt="" />SBI</div></a>
    
    
    <hr color=#E9FEF9  />
    <div class="menu-item" >Also from San</div>
    <hr color=#E9FEF9  />
    <a href="user.html" style="text-decoration: none;
    color: inherit;"> <div class="menu-item">
       <img height="20px" width="20px" style="border:0px solid black;
       transform: scale(1.6);" src="logo.png" alt="" />chat</div></a>
       
    <a href="https://limitleslibrty.github.io/sanhub4u/" style="text-decoration: none;
    color: inherit;"><div style="margin-top: -6px;" class="menu-item"><img height="20px" width="20px" style="border:0px solid black;transform: scale(1.5)" src="sanhub4u.png" alt="" /> Sanhub4u</div></a>
       <a href="https://limitleslibrty.github.io/Image-compressor/" style="text-decoration: none;
    color: inherit;"> <div class="menu-item" style="margin-top:-6px;"><img height="20px" width="20px" style="border:0px solid black;transform: scale(1.1)" src="pix.png" alt="" /> sanhubpix</div></a>
    
  </div>
</div>

    </div>
    <div id="messages"></div>
<div id="inputArea">
  <div id="replyPreviewContainer"></div>
  <div id="inputControls">
    
    <button id="gifBtn" title="GIF" style="height:35px;">
      
      
      
      
   <svg xmlns="http://www.w3.org/2000/svg" 
     width="24" height="24" 
     fill="none" 
     stroke="" 
     stroke-width="2" 
     stroke-linecap="round" 
     stroke-linejoin="round">

  <!-- outer rounded square -->
  <rect x="3" y="3" width="18" height="18" rx="6" ry="6"/>

  <!-- eyes -->
  <circle cx="9" cy="10" r="1"/>
  <circle cx="15" cy="10" r="1"/>

  <!-- mouth with folded corner -->
  <path d="M8 15h4c1.5 0 3 1 3 2v1l3-3"/>
</svg>
      
      
    </button>
    <!-- optional file attach (works locally; to upload to Firebase Storage add storage SDK) -->
    <input id="attachFile" type="file" accept="image/*,video/gif" multiple style="display:none" />
    <button id="attachBtn" title="Attach"
    style="height:35px;">
  <svg xmlns="http://www.w3.org/2000/svg" 
       width="24" height="24" 
       fill="none" 
       stroke="" 
       stroke-width="2" 
       stroke-linecap="round" 
       stroke-linejoin="round">
    <path d="M21.44 11.05l-9.19 9.19a5 5 0 0 1-7.07-7.07l9.19-9.19a3.5 3.5 0 0 1 4.95 4.95l-9.19 9.19a2 2 0 0 1-2.83-2.83l8.48-8.48" />
  </svg>

      
      
    </button>
    
    <textarea id="replyInput" placeholder="Type" rows="1" style="flex:1"></textarea>
    <button id="sendBtn">
      
  <!-- Up Arrow Icon -->
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="26" fill="none" stroke="" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
    <path d="M12 19V5"></path>
    <path d="M5 12l7-7 7 7"></path>
  </svg>

    </button>
  </div>
</div>
<!-- Chat Background Picker Modal -->
<div id="backgroundModal" class="color-modal" aria-hidden="true">
  <div class="color-modal-content">
    <div class="background-modal-header">
      <h3 style="margin: 0;">Chat Background</h3>
      <button class="background-close-btn" id="closeBackgroundModal" aria-label="Close">×</button>
    </div>
    

  <div class="background-tabs">
  <button class="bg-tab-btn active" data-tab="colors">Solid Colors</button>
  <button class="bg-tab-btn" data-tab="gradients">Gradients</button>
  <button class="bg-tab-btn" data-tab="images">Saved Images</button>
</div>
    
    <div id="colorsTab" class="bg-tab-content active">
      <div class="color-grid">
        <div class="color-option" data-color="#ffffff" style="background: #ffffff; border: 1px solid #eee;"></div>
        <div class="color-option" data-color="#f0f8ff" style="background: #f0f8ff;"></div>
        <div class="color-option" data-color="#fff0f5" style="background: #fff0f5;"></div>
        <div class="color-option" data-color="#f0fff0" style="background: #f0fff0;"></div>
        <div class="color-option" data-color="#fff8dc" style="background: #fff8dc;"></div>
        <div class="color-option" data-color="#f5f5f5" style="background: #f5f5f5;"></div>
        <div class="color-option" data-color="#e6e6fa" style="background: #e6e6fa;"></div>
        <div class="color-option" data-color="#faf0e6" style="background: #faf0e6;"></div>
      </div>
    </div>
    
    <div id="gradientsTab" class="bg-tab-content">
      <div class="gradient-grid">
        <div class="gradient-option" data-gradient="linear-gradient(135deg, #667eea 0%, #764ba2 100%)" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"></div>
        <div class="gradient-option" data-gradient="linear-gradient(135deg, #f093fb 0%, #f5576c 100%)" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);"></div>
        <div class="gradient-option" data-gradient="linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);"></div>
        <div class="gradient-option" data-gradient="linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);"></div>
        <div class="gradient-option" data-gradient="linear-gradient(135deg, #fa709a 0%, #fee140 100%)" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);"></div>
        <div class="gradient-option" data-gradient="linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)" style="background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);"></div>
      </div>
    </div>
    
<div id="imagesTab" class="bg-tab-content">
  <!-- Add Upload Section -->
  <div class="custom-upload" style="margin-bottom: 20px;">
    <input type="file" id="bgImageUpload" accept="image/*" style="display: none;">
    <button class="upload-btn" onclick="document.getElementById('bgImageUpload').click()">
      📁 Upload New Image
    </button>
    
    <!-- Add Image from URL Section -->
    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ccc;">
      <input 
        type="text" 
        id="imageUrlInput" 
        placeholder="Paste image URL here..."
        style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 8px; margin-bottom: 10px;"
      >
      <button class="upload-btn" onclick="addImageFromUrl()" style="background: #10B981;">
        🔗 Add from URL
      </button>
    </div>
    
    <p class="upload-hint">Upload an image or add from URL to add to Stalk saved collection</p>
  </div>
  
  <div class="image-grid" id="savedImagesGrid">
    <!-- Existing images -->
    <div class="image-option" data-image="https://images.unsplash.com/photo-1518837695005-2083093ee35b?w=400" style="background-image: url('https://images.unsplash.com/photo-1518837695005-2083093ee35b?w=400')"></div>
    <div class="image-option" data-image="https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400" style="background-image: url('https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400')"></div>
    <!-- Uploaded images will be added here dynamically -->
  </div>
</div>
    
    
    <div class="modal-actions">
      <button class="modal-btn secondary" id="resetBackgroundBtn">Reset to Default</button>
      <button class="modal-btn primary" id="applyBackgroundBtn">Apply as chat bg</button>
    </div>
  </div>
</div>
<!-- GIF modal -->
<div id="gifModal" aria-hidden="true">
  <div class="panel">
    <div class="search">
            <button style="
      background: rgba(255, 255, 255, 0.9);
border: 1px solid rgba(0,0,0,0.1);
border-radius: 50%;
width: 36px;
height: 36px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
color: grey;
      
      " id="gifCloseBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="128" height="128" aria-hidden="true">
  <!-- circle background -->
  <circle cx="50" cy="50" r="44" fill="#CFCFF3" />
  <!-- left arrow (shaft + head). adjust stroke-width to change thickness -->
  <g fill="none" stroke="#2F3140" stroke-width="8" stroke-linecap="round" stroke-linejoin="round">
    <!-- shaft -->
    <path d="M70 50 H35" />
    <!-- head -->
    <path d="M45 33 L25 50 L45 67" />
  </g>
</svg></button>
   
      <input id="gifSearch" placeholder="Search GIFs (Tenor)" style="flex:1;padding:8px;border-radius:8px;border:1px solid #ccc" />
      <button id="gifSearchBtn" style="
      background: rgba(255, 255, 255, 0.9);
border: 1px solid rgba(0,0,0,0.1);
border-radius: 50%;
width: 36px;
height: 36px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
color: grey;
padding: 3px;
;"
      >
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="11" cy="11" r="8" />
  <line x1="21" y1="21" x2="16.65" y2="16.65" />
</svg>
      </button>
 </div>
    <div id="gifResults"></div>
  </div>
</div>
  </div>
  
  
  
  <script>
  




// ===== WHATSAPP-LIKE SCROLL BEHAVIOR =====
let isUserScrolling = false;
let lastScrollPosition = 0;
let newMessagesCount = 0;
let unreadMessages = [];
let newMessagesDividerAdded = false;
let scrollEndTimer;
let unreadDividerTimer;

// Initialize scroll tracking
function initializeScrollTracking() {
  const messagesEl = document.getElementById('messages');
  if (!messagesEl) return;
  
  messagesEl.addEventListener('scroll', handleScroll);
}

// Check if near bottom
function isNearBottom(threshold = 100) {
  const messagesEl = document.getElementById('messages');
  if (!messagesEl) return true;
  return messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight < threshold;
}

// Handle scroll events
function handleScroll() {
  const messagesEl = document.getElementById('messages');
  if (!messagesEl) return;
  
  // Infinite scroll
  if (isLoadingOlderMessages || !hasMoreMessages) return;
  
  if (messagesEl.scrollTop < 100) {
    loadOlderMessages();
  }
  
  const currentScroll = messagesEl.scrollTop;
  const scrollDirection = currentScroll > lastScrollPosition ? 'down' : 'up';
  
  // When user manually scrolls to bottom
  if (scrollDirection === 'down' && isNearBottom(50)) {
    handleViewingNewMessages();
  }
  
  lastScrollPosition = currentScroll;
}

// Handle when user views new messages (click or manual scroll)
function handleViewingNewMessages() {
  // Reset unread count immediately
  resetUnreadCount();
  
  // Remove message highlights immediately
  clearMessageHighlights();
  
  // Hide notification immediately
  hideNewMessageNotification();
  
  // Remove unread divider after 5 seconds
  clearTimeout(unreadDividerTimer);
  unreadDividerTimer = setTimeout(() => {
    removeNewMessagesDivider();
  }, 5000);
}

// Show notification and divider
function showNewMessageNotification(count = 1) {
  const notification = document.getElementById('newMessageNotification');
  const countElement = document.getElementById('newMessageCount');
  
  if (!notification || !countElement) return;
  
  newMessagesCount += count;
  countElement.textContent = newMessagesCount;
  notification.style.display = 'flex';
  
  // Always add divider when new messages arrive
  addNewMessagesDivider();
  
  if (navigator.vibrate) {
    navigator.vibrate([100, 50, 100]);
  }
  
  // Auto-hide notification after 8 seconds (but keep divider)
  setTimeout(() => {
    if (notification.style.display !== 'none') {
      hideNewMessageNotification();
    }
  }, 8000);
}

// Scroll to new messages (when clicking notification)
function scrollToNewMessages() {
  const messagesEl = document.getElementById('messages');
  if (!messagesEl) return;
  
  // Scroll to bottom first
  messagesEl.scrollTo({
    top: messagesEl.scrollHeight,
    behavior: 'smooth'
  });
  
  // Then handle viewing messages
  setTimeout(() => {
    handleViewingNewMessages();
  }, 300);
}

// Hide notification only (keep divider)
function hideNewMessageNotification() {
  const notification = document.getElementById('newMessageNotification');
  if (notification) {
    notification.style.display = 'none';
  }
}

// Reset unread count
function resetUnreadCount() {
  newMessagesCount = 0;
  const countElement = document.getElementById('newMessageCount');
  if (countElement) {
    countElement.textContent = '0';
  }
  unreadMessages = [];
}

// Clear message highlights
function clearMessageHighlights() {
  document.querySelectorAll('.bubble.new-message').forEach(bubble => {
    bubble.classList.remove('new-message');
  });
}

// Add divider
function addNewMessagesDivider() {
  // Remove existing divider first to avoid duplicates
  removeNewMessagesDivider();
  
  const messagesEl = document.getElementById('messages');
  if (!messagesEl || unreadMessages.length === 0) return;
  
  const divider = document.createElement('div');
  divider.className = 'new-messages-divider';
  divider.innerHTML = '<span>New messages</span>';
  divider.id = 'newMessagesDivider';
  
  const firstUnreadMsg = document.getElementById('msg_' + unreadMessages[0]);
  if (firstUnreadMsg && firstUnreadMsg.parentNode) {
    firstUnreadMsg.parentNode.insertBefore(divider, firstUnreadMsg);
    newMessagesDividerAdded = true;
    console.log('Unread divider added');
  }
}

// Remove divider
function removeNewMessagesDivider() {
  const divider = document.getElementById('newMessagesDivider');
  if (divider) {
    divider.remove();
    newMessagesDividerAdded = false;
    console.log('Unread divider removed');
  }
}
  let selectedBackground = null;
let selectedType = 'color';
  document.addEventListener('DOMContentLoaded', function() {
  // Your existing authentication code
  if (!localStorage.getItem("authenticated")) {
    document.body.style.filter = "blur(8px)";
    
    setTimeout(() => {
      const raw = prompt("Enter password to access:");
      const entered = raw === null ? '' : raw.trim();
      
      // CORRECT encoded value for this scheme:
      // scheme: reverse the real password, then Base64-encode that reversed string.
      // For real password "8990" -> reversed "0998" -> base64 => "MDk5OA=="
      const encoded = "MDk5OA==";
      
      function decodePassword(enc) {
        try {
          const decoded = atob(enc); // Base64 decode -> "0998"
          return decoded.split('').reverse().join(''); // reverse -> "8990"
        } catch (e) {
          return null;
        }
      }
      
      const expected = decodePassword(encoded);
      
      if (entered && expected && entered === expected) {
        localStorage.setItem("authenticated", "true");
        alert("Access granted ✅");
        document.body.style.filter = "none";
      } else {
        alert("Wrong password ❌");
        location.reload();
      }
    }, 50);
  }
  
  // Initialize all your existing functionality
  initializeUploadedImages();
  loadSavedDP();
  loadSavedBackground();
  loadSavedHomeBackground();
  loadSavedName();
  
  
  setTimeout(() => {
  initializeScrollTracking();
  console.log('WhatsApp-like scroll behavior initialized');
}, 2000);
  // Initialize ALL images (both default and uploaded) with click handlers
  function initializeAllImages() {
    const allImages = document.querySelectorAll('.image-option');
    allImages.forEach(imageOption => {
      const imageUrl = imageOption.getAttribute('data-image');
      const imageName = imageOption.getAttribute('data-name') || 'Default Image';
      
      // Remove any existing click listeners to prevent duplicates
      const newImageOption = imageOption.cloneNode(true);
      imageOption.parentNode.replaceChild(newImageOption, imageOption);
      
      // Add click handler to the new element
      newImageOption.addEventListener('click', function(e) {
        e.stopPropagation();
        
        // Remove selection from all other options
        document.querySelectorAll('.color-option, .gradient-option, .image-option').forEach(opt => {
          opt.classList.remove('selected');
        });
        
        // Select this image
        this.classList.add('selected');
        
        // Store selection
        selectedBackground = this.getAttribute('data-image');
        selectedType = 'image';
        
        // Show action options for ALL images
        showImageActions(this, imageUrl, imageName);
      });
    });
  }
  
  // Initialize images after a short delay to ensure DOM is ready
  setTimeout(initializeAllImages, 100);
  
  // Initialize WhatsApp-like scroll behavior
  setTimeout(() => {
    initializeScrollTracking();
    console.log('WhatsApp-like scroll behavior initialized');
  }, 2000);
  
  // Re-initialize when background modal opens (for newly uploaded images)
  const backgroundModal = document.getElementById('backgroundModal');
  if (backgroundModal) {
    backgroundModal.addEventListener('click', function(e) {
      if (e.target === backgroundModal || e.target.classList.contains('background-close-btn')) {
        // Re-initialize images when modal closes/opens to catch new uploads
        setTimeout(initializeAllImages, 300);
      }
    });
  }
});
</script>
 
 

<script>
const db = firebase.database();

const listEl = document.getElementById('list');
const chatEl = document.getElementById('chat');
const chatList = document.getElementById('chatList');
const messagesEl = document.getElementById('messages');
const replyInput = document.getElementById('replyInput');


// ---- Presence in the SAME typingIndicator div ----
let statusListener = null; // holds { ref, callback } for cleanup

function formatLastSeen(ts) {
  if (!ts) return 'Last seen: unknown';
  const d = new Date(Number(ts));
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today); yesterday.setDate(today.getDate() - 1);

  const timeStr = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });

  if (d.toDateString() === today.toDateString()) return 'today at ' + timeStr;
  if (d.toDateString() === yesterday.toDateString()) return 'yesterday at ' + timeStr;
  return '' + d.toLocaleDateString([], { day: 'numeric', month: 'short', year: 'numeric' }) + ' at ' + timeStr;
}


// Close background modal function
function closeBackgroundModal() {
  const backgroundModal = document.getElementById('backgroundModal');
  backgroundModal.classList.remove('open');
}

// Initialize uploaded images with remove buttons
function initializeUploadedImages() {
  const savedImagesGrid = document.getElementById('savedImagesGrid');
  
  // Clear existing uploaded images (keep default ones)
  const defaultImages = Array.from(savedImagesGrid.querySelectorAll('.image-option'))
    .filter(opt => !opt.hasAttribute('data-name'));
  
  savedImagesGrid.innerHTML = '';
  defaultImages.forEach(img => savedImagesGrid.appendChild(img));
  
  // Add uploaded images with remove buttons
  uploadedImages.forEach(imageData => {
    addImageToGrid(imageData.url, imageData.name);
  });
}

// Update the existing addImageToGrid function
// Update the addImageToGrid function to handle image clicks with options
// Update the addImageToGrid function to handle image clicks with options - FIXED VERSION
function addImageToGrid(imageUrl, imageName) {
  const savedImagesGrid = document.getElementById('savedImagesGrid');
  
  // Check if image already exists to prevent duplicates
  const existingImage = Array.from(savedImagesGrid.querySelectorAll('.image-option'))
    .find(opt => opt.getAttribute('data-image') === imageUrl);
  
  if (existingImage) {
    return; // Image already exists, don't add duplicate
  }
  
  const imageOption = document.createElement('div');
  imageOption.className = 'image-option';
  imageOption.setAttribute('data-image', imageUrl);
  imageOption.setAttribute('data-name', imageName);
  imageOption.style.backgroundImage = `url('${imageUrl}')`;
  imageOption.title = imageName;
  
  // Add click handler to show options instead of applying immediately
  imageOption.addEventListener('click', function(e) {
    e.stopPropagation();
    
    // Remove selection from all other options
    document.querySelectorAll('.color-option, .gradient-option, .image-option').forEach(opt => {
      opt.classList.remove('selected');
    });
    
    // Select this image
    this.classList.add('selected');
    
    // Store selection
    selectedBackground = this.getAttribute('data-image');
    selectedType = 'image';
    
    // Show action options
    showImageActions(this, imageUrl, imageName);
  });
  
  // Add remove button for uploaded images (not default ones)
  if (imageName && !imageName.startsWith('Default')) {
    addRemoveButtonToImage(imageOption, imageUrl, imageName);
  }
  
  savedImagesGrid.appendChild(imageOption);
}
// Function to add image from URL
function addImageFromUrl() {
  const urlInput = document.getElementById('imageUrlInput');
  const imageUrl = urlInput.value.trim();
  
  if (!imageUrl) {
    alert('Please enter an image URL');
    return;
  }
  
  // More permissive validation for testing
  if (!imageUrl.startsWith('http')) {
    alert('Please enter a valid URL starting with http or https');
    return;
  }
  
  // Check if image already exists
  if (isImageAlreadyExists(imageUrl)) {
    alert('This image is already in your collection');
    return;
  }
  
  // Create a test image to check if URL is valid
  const testImage = new Image();
  testImage.onload = function() {
    // Image loaded successfully
    const imageName = extractImageNameFromUrl(imageUrl) || `Image_${Date.now()}`;
    const imageData = {
      url: imageUrl,
      name: imageName,
      uploadedAt: Date.now(),
      type: 'url'
    };
    
    // Add to local storage
    uploadedImages.push(imageData);
    localStorage.setItem('uploadedBackgrounds', JSON.stringify(uploadedImages));
    
    // Add to grid
    addImageToGrid(imageData.url, imageData.name);
    
    // Clear input
    urlInput.value = '';
    
    alert('Image added successfully from URL!');
  };
  
  testImage.onerror = function() {
    alert('Unable to load image from this URL. Please check the link and try again.\n\nTip: Try using direct image links from Unsplash or Imgur.');
  };
  
  // Add timeout for image loading
  setTimeout(() => {
    if (!testImage.complete) {
      alert('Image is taking too long to load. It might be restricted. Try a different image URL.');
    }
  }, 5000);
  
  testImage.src = imageUrl;
}
// Function to validate image URL
function isValidImageUrl(url) {
  try {
    const urlObj = new URL(url);
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg'];
    const path = urlObj.pathname.toLowerCase();
    
    return imageExtensions.some(ext => path.endsWith(ext)) ||
      url.includes('unsplash.com') ||
      url.includes('picsum.photos') ||
      url.match(/\.(jpg|jpeg|png|gif|webp|bmp)(\?.*)?$/i);
  } catch (e) {
    return false;
  }
}

// Function to extract image name from URL
function extractImageNameFromUrl(url) {
  try {
    const urlObj = new URL(url);
    const pathname = urlObj.pathname;
    const filename = pathname.split('/').pop();
    return filename || `Image_${Date.now()}`;
  } catch (e) {
    return `Image_${Date.now()}`;
  }
}

// Function to check if image already exists in collection
function isImageAlreadyExists(url) {
  return uploadedImages.some(img => img.url === url);
}

// Function to handle Enter key in URL input
document.addEventListener('DOMContentLoaded', function() {
  const urlInput = document.getElementById('imageUrlInput');
  if (urlInput) {
    urlInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        addImageFromUrl();
      }
    });
  }
});
// Function to show action options when image is clicked
// Function to show action options when image is clicked - FIXED VERSION
// Update the showImageActions function to include home background option
function showImageActions(imageElement, imageUrl, imageName) {
  // Remove any existing action menu
  const existingMenu = document.querySelector('.image-actions-menu');
  if (existingMenu) {
    existingMenu.remove();
  }
  
  // Create action menu
  const actionMenu = document.createElement('div');
  actionMenu.className = 'image-actions-menu';
  actionMenu.innerHTML = `
    <div class="action-menu-content">
      <button class="image-action-btn" data-action="apply-dp">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 2C13.1 2 14 2.9 14 4C14 5.1 13.1 6 12 6C10.9 6 10 5.1 10 4C10 2.9 10.9 2 12 2ZM21 9V7L15 1H5C3.89 1 3 1.89 3 3V19C3 20.1 3.89 21 5 21H19C20.11 21 21 20.11 21 19V9ZM19 9H14V10H19V9ZM6 10H11V15H6V10ZM8 12V13H9V12H8Z"/>
        </svg>
        Apply as DP
      </button>
      <button class="image-action-btn" data-action="apply-background">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M21 19V5C21 3.9 20.1 3 19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19ZM8.5 13.5L11 16.51L14.5 12L19 18H5L8.5 13.5Z"/>
        </svg>
        Apply as Chat Background
      </button>
      <button class="image-action-btn" data-action="apply-home-background">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
        </svg>
        Apply as Home Background
      </button>
      <button class="image-action-btn" data-action="remove-photo">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
        </svg>
        Remove Photo
      </button>
    </div>
  `;
  
  // Get the modal content container
  const modalContent = document.querySelector('.color-modal-content');
  
  // Position the menu relative to the clicked image within the modal
  const rect = imageElement.getBoundingClientRect();
  const modalRect = modalContent.getBoundingClientRect();
  
  actionMenu.style.position = 'absolute';
  actionMenu.style.top = (rect.bottom - modalRect.top + 5) + 'px';
  actionMenu.style.left = (rect.left - modalRect.left) + 'px';
  actionMenu.style.zIndex = '1000';
  
  // Add to background modal content
  modalContent.appendChild(actionMenu);
  
  // Add event listeners to action buttons
  actionMenu.querySelectorAll('.image-action-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const action = btn.dataset.action;
      
      switch (action) {
        case 'apply-dp':
          applyAsDP(imageUrl);
          break;
        case 'apply-background':
          applyAsBackground(imageUrl);
          break;
        case 'apply-home-background':
          applyAsHomeBackground(imageUrl);
          break;
        case 'remove-photo':
          removePhoto(imageUrl, imageName, imageElement);
          break;
      }
      
      // Remove the menu after action
      actionMenu.remove();
    });
  });
  
  // Close menu when clicking outside
  const closeMenu = (e) => {
    if (!actionMenu.contains(e.target) && !imageElement.contains(e.target)) {
      actionMenu.remove();
      document.removeEventListener('click', closeMenu);
    }
  };
  
  setTimeout(() => {
    document.addEventListener('click', closeMenu);
  }, 100);
}

// Function to apply image as DP
// Function to apply image as DP - FIXED PERSISTENCE
function applyAsDP(imageUrl) {
  const userLogo = document.getElementById('userLogo');
  if (userLogo) {
    userLogo.src = imageUrl;
    // Save to localStorage with proper key
    localStorage.setItem('userProfilePicture', imageUrl);
    alert('Profile picture updated successfully!');
  }
}

function editProfileName() {
  const currentName = document.getElementById('profileNameDisplay').textContent;
  const currentChatName = document.getElementById('chatTitle').textContent;
  
  // Use the chat title if available, otherwise use profile name
  const currentDisplayName = currentChatName || currentName;
  
  const newName = prompt('Enter new name:', currentDisplayName);
  
  if (newName && newName.trim() !== '') {
    const trimmedName = newName.trim();
    
    // Update both profile display and chat header
    document.getElementById('profileNameDisplay').textContent = trimmedName;
    document.getElementById('chatTitle').textContent = trimmedName;
    
    // Save to localStorage for persistence
    localStorage.setItem('userDisplayName', trimmedName);
    
    // Optional: Show confirmation
    showNotification('Name updated successfully!');
  }
}
function loadSavedName() {
  const savedName = localStorage.getItem('userDisplayName');
  if (savedName) {
    document.getElementById('profileNameDisplay').textContent = savedName;
    document.getElementById('chatTitle').textContent = savedName;
  }
}
// Load saved DP on page load
function loadSavedDP() {
  const savedDP = localStorage.getItem('userProfilePicture');
  const userLogo = document.getElementById('userLogo');
  if (savedDP && userLogo) {
    userLogo.src = savedDP;
  }
}

// Call this on page load
document.addEventListener('DOMContentLoaded', function() {
  loadSavedDP();
  // ... rest of your initialization code
});
// Function to apply image as background
function applyAsBackground(imageUrl) {
  selectedBackground = imageUrl;
  selectedType = 'image';
  
  applyBackground(
    'image',
    selectedBackground,
    parseInt(blurSlider?.value || 0),
    parseInt(opacitySlider?.value || 50)
  );
  
  alert('Chat background updated successfully!');
}

// Function to remove photo (already exists, just making sure it's accessible)
function removePhoto(imageUrl, imageName, imageElement) {
  if (confirm(`Remove "${imageName}" from your saved collection?`)) {
    // Remove from uploadedImages array
    uploadedImages = uploadedImages.filter(img => img.url !== imageUrl);
    
    // Update localStorage
    localStorage.setItem('uploadedBackgrounds', JSON.stringify(uploadedImages));
    
    // Remove from DOM
    imageElement.remove();
    
    // If this was the currently selected background, reset selection
    if (selectedBackground === imageUrl && selectedType === 'image') {
      selectedBackground = null;
      selectedType = null;
    }
    
    console.log('Image removed from collection');
  }
}
function subscribeToPresenceFor(chatKey) {
  // remove previous listener
  if (statusListener && statusListener.ref) {
    try { statusListener.ref.off('value', statusListener.callback); } catch(e) {}
    statusListener = null;
  }

  const typingEl = document.getElementById('typingIndicator');
  const userLogo = document.getElementById('userLogo');
  if (!typingEl) return;

  const statusRef = db.ref('status/' + chatKey);
  const callback = snap => {
    const statusObj = snap.val();
    let typing = false;
    let state = 'offline';
    let last_changed = null;

    if (statusObj) {
      if (typeof statusObj === 'object') {
        typing = !!statusObj.typing;
        state = statusObj.state || state;
        last_changed = statusObj.last_changed || null;
      } else if (typeof statusObj === 'string') {
        state = statusObj;
      }
    }

    // Show in same div
    // Show in same div
if (typing) {
  typingEl.style.display = 'block';
  typingEl.textContent = 'typing…';
  updateProfilePictureBorder(true); // Typing implies online
} else {
  // not typing: online or last seen
  typingEl.style.display = 'block';
  if (state === 'online') {
    typingEl.textContent = 'online';
    updateProfilePictureBorder(true);
  } else {
    typingEl.textContent = formatLastSeen(last_changed);
    updateProfilePictureBorder(false);
  }
}
  };

  statusListener = { ref: statusRef, callback };
  statusRef.on('value', callback);
}

// Ensure we subscribe when opening a chat
const oldOpenChat_forPresence = openChat;
openChat = function(key) {
  oldOpenChat_forPresence(key);
  // key in your app is the DB key (looks like you already use underscores)
  subscribeToPresenceFor(key);
};

// Optional: cleanup listener when going back to inbox
const oldPop = window.onpopstate;
// Simple fix - replace your current popstate listener with this:
window.addEventListener('popstate', function(event) {
  if (chatEl.classList.contains('active')) {
    chatEl.classList.remove('active');
    listEl.classList.add('active');
    currentKey = null;
    
    // Clean up any active listeners
    if (childListener) {
      db.ref('chats/' + currentKey).off('value', childListener);
      childListener = null;
    }
  }
});

// And ensure your goBackToList function calls history.back():
function goBackToList() {
  history.back();
}

/* ===== improved presence helper =====
   Replace your current setPresence(...) function with this.
*/




let _presenceHeartbeat = null;


function adjustMessagesPadding(){
  const input = document.getElementById('inputArea');
  const messages = document.getElementById('messages');
  if(!input || !messages) return;
  // add extra spacing for safe area
  const extra = 16;
  messages.style.paddingBottom = (input.offsetHeight + extra) + 'px';
}

// run on load and whenever window resizes or input changes
window.addEventListener('load', adjustMessagesPadding);
window.addEventListener('resize', adjustMessagesPadding);

// if your textarea auto-resizes, call adjustMessagesPadding on input
const txt = document.getElementById('replyInput');
if(txt){
  txt.addEventListener('input', function(){ 
    // if you have an auto-height script, run it first then adjust
    setTimeout(adjustMessagesPadding, 60);
  });
}


function linkify(text) {
  if (!text) return '';
  
  // Regular expression to match URLs
  const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
  
  // Replace URLs with anchor tags
  return text.replace(urlRegex, function(url) {
    // Shorten display text for long URLs (like WhatsApp does)
    const displayUrl = url.length > 30 ? url.substring(0, 27) + '...' : url;
    return '<a href="' + url + '" target="_blank" rel="noopener noreferrer" class="message-link">' + displayUrl + '</a>';
  });
}


function setPresence(userKey) {
  if (!userKey) return;
  const userStatusRef = db.ref('status/' + userKey);

  const makeOffline = () => ({
    state: 'offline',
    last_changed: Date.now(),
  });
  const makeOnline = () => ({
    state: 'online',
    last_changed: Date.now(),
  });

  // Clear any previous heartbeat
  if (_presenceHeartbeat) {
    clearInterval(_presenceHeartbeat);
    _presenceHeartbeat = null;
  }

  // Listen for connection status to RTDB servers
  db.ref('.info/connected').on('value', (snap) => {
    if (snap.val() === true) {
      // Ensure server will set offline when this client truly disconnects
      userStatusRef.onDisconnect().set(makeOffline()).catch(()=>{});

      // Immediately mark online
      userStatusRef.set(makeOnline()).catch(()=>{});

      // Start heartbeat to continually update last_changed so server
      // will not mark connection idle. 10s is a good compromise.
      if (!_presenceHeartbeat) {
        _presenceHeartbeat = setInterval(() => {
          userStatusRef.update({ last_changed: Date.now(), state: 'online' }).catch(()=>{});
        }, 5000);
      }
    } else {
      // not connected -> clear heartbeat
      if (_presenceHeartbeat) {
        clearInterval(_presenceHeartbeat);
        _presenceHeartbeat = null;
      }
    }
  });

  // Best-effort attempt to mark offline on page unload using beacon
  window.addEventListener('unload', () => {
    try {
      // Try to use onDisconnect as main line; sendBeacon is fallback
      const payload = JSON.stringify(makeOffline());
      // Using REST endpoint would be ideal, but as a fallback use sendBeacon to a small cloud function
      // Here we attempt a tiny write via navigator.sendBeacon to a special endpoint if you have one.
      // Fallback: attempt a synchronous set (sometimes fails)
      userStatusRef.set(makeOffline());
    } catch (e) {
      // ignore
    }
  });
}

// Call it like this:
setPresence("brother");




let typingTimeout;

replyInput.addEventListener("input", () => {
  // Mark brother as typing
  db.ref("status/brother/typing").set(true);
  
  // Reset after 2 seconds of no input
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    db.ref("status/brother/typing").set(false);
  }, 900);
});
const searchBox = document.getElementById('searchBox');
const replyPreviewContainer = document.getElementById('replyPreviewContainer');

// Instead of listening to your own typing status:
const typingIndicator = document.getElementById('typingIndicator');

// use a single place to derive the DB key from the email
const currentUserEmail = "mahekj05@gmail.com";
const currentUserKey = currentUserEmail.replace(/\./g, '_');

// listen for typing under the same key used elsewhere
db.ref('status/' + currentUserKey + '/typing').on('value', (snapshot) => {
  const isTyping = snapshot.val();
  typingIndicator.style.display = isTyping ? 'block' : 'none';
});

let currentKey = null;
let childListener = null;
let allChats = [];
let replyToText = null;
let searchTimeout;

// Fix for system back button functionality
let isInChatView = false;
// --- Infinite scroll variables ---
let isLoadingOlderMessages = false;
let hasMoreMessages = true;
let oldestLoadedTimestamp = null;

// --- Infinite scroll ---
let oldestLoadedKey = null;
let isLoadingOlder = false;
let reachedBeginning = false;

// --- Store messages ---
let messageStore = {};
let lastRenderedDate = null; 
let lastRenderedMsgTime = 0;
let initialLoadDone = false;
// global tracker// *** FIX: Track last date divider ***

// --- Cache helpers ---





function getCachedMessages(chatKey) { const c = localStorage.getItem('chat_' + chatKey); return c ? JSON.parse(c) : null; }

// --- Load cached chats ---
// --- Load cached chat list (optimized) ---
function getCachedChatList() {
  const c = localStorage.getItem('cachedChatList');
  return c ? JSON.parse(c) : null;
}

function cacheChatList(chatListData) {
  localStorage.setItem('cachedChatList', JSON.stringify(chatListData));
}

// Optimized: Only cache last message for each chat
function renderChatsOptimized(chatListData) {
  chatList.innerHTML = '';
  allChats = [];
  
  const sortedKeys = Object.keys(chatListData).sort((a, b) =>
    chatListData[b].lastTimestamp - chatListData[a].lastTimestamp
  );
  
  sortedKeys.forEach(chatKey => {
    const { lastMessage, lastTimestamp } = chatListData[chatKey];
    const lastTime = new Date(lastTimestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
    
    const item = document.createElement('div');
    item.className = 'chat-item';
    item.onclick = () => openChat(chatKey);
    
    const name = document.createElement('div');
    name.className = 'chat-name';
    name.textContent = chatKey.replace(/_/g, '.');
    
    const preview = document.createElement('div');
    preview.className = 'chat-preview';
    preview.textContent = lastMessage.text || '[Media]';
    
    const time = document.createElement('div');
    time.className = 'chat-time';
    time.textContent = lastTime;
    
    item.appendChild(name);
    item.appendChild(preview);
    item.appendChild(time);
    chatList.appendChild(item);
    
    allChats.push({ key: chatKey, element: item, preview: lastMessage.text });
  });
}

// Load optimized chat list
const cachedChatList = getCachedChatList();
if (cachedChatList) renderChatsOptimized(cachedChatList);

// Only cache last messages for chat list, not all messages
db.ref('chats').on('value', snapshot => {
  const chats = snapshot.val();
  if (!chats) return;
  
  const chatListData = {};
  
  Object.keys(chats).forEach(chatKey => {
    const messages = chats[chatKey];
    const messageKeys = Object.keys(messages).map(Number);
    
    if (messageKeys.length > 0) {
      const lastKey = Math.max(...messageKeys);
      chatListData[chatKey] = {
        lastMessage: messages[lastKey],
        lastTimestamp: lastKey
      };
    }
  });
  
  cacheChatList(chatListData);
  renderChatsOptimized(chatListData);
});

// use the correct brotherKey
function renderChats(chats) {
  chatList.innerHTML = '';
  allChats = [];
  const sortedKeys = Object.keys(chats).sort((a,b)=>{
    const lastA = Math.max(...Object.keys(chats[a]).map(Number));
    const lastB = Math.max(...Object.keys(chats[b]).map(Number));
    return lastB - lastA;
  });
  sortedKeys.forEach(key=>{
    const messages = chats[key];
    const timestamps = Object.keys(messages).map(Number).sort((a,b)=>a-b);
    const lastMsg = messages[timestamps[timestamps.length-1]];
    const lastTime = new Date(timestamps[timestamps.length-1]).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', hour12:true});
    
    
    const item = document.createElement('div');
    item.className = 'chat-item';
    item.onclick = ()=>openChat(key);
    const name = document.createElement('div'); name.className = 'chat-name'; name.textContent = key.replace(/_/g,'.');
    const preview = document.createElement('div'); preview.className = 'chat-preview'; preview.textContent = lastMsg.text;
    
    const event = new CustomEvent('chatOpened', { detail: key });
window.dispatchEvent(event);
    
    const time = document.createElement('div'); time.className = 'chat-time'; time.textContent = lastTime;
    item.appendChild(name); item.appendChild(preview); item.appendChild(time);
    chatList.appendChild(item);
    allChats.push({ key, element:item, preview:lastMsg.text });
  });
}

// --- Search ---
function filterChats() {
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(() => {
    const term = searchBox.value.toLowerCase();
    allChats.forEach(chat => {
      chat.element.style.display =
        chat.key.toLowerCase().includes(term) || chat.preview.toLowerCase().includes(term) ? '' : 'none';
    });
  }, 200);
}



// --- Date dividers ---
function formatDateSeparator(ts){
  const msgDate = new Date(Number(ts));
  const today = new Date();
  const yesterday = new Date(); yesterday.setDate(today.getDate()-1);
  if(msgDate.toDateString()===today.toDateString()) return "Today";
  else if(msgDate.toDateString()===yesterday.toDateString()) return "Yesterday";
  else return msgDate.toLocaleDateString([], { day:"numeric", month:"short", year:"numeric" });
}

function createDateDivider(label){
  const div = document.createElement("div");
  div.className = "date-divider";
  div.textContent = label;
  return div;
}
// ===== MESSAGE SELECTION FUNCTIONALITY =====
let selectedMessages = new Set();
let isSelectionMode = false;
let longPressTimer = null;
let currentLongPressTarget = null;

// Initialize selection functionality
function initializeMessageSelection() {
  const messagesEl = document.getElementById('messages');
  
  // Add event listeners to messages container
  messagesEl.addEventListener('touchstart', handleTouchStart, { passive: true });
  messagesEl.addEventListener('touchend', handleTouchEnd);
  messagesEl.addEventListener('touchmove', handleTouchMove);
  
  // Toolbar event listeners
  document.getElementById('deleteSelected').addEventListener('click', deleteSelectedMessages);
  document.getElementById('copySelected').addEventListener('click', copySelectedMessages);
  document.getElementById('closeSelection').addEventListener('click', clearSelection);
}

// Touch event handlers - COMPLETELY BYPASS IMAGES
function handleTouchStart(e) {
  // Don't start swipe if clicking on a link, reply box, or image
  if (e.target.closest('.message-link') || e.target.closest('.reply-box') || e.target.tagName === 'IMG') {
    return;
  }
  
  const bubble = e.target.closest('.bubble');
  if (!bubble) return;
  
  currentLongPressTarget = bubble;
  longPressTimer = setTimeout(() => {
    // Enter selection mode on long press
    if (!isSelectionMode) {
      isSelectionMode = true;
      toggleMessageSelection(bubble);
    }
    longPressTimer = null;
    currentLongPressTarget = null;
  }, 500);
}

function handleTouchEnd(e) {
  if (longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
    
    // If we're in selection mode and this was a quick tap, select the message
    // But allow image clicks to proceed normally
    if (isSelectionMode && currentLongPressTarget &&
      !e.target.closest('.message-link') &&
      !e.target.closest('.reply-box') &&
      e.target.tagName !== 'IMG') {
      toggleMessageSelection(currentLongPressTarget);
    }
  }
  currentLongPressTarget = null;
}

function handleTouchMove(e) {
  if (longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
    currentLongPressTarget = null;
  }
}

// Toggle message selection
function toggleMessageSelection(bubble) {
  const msgKey = bubble.getAttribute('data-msg-key');
  
  if (selectedMessages.has(msgKey)) {
    selectedMessages.delete(msgKey);
    bubble.classList.remove('selected');
  } else {
    selectedMessages.add(msgKey);
    bubble.classList.add('selected');
  }
  
  updateSelectionToolbar();
}

// Update selection toolbar
function updateSelectionToolbar() {
  const toolbar = document.getElementById('selectionToolbar');
  const selectedCount = document.getElementById('selectedCount');
  
  if (selectedMessages.size > 0) {
    toolbar.style.display = 'flex';
    selectedCount.textContent = `${selectedMessages.size} selected`;
    
    // Adjust messages padding for toolbar
    document.getElementById('messages').classList.add('with-selection-toolbar');
  } else {
    // If no messages selected, exit selection mode
    isSelectionMode = false;
    toolbar.style.display = 'none';
    document.getElementById('messages').classList.remove('with-selection-toolbar');
  }
}

// Clear selection
function clearSelection() {
  selectedMessages.clear();
  isSelectionMode = false;
  
  // Remove selection from all messages
  document.querySelectorAll('.bubble.selected').forEach(bubble => {
    bubble.classList.remove('selected');
  });
  
  // Hide toolbar
  document.getElementById('selectionToolbar').style.display = 'none';
  
  // Reset messages padding
  document.getElementById('messages').classList.remove('with-selection-toolbar');
}

// Delete selected messages
function deleteSelectedMessages() {
  if (selectedMessages.size === 0 || !currentKey) return;
  
  if (confirm(`Delete ${selectedMessages.size} message(s)?`)) {
    selectedMessages.forEach(msgKey => {
      db.ref('chats/' + currentKey + '/' + msgKey).remove()
        .then(() => console.log('Deleted:', msgKey))
        .catch(err => console.error('Failed to delete:', err));
    });
    
    clearSelection();
  }
}

// Copy selected messages
function copySelectedMessages() {
  if (selectedMessages.size === 0) return;
  
  let textToCopy = '';
  selectedMessages.forEach(msgKey => {
    const message = messageStore[msgKey];
    if (message && message.text) {
      textToCopy += message.text + '\n\n';
    }
  });
  
  if (textToCopy) {
    navigator.clipboard.writeText(textToCopy.trim())
      .then(() => {
        alert('Messages copied to clipboard!');
        clearSelection();
      })
      .catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy messages');
      });
  } else {
    alert('No text messages to copy');
  }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', initializeMessageSelection);

// Also re-initialize when opening a new chat
const originalOpenChat = openChat;
openChat = function(key) {
  originalOpenChat(key);
  // Clear any existing selection when switching chats
  clearSelection();
};
// Close background modal when close button is clicked
document.addEventListener('DOMContentLoaded', function() {
  const closeBtn = document.getElementById('closeBackgroundModal');
  if (closeBtn) {
    closeBtn.addEventListener('click', closeBackgroundModal);
  }
  
  // Also close when clicking outside the modal content
  const backgroundModal = document.getElementById('backgroundModal');
  if (backgroundModal) {
    backgroundModal.addEventListener('click', function(e) {
      if (e.target === backgroundModal) {
        closeBackgroundModal();
      }
    });
  }
  
  // Close with Escape key
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && backgroundModal.classList.contains('open')) {
      closeBackgroundModal();
    }
  });
});



function highlightAndScrollTo(msgKey) {
  if (!msgKey) return;
  // prefer id format first
  const id = 'msg_' + msgKey;
  let target = document.getElementById(id);
  if (!target) {
    // fallback to data attribute
    target = document.querySelector('[data-msg-key="' + msgKey + '"]');
  }
  if (!target) {
    // If message not rendered yet, try small retry (best-effort)
    let tries = 0;
    const retry = setInterval(() => {
      tries++;
      let t = document.getElementById(id) || document.querySelector('[data-msg-key="' + msgKey + '"]');
      if (t) {
        clearInterval(retry);
        t.scrollIntoView({ behavior: 'smooth', block: 'center' });
        t.classList.add('message-highlight');
        setTimeout(() => t.classList.remove('message-highlight'), 2200);
      } else if (tries > 8) {
        clearInterval(retry);
        console.warn('Referenced message not found in DOM:', msgKey);
      }
    }, 150);
    return;
  }
  
  // scroll and highlight
  try {
    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
  } catch (e) {
    target.scrollIntoView();
  }
  target.classList.add('message-highlight');
  // remove highlight after a short while
  setTimeout(() => {
    target && target.classList.remove('message-highlight');
  }, 2200);
}

window.buildMessageBubble = function(msgKey, val) {
  const div = document.createElement('div');
  div.className = 'bubble ' + (val.from === 'user' ? 'from-user' : 'from-brother');
  div.setAttribute('data-msg-key', String(msgKey));
  div.id = 'msg_' + String(msgKey);
  
  // Selection checkbox
  const checkbox = document.createElement('div');
  checkbox.className = 'selection-checkbox';
  div.appendChild(checkbox);
  
  // Selection overlay
  const overlay = document.createElement('div');
  overlay.className = 'selection-overlay';
  div.appendChild(overlay);
  
  // Reply arrow
  const arrow = document.createElement('div');
  arrow.className = 'reply-arrow';
  arrow.innerHTML = '↩';
  div.appendChild(arrow);
  
  // Attach swipe handlers for reply
  attachSwipeHandlers(div, msgKey, val.text || '');
  
  // Reply preview
  if (val.replyTo && messageStore[val.replyTo]) {
    const replyDiv = document.createElement('div');
    replyDiv.className = 'reply-box';
    const referenced = messageStore[val.replyTo];
    if (referenced && referenced.text) {
      const truncatedText = referenced.text.length > 120 ?
        referenced.text.slice(0, 120) + '…' : referenced.text;
      replyDiv.innerHTML = linkify(truncatedText);
    } else {
      replyDiv.textContent = '[media]';
    }
    
    replyDiv.addEventListener('click', (e) => {
      e.stopPropagation();
      e.stopImmediatePropagation();
      highlightAndScrollTo(val.replyTo);
    });
    
    div.prepend(replyDiv);
  }
  
  // Media (image/gif)
  if (val.type === 'gif' || val.type === 'image') {
    const media = document.createElement('img');
    media.style.maxWidth = '100%';
    media.style.maxHeight = '260px';
    media.style.borderRadius = '8px';
    media.style.display = 'block';
    media.style.marginBottom = '6px';
    media.src = val.url;
    media.alt = val.type;
    div.appendChild(media);
    
    // Menu button
    const menuBtn = document.createElement('button');
    menuBtn.innerHTML = '⋮';
    menuBtn.className = 'menu-btn';
    menuBtn.style.position = 'absolute';
    menuBtn.style.top = '6px';
    menuBtn.style.right = '6px';
    menuBtn.style.background = 'transparent';
    menuBtn.style.border = 'none';
    menuBtn.style.fontSize = '18px';
    menuBtn.style.cursor = 'pointer';
    
    const menu = createDeleteMenu(msgKey);
    div.appendChild(menu);
    
    menuBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      menu.style.display = (menu.style.display === 'none') ? 'block' : 'none';
    });
    
    document.addEventListener('click', () => { menu.style.display = 'none'; });
    div.appendChild(menuBtn);
    
    if (val.text) {
      const textNode = document.createElement('div');
      textNode.innerHTML = linkify(val.text);
      div.appendChild(textNode);
    }
  } else {
    // Text message
    const textNode = document.createElement('div');
    textNode.innerHTML = linkify(val.text || '');
    div.appendChild(textNode);
    
    // Remove long press delete handlers since we're using selection now
    // (Keep only the selection functionality)
  }
  
  // Timestamp
  const timeNode = document.createElement('div');
  timeNode.className = 'msg-time';
  timeNode.textContent = new Date(Number(msgKey)).toLocaleTimeString([], {
    hour: '2-digit',
    minute: '2-digit',
    hour12: true
  });
  div.appendChild(timeNode);
  
  return div;
};

// ensure the local name points to the same function used in renderMessages
buildMessageBubble = window.buildMessageBubble;

// --- Render messages (fixed) ---




// Replace your entire openChat function with this optimized version
function openChat(key) {
  listEl.classList.remove('active');
  chatEl.classList.add('active');
  
  // Reset state
  currentKey = key;
  
  history.pushState({ screen: "chat" }, "Chat");
  
  messageStore = {};
  lastRenderedDate = null;
  lastRenderedMsgTime = 0;
  messagesEl.innerHTML = '';
  initialLoadDone = false;
  clearSelection();
  
// Reset WhatsApp-like behavior state when opening a new chat
hideNewMessageNotification();
removeNewMessagesDivider();
clearMessageHighlights(); // ADD THIS LINE
unreadMessages = [];
newMessagesCount = 0;
isUserScrolling = false;
  // Reset infinite scroll variables
  isLoadingOlderMessages = false;
  hasMoreMessages = true;
  oldestLoadedTimestamp = null;
  
  // Show loading indicator
  messagesEl.innerHTML = '<div class="loading-indicator">Loading messages...</div>';
  
  // Load cached messages first for immediate display
  const cachedMsgs = getCachedMessages(key);
  if (cachedMsgs) {
    processAndRenderMessages(cachedMsgs);
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
  
  // Set up real-time listener with optimized query
  if (childListener) {
    db.ref('chats/' + currentKey).off('value', childListener);
  }
  
  childListener = db.ref('chats/' + currentKey)
    .orderByKey()
    .limitToLast(100) // Only get the most recent 100 messages initially
    .on('value', snap => {
      const msgs = snap.val();
      if (msgs) {
        cacheMessages(currentKey, msgs);
        processAndRenderMessages(msgs);
        
        // Remove loading indicator if it exists
        const loadingIndicator = messagesEl.querySelector('.loading-indicator');
        if (loadingIndicator) {
          messagesEl.removeChild(loadingIndicator);
        }
      }
    });
  
  // Add scroll event listener for infinite scroll
  messagesEl.addEventListener('scroll', handleScroll);
  
  // Subscribe to presence for this chat
  subscribeToPresenceFor(key);
}

// Handle image upload and storage
let uploadedImages = JSON.parse(localStorage.getItem('uploadedBackgrounds') || '[]');

// Initialize uploaded images on load
function initializeUploadedImages() {
  const savedImagesGrid = document.getElementById('savedImagesGrid');
  
  // Add uploaded images to the grid
  uploadedImages.forEach(imageData => {
    addImageToGrid(imageData.url, imageData.name);
  });
}
// Add this CSS for the remove button
const removeButtonStyle = `
.remove-image-btn {
    position: absolute;
    top: 4px;
    right: 4px;
    width: 20px;
    height: 20px;
    background: #ff4444;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
    opacity: 0.9;
}

.remove-image-btn:hover {
    background: #cc0000;
    opacity: 1;
    transform: scale(1.1);
}

.image-option {
    position: relative;
}

/* Hide remove button when image is selected */
.image-option.selected .remove-image-btn {
    display: none;
}
`;

// Inject the styles
const style = document.createElement('style');
style.textContent = removeButtonStyle;
document.head.appendChild(style);

// Function to add remove button to uploaded images
function addRemoveButtonToImage(imageOption, imageUrl, imageName) {
  const removeBtn = document.createElement('button');
  removeBtn.className = 'remove-image-btn';
  removeBtn.innerHTML = '×';
  removeBtn.title = 'Remove image';
  
  removeBtn.addEventListener('click', (e) => {
    e.stopPropagation(); // Prevent triggering image selection
    removeUploadedImage(imageUrl, imageName, imageOption);
  });
  
  imageOption.appendChild(removeBtn);
}

// Function to remove uploaded image
function removeUploadedImage(imageUrl, imageName, imageElement) {
  if (confirm(`Remove "${imageName}" from your saved collection?`)) {
    // Remove from uploadedImages array
    uploadedImages = uploadedImages.filter(img => img.url !== imageUrl);
    
    // Update localStorage
    localStorage.setItem('uploadedBackgrounds', JSON.stringify(uploadedImages));
    
    // Remove from DOM
    imageElement.remove();
    
    // If this was the currently selected background, reset selection
    if (selectedBackground === imageUrl && selectedType === 'image') {
      selectedBackground = null;
      selectedType = null;
    }
    
    console.log('Image removed from collection');
  }
}

// Update your existing addImageToGrid function
function addImageToGrid(imageUrl, imageName) {
  const savedImagesGrid = document.getElementById('savedImagesGrid');
  
  const imageOption = document.createElement('div');
  imageOption.className = 'image-option';
  imageOption.setAttribute('data-image', imageUrl);
  imageOption.setAttribute('data-name', imageName);
  imageOption.style.backgroundImage = `url('${imageUrl}')`;
  imageOption.title = imageName;
  
  // Add click handler for SELECTION only (not application)
  imageOption.addEventListener('click', function() {
    // Deselect all other options
    document.querySelectorAll('.color-option, .gradient-option, .image-option').forEach(opt => {
      opt.classList.remove('selected');
    });
    
    // Select this image
    this.classList.add('selected');
    
    // Store selection but don't apply yet
    selectedBackground = this.getAttribute('data-image');
    selectedType = 'image';
    
    console.log('Image selected (not applied):', selectedBackground);
  });
  
  // Add remove button for uploaded images (not default ones)
  if (imageName) {
    addRemoveButtonToImage(imageOption, imageUrl, imageName);
  }
  
  savedImagesGrid.appendChild(imageOption);
}

// Update the apply background button to use the selection
document.addEventListener('DOMContentLoaded', function() {
  const applyBackgroundBtn = document.getElementById('applyBackgroundBtn');
  
  if (applyBackgroundBtn) {
    // Remove any existing event listeners and add new one
    applyBackgroundBtn.replaceWith(applyBackgroundBtn.cloneNode(true));
    const newApplyBtn = document.getElementById('applyBackgroundBtn');
    
    newApplyBtn.addEventListener('click', function() {
      console.log('Apply Background button clicked');
      
      if (selectedBackground && selectedType) {
        console.log('Applying background:', selectedType, selectedBackground);
        applyBackground(
          selectedType,
          selectedBackground,
          parseInt(blurSlider?.value || 0),
          parseInt(opacitySlider?.value || 50)
        );
        closeBackgroundPicker();
      } else {
        console.log('No background selected');
        alert('Please select a background first');
      }
    });
  }
  
  // Initialize remove buttons for existing uploaded images
  const savedImagesGrid = document.getElementById('savedImagesGrid');
  const uploadedImageOptions = savedImagesGrid.querySelectorAll('.image-option[data-name]');
  
  uploadedImageOptions.forEach(option => {
    const imageUrl = option.getAttribute('data-image');
    const imageName = option.getAttribute('data-name');
    addRemoveButtonToImage(option, imageUrl, imageName);
  });
});

// Also update the color and gradient selection to work the same way
document.querySelectorAll('.color-option').forEach(option => {
  option.addEventListener('click', () => {
    document.querySelectorAll('.color-option, .gradient-option, .image-option').forEach(o => o.classList.remove('selected'));
    option.classList.add('selected');
    selectedBackground = option.dataset.color;
    selectedType = 'color';
    console.log('Color selected (not applied):', selectedBackground);
  });
});

document.querySelectorAll('.gradient-option').forEach(option => {
  option.addEventListener('click', () => {
    document.querySelectorAll('.color-option, .gradient-option, .image-option').forEach(o => o.classList.remove('selected'));
    option.classList.add('selected');
    selectedBackground = option.dataset.gradient;
    selectedType = 'gradient';
    console.log('Gradient selected (not applied):', selectedBackground);
  });
});
// Add uploaded image to the grid


// Handle file upload
document.getElementById('bgImageUpload').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  if (!file.type.startsWith('image/')) {
    alert('Please select an image file');
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function(event) {
    const imageData = {
      url: event.target.result,
      name: file.name,
      uploadedAt: Date.now()
    };
    
    // Add to local storage
    uploadedImages.push(imageData);
    localStorage.setItem('uploadedBackgrounds', JSON.stringify(uploadedImages));
    
    // Add to grid
    addImageToGrid(imageData.url, imageData.name);
    
    // Select the newly uploaded image
    selectedBackground = imageData.url;
    selectedType = 'image';
    
    // Apply the background immediately
    applyBackground(
      'image',
      selectedBackground,
      parseInt(blurSlider.value),
      parseInt(opacitySlider.value)
    );
    
    alert('Image uploaded and applied successfully!');
  };
  
  reader.readAsDataURL(file);
  this.value = ''; // Reset file input
});

// Initialize on page load
// Initialize on page load - FIXED VERSION (no duplicates)
// Initialize on page load - FIXED VERSION
document.addEventListener('DOMContentLoaded', function() {
  initializeUploadedImages();
  loadSavedDP();
  loadSavedBackground();
  
  // Initialize ALL images (both default and uploaded) with click handlers
  function initializeAllImages() {
    const allImages = document.querySelectorAll('.image-option');
    allImages.forEach(imageOption => {
      const imageUrl = imageOption.getAttribute('data-image');
      const imageName = imageOption.getAttribute('data-name') || 'Default Image';
      
      // Remove any existing click listeners to prevent duplicates
      const newImageOption = imageOption.cloneNode(true);
      imageOption.parentNode.replaceChild(newImageOption, imageOption);
      
      // Add click handler to the new element
      newImageOption.addEventListener('click', function(e) {
        e.stopPropagation();
        
        // Remove selection from all other options
        document.querySelectorAll('.color-option, .gradient-option, .image-option').forEach(opt => {
          opt.classList.remove('selected');
        });
        
        // Select this image
        this.classList.add('selected');
        
        // Store selection
        selectedBackground = this.getAttribute('data-image');
        selectedType = 'image';
        
        // Show action options for ALL images
        showImageActions(this, imageUrl, imageName);
      });
    });
  }
  
  // Initialize images after a short delay to ensure DOM is ready
  setTimeout(initializeAllImages, 100);
  
  // Re-initialize when background modal opens (for newly uploaded images)
  const backgroundModal = document.getElementById('backgroundModal');
  if (backgroundModal) {
    backgroundModal.addEventListener('click', function(e) {
      if (e.target === backgroundModal || e.target.classList.contains('background-close-btn')) {
        // Re-initialize images when modal closes/opens to catch new uploads
        setTimeout(initializeAllImages, 300);
      }
    });
  }
});
// Replace your renderMessages function with this optimized version
// Function to apply image as home page background
// Function to apply image as home page background - FIXED VERSION
// Function to apply image as home page background - WORKING VERSION
function applyAsHomeBackground(imageUrl) {
  console.log('Applying home background:', imageUrl);
  
  // Save the home background setting
  const homeBackgroundSettings = {
    type: 'image',
    value: imageUrl,
    appliedAt: Date.now()
  };
  
  localStorage.setItem('homeBackground', JSON.stringify(homeBackgroundSettings));
  applyHomeBackground(imageUrl);
  
  // Close the action menu
  const actionMenu = document.querySelector('.image-actions-menu');
  if (actionMenu) {
    actionMenu.remove();
  }
  
  alert('Home page background updated successfully!');
}

// Apply home background to the UI - WORKING VERSION
function applyHomeBackground(imageUrl) {
  console.log('applyHomeBackground called with:', imageUrl);
  
  const listEl = document.getElementById('list');
  if (!listEl) {
    console.error('List element not found!');
    return;
  }
  
  // Remove any existing home background styles
  const existingStyle = document.getElementById('home-background-style');
  if (existingStyle) {
    existingStyle.remove();
  }
  
  // Create new style for home background with maximum specificity
  const style = document.createElement('style');
  style.id = 'home-background-style';
  
  // Use very specific CSS selectors with !important
  style.textContent = `
    /* Target the list div directly */
    #list {
      background-image: url("${imageUrl}") !important;
      background-size: cover !important;
      background-position: center !important;
      background-repeat: no-repeat !important;
      background-attachment: fixed !important;
    }
    
    /* Override any inline styles or other CSS */
    body #list {
      background-image: url("${imageUrl}") !important;
      background-size: cover !important;
      background-position: center !important;
      background-repeat: no-repeat !important;
      background-attachment: fixed !important;
    }
    
    /* Make sure it works in both light and dark modes */
    body:not(.dark) #list,
    body.dark #list {
      background-image: url("${imageUrl}") !important;
      background-size: cover !important;
      background-position: center !important;
      background-repeat: no-repeat !important;
      background-attachment: fixed !important;
    }
    

  `;
  
  document.head.appendChild(style);
  
  // Force immediate application by adding a class and triggering reflow
  listEl.classList.add('home-background-applied');
  
  // Force browser to repaint
  void listEl.offsetWidth;
  
  console.log('Home background style applied successfully');
}

// Apply home background to the UI


// Load saved home background on page load
// Load saved home background on page load - UPDATED
function loadSavedHomeBackground() {
  const savedHomeBg = JSON.parse(localStorage.getItem('homeBackground') || '{}');
  if (savedHomeBg.value) {
    console.log('Loading saved home background:', savedHomeBg.value);
    // Use setTimeout to ensure DOM is fully loaded
    setTimeout(() => {
      applyHomeBackground(savedHomeBg.value);
    }, 100);
  } else {
    console.log('No saved home background found');
  }
}

// Update the DOMContentLoaded to load home background
document.addEventListener('DOMContentLoaded', function() {
  loadSavedDP();
  loadSavedBackground();
  loadSavedHomeBackground();
  loadSavedName();
  // ... rest of initialization
});
// --- Render messages (fixed) ---
function processAndRenderMessages(messages) {
  if (!messages) return;
  
  const wasNearBottom = isNearBottom();
  const messagesEl = document.getElementById('messages');
  
  // Convert to array and sort by timestamp
  const messageArray = Object.entries(messages)
    .map(([key, value]) => ({ key: Number(key), value }))
    .sort((a, b) => a.key - b.key);
  
  const fragment = document.createDocumentFragment();
  let addedNewMessages = false;
  let newMessageCount = 0;
  
  messageArray.forEach(({ key, value }) => {
    const msgKey = String(key);
    const val = value;
    
    if (!val || (!val.text && !val.type && !val.url)) return;
    
    // Check if this message is already rendered
    const existingMsg = document.getElementById('msg_' + msgKey) ||
      document.querySelector('[data-msg-key="' + msgKey + '"]');
    if (existingMsg) return;
    
    // Add to messageStore
    messageStore[msgKey] = val;
    
    const msgDate = new Date(key);
    const dateLabel = formatDateSeparator(msgKey);
    
    // Date divider
    if (lastRenderedDate !== msgDate.toDateString()) {
      fragment.appendChild(createDateDivider(dateLabel));
      lastRenderedDate = msgDate.toDateString();
    }
    
    const div = buildMessageBubble(msgKey, val);
    
// Mark as new message if it's from user and we're not at bottom
if (val.from === "user" && !wasNearBottom && initialLoadDone) {
  div.classList.add('new-message');
  newMessageCount++;
  
  // Track unread messages for proper highlighting
  if (!unreadMessages.includes(msgKey)) {
    unreadMessages.push(msgKey);
  }
  
  // Show notification and divider for new messages
  if (initialLoadDone) {
    showNewMessageNotification(1);
  }
}
    
    fragment.appendChild(div);
    addedNewMessages = true;
    
    // Play sound only for new incoming messages
    if (initialLoadDone && val.from === "user" && key > lastRenderedMsgTime) {
      const snd = document.getElementById("receiveSound");
      if (snd) snd.play().catch(() => {});
    }
    
    // Update last seen
    if (key > lastRenderedMsgTime) {
      lastRenderedMsgTime = key;
    }
  });
  
  if (addedNewMessages) {
    messagesEl.appendChild(fragment);
    
    // WhatsApp-like behavior
    if (!isUserScrolling && wasNearBottom) {
      // Auto-scroll if user is at bottom
      messagesEl.scrollTop = messagesEl.scrollHeight;
      hideNewMessageNotification();
    } else if (initialLoadDone && newMessageCount > 0) {
      // User is not at bottom - show notification
      showNewMessageNotification(newMessageCount);
    }
  }
  
  // Mark first load as done
  initialLoadDone = true;
}
// Clear all message highlights when opening chat
function clearMessageHighlights() {
  document.querySelectorAll('.bubble.new-message').forEach(bubble => {
    bubble.classList.remove('new-message');
  });
  document.querySelectorAll('.message-highlight').forEach(bubble => {
    bubble.classList.remove('message-highlight');
  });
}
function cacheMessages(chatKey, data) {
  if (!data) return;
  
  // Get all message keys and sort them (newest first)
  const keys = Object.keys(data).map(Number).sort((a, b) => b - a);
  
  // Take only the latest 300 messages but maintain order
  if (keys.length > 300) {
    const limitedData = {};
    
    // Get the 300 newest messages but store them in chronological order
    keys.slice(0, 300)
      .sort((a, b) => a - b) // Sort in ascending order for proper caching
      .forEach(key => {
        limitedData[key] = data[key];
      });
      
    localStorage.setItem('chat_' + chatKey, JSON.stringify(limitedData));
  } else {
    localStorage.setItem('chat_' + chatKey, JSON.stringify(data));
  }
}

// Optimized function to load older messages
async function loadOlderMessages() {
  if (!currentKey || isLoadingOlderMessages || !hasMoreMessages) return;
  
  isLoadingOlderMessages = true;
  
  try {
    // Show loading indicator at the top
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'loading-indicator';
    loadingDiv.textContent = 'Loading older messages...';
    messagesEl.insertBefore(loadingDiv, messagesEl.firstChild);
    
    // Get the oldest timestamp we have loaded
    const messageKeys = Object.keys(messageStore).map(Number);
    const oldestKey = oldestLoadedTimestamp || Math.min(...messageKeys);
    
    // Query Firebase for older messages
    const snapshot = await db.ref('chats/' + currentKey)
      .orderByKey()
      .endBefore(String(oldestKey))
      .limitToLast(50)
      .once('value');
    
    const olderMessages = snapshot.val();
    
    if (!olderMessages || Object.keys(olderMessages).length === 0) {
      hasMoreMessages = false;
      loadingDiv.textContent = 'No older messages';
      setTimeout(() => {
        if (loadingDiv.parentNode === messagesEl) {
          messagesEl.removeChild(loadingDiv);
        }
      }, 2000);
      return;
    }
    
    // Add older messages to messageStore
    Object.assign(messageStore, olderMessages);
    
    // Render older messages at the top
    renderOlderMessages(olderMessages);
    
    // Update oldest loaded timestamp
    const olderKeys = Object.keys(olderMessages).map(Number);
    oldestLoadedTimestamp = Math.min(...olderKeys);
    
    // Remove loading indicator
    if (loadingDiv.parentNode === messagesEl) {
      messagesEl.removeChild(loadingDiv);
    }
    
  } catch (error) {
    console.error('Error loading older messages:', error);
    const loadingDiv = messagesEl.querySelector('.loading-indicator');
    if (loadingDiv && loadingDiv.parentNode === messagesEl) {
      loadingDiv.textContent = 'Error loading messages';
      setTimeout(() => {
        if (loadingDiv.parentNode === messagesEl) {
          messagesEl.removeChild(loadingDiv);
        }
      }, 2000);
    }
  } finally {
    isLoadingOlderMessages = false;
  }
}


// Optimized function to render older messages
function renderOlderMessages(messages) {
  // Convert to array and sort by timestamp
  const messageArray = Object.entries(messages)
    .map(([key, value]) => ({ key: Number(key), value }))
    .sort((a, b) => a.key - b.key); // Sort by timestamp (ascending order)
  
  const fragment = document.createDocumentFragment();
  let currentDate = null;
  
  messageArray.forEach(({ key, value }) => {
    const msgKey = String(key);
    const val = value;
    
    if (!val || (!val.text && !val.type && !val.url)) return;
    
    const msgDate = new Date(key);
    const dateLabel = formatDateSeparator(msgKey);
    
    // Date divider
    if (currentDate !== msgDate.toDateString()) {
      fragment.appendChild(createDateDivider(dateLabel));
      currentDate = msgDate.toDateString();
    }
    
    const div = buildMessageBubble(msgKey, val);
    fragment.appendChild(div);
  });
  
  // Get first child to insert before
  const firstChild = messagesEl.firstChild;
  messagesEl.insertBefore(fragment, firstChild);
}
//script set 






// --- Send reply ---
function sendReply(){
  const text = replyInput.value.trim();
  if(text==='' || !currentKey) return;
  const timestamp = Date.now();
  const message = {text,from:'brother'};
  if(replyToText){message.replyTo = replyToText.msgKey; replyToText=null;}
  
  db.ref('chats/'+currentKey+'/'+timestamp).set(message);
  db.ref("status/brother/typing").set(false); // stop typing

  document.getElementById("sendSound").play();
  
  replyInput.value='';
  replyInput.style.height="auto";
  replyInput.focus();
  replyPreviewContainer.innerHTML='';
}



// --- Swipe & reply handlers ---
function attachSwipeHandlers(bubbleEl,msgKey,text){
  let startX=0,startY=0,currentX=0,dragging=false,vibrated=false;
  bubbleEl.addEventListener('touchstart',e=>{
    // Don't start swipe if clicking on a link
    if (e.target.closest('.message-link')) return;
    
    startX=e.touches[0].clientX; 
    startY=e.touches[0].clientY; 
    dragging=true; 
    vibrated=false; 
    bubbleEl.style.transition="none";
  });
  bubbleEl.addEventListener('touchmove', e => {
      if (!dragging) return;
      
      // Don't process swipe if clicking on a link
      if (e.target.closest('.message-link')) {
        dragging = false;
        return;
      }
      
      currentX = e.touches[0].clientX - startX;
      const dy = e.touches[0].clientY - startY;
      if (Math.abs(dy) > 30) return;  
      const offset=Math.sign(currentX)*Math.min(Math.abs(currentX),120);
    bubbleEl.style.transform=`translateX(${offset}px)`;
    if(Math.abs(offset)>50 && !bubbleEl.classList.contains("show-arrow")){
      bubbleEl.classList.add("show-arrow");
      if(!vibrated && navigator.vibrate){navigator.vibrate([80,50,80]);vibrated=true;}
    } else bubbleEl.classList.remove("show-arrow");
  });
  bubbleEl.addEventListener('touchend',()=>{
    dragging=false; bubbleEl.style.transition="transform 0.2s ease"; bubbleEl.classList.remove("show-arrow");
    if(Math.abs(currentX)>80){
      replyToText={msgKey,text};
      replyPreviewContainer.innerHTML=`<div class="reply-preview"><div class="reply-preview-text">${text}</div><button onclick="cancelReply()">✖</button></div>`;
      replyInput.focus();
    }
    bubbleEl.style.transform="translateX(0px)"; currentX=0;
  });
}

function cancelReply(){replyToText=null; replyPreviewContainer.innerHTML=''; replyInput.placeholder='Type a message…';}
replyInput.addEventListener('blur',()=>{if(!replyInput.value && !replyToText) cancelReply();});

// --- Dark mode ---
// --- Dark mode ---
const darkModeToggle = document.getElementById("darkModeToggle");
const themeMeta = document.getElementById("theme-color-meta");

function updateThemeColor() {
  if (document.body.classList.contains("dark")) {
    themeMeta.setAttribute("content", "#13221F"); // dark mode color
  } else {
    themeMeta.setAttribute("content", "#DDF2ED"); // light mode color
  }
}




// On load, check saved mode
if (localStorage.getItem("darkMode") === "enabled") {
  document.body.classList.add("dark");
  darkModeToggle.textContent = "☀️";
}
updateThemeColor();

// Toggle button click
darkModeToggle.addEventListener("click", () => {
  document.body.classList.toggle("dark");
  if (document.body.classList.contains("dark")) {
    localStorage.setItem("darkMode", "enabled");
    darkModeToggle.textContent = "☀️";
  } else {
    localStorage.setItem("darkMode", "disabled");
    darkModeToggle.textContent = "🌙";
  }
  updateThemeColor();
});




window.addEventListener("popstate", function(event) {
  if (chatEl.classList.contains('active')) {
    chatEl.classList.remove('active');
    listEl.classList.add('active');
    currentKey = null;
  } else {
    history.back();
  }
});
</script>




<script>
  // ensure this runs after firebase.initializeApp(...) and after "const db = firebase.database();"
  const userEmail = "mahekj05@gmail.com";
  const userKey = userEmail.replace(/\./g, '_');
  
  // debug helper
  db.ref('.info/connected').on('value', snap => {
    console.log('DEBUG: .info/connected =>', snap.val());
  });
  
  // call setPresence that you already defined (or add below if missing)
  
  
  // For UI: update avatar border on status changes (you already have similar code)
  db.ref('status/' + userKey).on('value', snapshot => {
    const status = snapshot.val();
    console.log('DEBUG: status snapshot', status);
    const userLogo = document.getElementById('userLogo');
    if (!userLogo) return;
    let state = null;
    if (status && typeof status === 'object') state = status.state;
    else state = status;
    userLogo.style.border = (state === 'online') ? '3px solid green' : '3px solid orange';
  });
</script>
<style>
.chat-item {
  position: relative; /* Important for absolute badge positioning */
}
.unread-badge {
  position: absolute;
  top: 40px;
  right: 20px;
  background: #25D366; /* WhatsApp green */
  color: white;
  font-size: 12px;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 12px;
  min-width: 18px;
  text-align: center;
  display: inline-block; /* Show by default for testing */
}
</style>
<script>
// --- UNREAD BADGES & LAST SEEN TRACKING ---
let unreadCounts = {}; // store counts per chat key
let lastSeen = {};     // store last seen timestamp per chat

// --- Load/Save last seen from localStorage ---
function saveLastSeen() {
  localStorage.setItem('lastSeen', JSON.stringify(lastSeen));
}
function loadLastSeen() {
  const data = localStorage.getItem('lastSeen');
  if (data) lastSeen = JSON.parse(data);
}
loadLastSeen();

// --- Render chats and show badges ---
const oldRenderChats = renderChats;
renderChats = function(chats) {
  oldRenderChats(chats); // call original renderChats
  Object.keys(chats).forEach(key => {
    const item = allChats.find(c => c.key === key)?.element;
    if (item) {
      let badge = item.querySelector('.unread-badge');
      if (!badge) {
        badge = document.createElement('span');
        badge.className = 'unread-badge';
        item.appendChild(badge);
      }
      badge.textContent = unreadCounts[key] || 0;
      badge.style.display = (unreadCounts[key] || 0) > 0 ? 'inline-block' : 'none';
    }
  });
};

// --- Reset unread count when opening a chat ---
const oldOpenChat = openChat;
openChat = function(key) {
  unreadCounts[key] = 0;
  lastSeen[key] = Date.now();
  saveLastSeen();
  renderChatsOptimized(getCachedChatList() || {});
  oldOpenChat(key);
};

// --- Listen for new messages (child_added and child_changed) ---
db.ref('chats').on('child_added', snap => {
  const chatKey = snap.key;
  const msgs = snap.val();
  const lastKey = Math.max(...Object.keys(msgs).map(Number));
  const lastMsg = msgs[lastKey];
  const seenTime = lastSeen[chatKey] || 0;

  if (lastMsg.from === 'user' && lastKey > seenTime && chatKey !== currentKey) {
    unreadCounts[chatKey] = (unreadCounts[chatKey] || 0) + 1;
    renderChatsOptimized(getCachedChatList() || {});
  }
});

db.ref('chats').on('child_changed', snap => {
  const chatKey = snap.key;
  const msgs = snap.val();
  const lastKey = Math.max(...Object.keys(msgs).map(Number));
  const lastMsg = msgs[lastKey];
  const seenTime = lastSeen[chatKey] || 0;

  if (lastMsg.from === 'user' && lastKey > seenTime && chatKey !== currentKey) {
    unreadCounts[chatKey] = (unreadCounts[chatKey] || 0) + 1;
    renderChatsOptimized(getCachedChatList() || {});
  }
});
  // When going back to inbox, badges will already be updated
</script>
<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker
        .register("./service-worker.js")
        .then((reg) => console.log("Service Worker registered:", reg.scope))
        .catch((err) => console.error("Service Worker failed:", err));
    });
  }
</script>
  <script>
    // Prevent pinch zoom
    document.addEventListener('touchmove', function(event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
    }, { passive: false });
    
    // Prevent double-tap zoom
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, { passive: false });
  </script>

<script>
/* ===== Configuration ===== */
// Add your GIPHY API key here:
/* ===== Tenor configuration ===== */
// Get a Tenor API key: (Google Cloud Console -> enable Tenor API & create key)
const TENOR_API_KEY = "AIzaSyB_R_WfxdRYAnMCykNpxDAAJRqKkjpgUTs"; // <-- replace with your key
const TENOR_CLIENT_KEY = "brother dashboard"; // optional string identifying your app (use same value for all calls) // <-- get one at https://developers.giphy.com/ (free)

/* ===== Emoji picker setup using emoji-button ===== */
const { EmojiButton } = window;
let picker;
try{
  picker = new EmojiButton({ position: 'top-end', zIndex: 99999 });
  const emojiBtn = document.getElementById('emojiBtn');
  const replyInput = document.getElementById('replyInput');

  emojiBtn.addEventListener('click', () => {
    picker.togglePicker(emojiBtn);
  });

  picker.on('emoji', selection => {
    // Insert emoji at cursor position in textarea
    insertAtCursor(replyInput, selection.emoji);
    replyInput.focus();
  });
} catch(e){
  console.warn("Emoji picker failed to load:", e);
}

/* helper: insert at cursor for textarea */
function insertAtCursor(input, text) {
  const start = input.selectionStart || 0;
  const end = input.selectionEnd || 0;
  const value = input.value || '';
  input.value = value.slice(0, start) + text + value.slice(end);
  // move cursor after inserted text
  const newPos = start + text.length;
  input.selectionStart = input.selectionEnd = newPos;
  input.dispatchEvent(new Event('input'));
}

// Background Picker Functionality
const backgroundModal = document.getElementById('backgroundModal');
const resetBackgroundBtn = document.getElementById('resetBackgroundBtn');
const applyBackgroundBtn = document.getElementById('applyBackgroundBtn');
const bgImageUpload = document.getElementById('bgImageUpload');
const blurSlider = document.getElementById('blurSlider');
const opacitySlider = document.getElementById('opacitySlider');
const blurValue = document.getElementById('blurValue');
const opacityValue = document.getElementById('opacityValue');

 // 'color', 'gradient', 'image', 'custom'

// Load saved background
// Load saved background
function loadSavedBackground() {
  const saved = JSON.parse(localStorage.getItem('chatBackground') || '{}');
  console.log('Loading saved background:', saved);
  
  if (saved.type && saved.value) {
    // Use setTimeout to ensure DOM is ready and color system is initialized
    setTimeout(() => {
      console.log('Applying saved background using color system');
      applyBackground(saved.type, saved.value, saved.blur, saved.opacity);
    }, 200);
  } else {
    console.log('No saved background, using default color system');
    const messagesEl = document.getElementById('messages');
    messagesEl.classList.remove('custom-background');
    messagesEl.removeAttribute('style');
    
    // Remove any custom background styles
    const existingStyle = document.getElementById('custom-background-style');
    if (existingStyle) {
      existingStyle.remove();
    }
    
    // Let the existing color system handle the default background
    // It will use the colors from your customColors object
  }
}

// Apply background to messages area
// Apply background to messages area
function applyBackground(type, value, blur = 0, opacity = 50) {
  console.log('Final application:', { type, value, blur, opacity });
  
  const messagesEl = document.getElementById('messages');
  
  // Remove preview
  messagesEl.classList.remove('background-preview');
  const previewStyle = document.getElementById('background-preview-style');
  if (previewStyle) {
    previewStyle.remove();
  }
  
  // Remove any existing custom background
  messagesEl.classList.remove('custom-background');
  const existingStyle = document.getElementById('custom-background-style');
  if (existingStyle) {
    existingStyle.remove();
  }
  
  // Apply final background
  const currentMode = document.body.classList.contains('dark') ? 'dark' : 'light';
  const style = document.createElement('style');
  style.id = 'custom-background-style';
  
  let css = '';
  
  switch (type) {
    case 'color':
      css = `
                ${currentMode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #messages.custom-background {
                    background: ${value} !important;
                    background-color: ${value} !important;
                }
            `;
      break;
    case 'gradient':
      css = `
                ${currentMode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #messages.custom-background {
                    background: ${value} !important;
                }
            `;
      break;
    case 'image':
      css = `
                ${currentMode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #messages.custom-background {
                    background-image: url("${value}") !important;
                    background-size: cover !important;
                    background-position: center !important;
                    background-repeat: no-repeat !important;
                    background-attachment: fixed !important;
                }
            `;
      break;
  }
  
  if (blur > 0) {
    css = css.replace('}', `
            backdrop-filter: blur(${blur}px) !important;
            -webkit-backdrop-filter: blur(${blur}px) !important;
        }`);
  }
  
  style.textContent = css;
  document.head.appendChild(style);
  messagesEl.classList.add('custom-background');
  
  // Save settings
  const backgroundSettings = {
    type: type,
    value: value,
    blur: blur,
    opacity: opacity,
    appliedAt: Date.now()
  };
  
  localStorage.setItem('chatBackground', JSON.stringify(backgroundSettings));
  console.log('Background saved:', backgroundSettings);
  
  
}

// Open background picker
function openBackgroundPicker() {
  backgroundModal.classList.add('open');
  selectedBackground = null;
  
  // Load current settings
  const current = JSON.parse(localStorage.getItem('chatBackground') || '{}');
  if (current.blur) {
    blurSlider.value = current.blur;
    blurValue.textContent = current.blur;
  }
  if (current.opacity) {
    opacitySlider.value = current.opacity;
    opacityValue.textContent = current.opacity;
  }
}

// Close background picker
function closeBackgroundPicker() {
  backgroundModal.classList.remove('open');
}

// Tab functionality
document.querySelectorAll('.bg-tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.bg-tab-btn').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.bg-tab-content').forEach(c => c.classList.remove('active'));
    
    btn.classList.add('active');
    const tabId = btn.dataset.tab + 'Tab';
    document.getElementById(tabId).classList.add('active');
  });
});

// Color selection - add debugging
document.querySelectorAll('.color-option').forEach(option => {
  option.addEventListener('click', () => {
    console.log('Color option clicked:', option.dataset.color);
    document.querySelectorAll('.color-option, .gradient-option, .image-option').forEach(o => o.classList.remove('selected'));
    option.classList.add('selected');
    selectedBackground = option.dataset.color;
    selectedType = 'color';
    console.log('Selected:', selectedType, selectedBackground);
  });
});

// Gradient selection - add debugging
document.querySelectorAll('.gradient-option').forEach(option => {
  option.addEventListener('click', () => {
    console.log('Gradient option clicked:', option.dataset.gradient);
    document.querySelectorAll('.color-option, .gradient-option, .image-option').forEach(o => o.classList.remove('selected'));
    option.classList.add('selected');
    selectedBackground = option.dataset.gradient;
    selectedType = 'gradient';
    console.log('Selected:', selectedType, selectedBackground);
  });
});

// Image selection - add debugging
document.querySelectorAll('.image-option').forEach(option => {
  option.addEventListener('click', () => {
    console.log('Image option clicked:', option.dataset.image);
    document.querySelectorAll('.color-option, .gradient-option, .image-option').forEach(o => o.classList.remove('selected'));
    option.classList.add('selected');
    selectedBackground = option.dataset.image;
    selectedType = 'image';
    console.log('Selected:', selectedType, selectedBackground);
  });
});

// Apply background button - add debugging
// Add this to your JavaScript

// Reset background
resetBackgroundBtn.addEventListener('click', () => {
  const messagesEl = document.getElementById('messages');
  
  // Remove custom background class
  messagesEl.classList.remove('custom-background');
  
  // Remove inline styles
  messagesEl.removeAttribute('style');
  
  // Remove custom background styles
  const existingStyle = document.getElementById('custom-background-style');
  if (existingStyle) {
    existingStyle.remove();
  }
  
  // Let the existing color system handle the default background
  // This will use whatever is in your customColors for messagesBg
  
  localStorage.removeItem('chatBackground');
  closeBackgroundPicker();
  alert('Background reset to default');
});
// Add event listener for the menu item
document.addEventListener('click', (e) => {
  if (e.target.dataset.action === 'chat-background') {
    openBackgroundPicker();
  }
});

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
  loadSavedBackground();
});
/* ===== GIF picker modal + search ===== */
const gifBtn = document.getElementById('gifBtn');
const gifModal = document.getElementById('gifModal');
const gifSearch = document.getElementById('gifSearch');
const gifSearchBtn = document.getElementById('gifSearchBtn');
const gifResults = document.getElementById('gifResults');
const gifCloseBtn = document.getElementById('gifCloseBtn');

gifBtn.addEventListener('click', () => {
  console.log("GIF button clicked");
  gifModal.style.display = 'flex';
  searchTenor('trending');
});

gifCloseBtn.addEventListener('click', () => {
  gifModal.style.display = 'none';
  gifModal.setAttribute('aria-hidden','true');
});

gifSearchBtn.addEventListener('click', () => {
  const q = gifSearch.value.trim();
  if (!q) return;
  searchTenor(q);
});

async function searchTenor(query) {
  gifResults.innerHTML = 'Loading…';
  try {
    let url;
    const encoded = encodeURIComponent(query || '');
    // Trending / featured
    if (query === 'trending' || !query) {
      url = `https://tenor.googleapis.com/v2/featured?key=${TENOR_API_KEY}&client_key=${TENOR_CLIENT_KEY}&limit=25&contentfilter=low`;
    } else {
      // Search endpoint
      url = `https://tenor.googleapis.com/v2/search?q=${encoded}&key=${TENOR_API_KEY}&client_key=${TENOR_CLIENT_KEY}&limit=25&contentfilter=low`;
    }
    
    const res = await fetch(url);
    if (!res.ok) throw new Error('Tenor fetch failed: ' + res.status);
    const json = await res.json();
    
    gifResults.innerHTML = '';
    
    const results = json.results || [];
    results.forEach(r => {
      // defensive: pick a small preview format first (nanogif / tinygif), then fallback
      const mf = r.media_formats || {};
      const preview =
        (mf.nanogif && mf.nanogif.url) ||
        (mf.tinygif && mf.tinygif.url) ||
        (mf.nanowebp && mf.nanowebp.url) ||
        (mf.gif && mf.gif.url) ||
        null;
      
      // pick the share/full url (prefer full gif)
      const full =
        (mf.gif && mf.gif.url) ||
        (mf.mediumgif && mf.mediumgif.url) ||
        (mf.nanowebp && mf.nanowebp.url) ||
        preview;
      
      if (!preview) return; // no usable preview -> skip
      
      const img = document.createElement('img');
      img.className = 'gif-thumb';
      img.src = preview;
      img.alt = r.content_description || r.id || 'gif';
      
      img.addEventListener('click', () => {
        // send selected GIF as media message (your existing helper)
        sendMediaMessage({ type: 'gif', url: full });
        
        // optional: register the share with Tenor to improve search relevancy
        // (don't block UI on this; fire-and-forget)
        try {
          fetch(`https://tenor.googleapis.com/v2/registershare?id=${r.id}&key=${TENOR_API_KEY}&client_key=${TENOR_CLIENT_KEY}&q=${encoded}`)
            .catch(() => {});
        } catch (e) {}
        
        gifModal.style.display = 'none';
      });
      
      gifResults.appendChild(img);
    });
    
    if (results.length === 0) gifResults.innerHTML = 'No GIFs found.';
  } catch (err) {
    console.error('Tenor search error', err);
    gifResults.innerHTML = 'Search failed.';
  }
}

/* ===== Attach/file input (optional) ===== */
const attachBtn = document.getElementById('attachBtn');
const attachFile = document.getElementById('attachFile');

attachBtn.addEventListener('click', () => attachFile.click());


/* ===== Image compression helper (compress to approx target size and return dataURL) ===== */

function blobToDataURL(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

function imageBitmapOrImgFromFile(file) {
  // returns a Promise that resolves with an object {bitmap, width, height}
  if (window.createImageBitmap) {
    return createImageBitmap(file).then(bitmap => ({ bitmap, width: bitmap.width, height: bitmap.height }));
  } else {
    // fallback for older browsers
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        // draw into an offscreen canvas to create an ImageBitmap equivalent
        resolve({ img, width: img.naturalWidth, height: img.naturalHeight });
      };
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }
}

function canvasToBlob(canvas, quality) {
  return new Promise((resolve) => {
    canvas.toBlob(blob => resolve(blob), 'image/jpeg', quality);
  });
}

/**
 * Compress a File/Blob image to an approximate target size (KB).
 * Returns a Promise<string> resolving to a dataURL (JPEG).
 *
 * @param {File|Blob} file - source image file
 * @param {number} targetKb - desired max size in kilobytes (e.g. 200)
 * @param {object} opts - optional { maxWidth, maxHeight, minQuality }
 */
async function compressImageFile(file, targetKb = 200, opts = {}) {
  const maxWidth = opts.maxWidth || 1920;
  const maxHeight = opts.maxHeight || 1920;
  const minQuality = (opts.minQuality !== undefined) ? opts.minQuality : 0.45;
  
  // Load image (bitmap or img)
  const imgObj = await imageBitmapOrImgFromFile(file);
  let srcWidth = imgObj.width;
  let srcHeight = imgObj.height;
  
  // compute initial scale to fit maxWidth/maxHeight
  let scale = Math.min(1, maxWidth / srcWidth, maxHeight / srcHeight);
  let targetWidth = Math.round(srcWidth * scale);
  let targetHeight = Math.round(srcHeight * scale);
  
  // create canvas
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // helper to draw (bitmap or img) into canvas with current dims
  function drawToCanvas() {
    canvas.width = targetWidth;
    canvas.height = targetHeight;
    // if we have a bitmap use drawImage(bitmap,...)
    if (imgObj.bitmap) {
      ctx.drawImage(imgObj.bitmap, 0, 0, targetWidth, targetHeight);
    } else if (imgObj.img) {
      ctx.drawImage(imgObj.img, 0, 0, targetWidth, targetHeight);
    }
  }
  
  // iterative quality reduction loop, optionally downscale if quality floor hits
  let quality = 0.92;
  let blob = null;
  let dataUrl = null;
  const targetBytes = targetKb * 1024;
  
  // try multiple attempts: reduce quality first, then scale down if needed
  for (let attempt = 0; attempt < 8; attempt++) {
    drawToCanvas();
    blob = await canvasToBlob(canvas, quality);
    if (!blob) break;
    if (blob.size <= targetBytes || quality <= minQuality) {
      dataUrl = await blobToDataURL(blob);
      if (blob.size <= targetBytes) return dataUrl;
      // if we hit minQuality but still too big — we'll scale down image and try again
    }
    
    // if blob is too big, reduce quality
    if (blob.size > targetBytes) {
      // lower quality step
      quality = quality - 0.12;
      if (quality < minQuality) quality = minQuality;
    }
    
    // if at minimum quality and still large, scale down the dimensions by 0.85 and retry
    if (quality <= minQuality && blob.size > targetBytes) {
      targetWidth = Math.max(200, Math.round(targetWidth * 0.85));
      targetHeight = Math.max(200, Math.round(targetHeight * 0.85));
      // reset quality to a reasonable value for next loop
      quality = Math.max(minQuality, 0.82);
    }
  }
  
  // final fallback: return the last generated dataURL even if slightly larger than target
  if (blob) dataUrl = await blobToDataURL(blob);
  return dataUrl;
}

// Remove any existing event listeners first
attachFile.removeEventListener('change', handleFileUpload);
attachFile.addEventListener('change', handleFileUpload);

async function handleFileUpload(e) {
  const files = Array.from(e.target.files);
  if (files.length === 0) return;
  
  // Show processing indicator that matches app theme
  const processingIndicator = document.createElement('div');
  processingIndicator.id = 'fileUploadProgress';
  processingIndicator.innerHTML = `
    <div class="progress-content">
      <div class="progress-spinner"></div>
      <div class="progress-text">Processing ${files.length} image(s)...</div>
      <div class="progress-count">0/${files.length}</div>
    </div>
  `;
  
  processingIndicator.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: ${document.body.classList.contains('dark') ? '#13221F' : '#DDF2ED'};
    color: ${document.body.classList.contains('dark') ? '#B7CAC6' : '#3A4F4A'};
    padding: 20px;
    border-radius: 16px;
    
    z-index: 10000;
  
    min-width: 280px;
    backdrop-filter: blur(10px);
    font-family: 'Segoe UI', sans-serif;
  `;
  
  document.body.appendChild(processingIndicator);
  
  let processedCount = 0;
  let sentMessages = 0;
  
  for (const file of files) {
    if (!file.type.startsWith('image/')) {
      processedCount++;
      continue;
    }
    
    try {
      const compressedDataUrl = await compressImageFile(file, 200, { maxWidth: 1600, maxHeight: 1600 });
      if (compressedDataUrl) {
        setTimeout(() => {
          sendMediaMessage({ type: 'image', url: compressedDataUrl });
          sentMessages++;
        }, sentMessages * 100);
      }
    } catch (err) {
      console.error('Image compression failed', err);
      setTimeout(() => {
        const reader = new FileReader();
        reader.onload = function(ev) {
          sendMediaMessage({ type: 'image', url: ev.target.result });
          sentMessages++;
        };
        reader.readAsDataURL(file);
      }, sentMessages * 100);
    }
    
    processedCount++;
    // Update progress text
    const progressText = processingIndicator.querySelector('.progress-text');
    const progressCount = processingIndicator.querySelector('.progress-count');
    if (progressText && progressCount) {
      progressText.textContent = `Processing ${files.length} image(s)...`;
      progressCount.textContent = `${processedCount}/${files.length}`;
    }
  }
  
  // Remove indicator after all processing is done
  setTimeout(() => {
    const indicator = document.getElementById('fileUploadProgress');
    if (indicator && indicator.parentNode) {
      // Add fade out animation
      indicator.style.opacity = '0';
      indicator.style.transform = 'translate(-50%, -50%) scale(0.9)';
      indicator.style.transition = 'all 0.3s ease';
      
      setTimeout(() => {
        if (indicator.parentNode) {
          document.body.removeChild(indicator);
        }
      }, 300);
    }
    attachFile.value = '';
  }, Math.max(1000, files.length * 150));
}
/* ===== Paste handler: compress pasted image blob before sending ===== */
document.addEventListener('paste', async (e) => {
  const items = e.clipboardData && e.clipboardData.items;
  if (!items) return;
  
  const imageItems = Array.from(items).filter(it => it.kind === 'file' && it.type.startsWith('image/'));
  
  if (imageItems.length > 0) {
    for (const it of imageItems) {
      const blob = it.getAsFile();
      if (blob) {
        try {
          const compressed = await compressImageFile(blob, 200, { maxWidth: 1600, maxHeight: 1600 });
          if (compressed) sendMediaMessage({ type: 'image', url: compressed });
        } catch (err) {
          console.error('Paste compression failed', err);
          const reader = new FileReader();
          reader.onload = (ev) => sendMediaMessage({ type: 'image', url: ev.target.result });
          reader.readAsDataURL(blob);
        }
      }
    }
    e.preventDefault();
  }
  
  // Handle single URL pasting (existing code)
  for (const it of items) {
    if (it.kind === 'string' && it.type === 'text/plain') {
      it.getAsString(str => {
        if (str.match(/\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || str.includes('giphy.com')) {
          sendMediaMessage({ type: 'gif', url: str });
        }
      });
    }
  }
});


/* ===== Paste handler for image/GIF URLs or direct images ===== */


/* ===== sendMediaMessage helper =====
   Sends a chat message object to your DB with type and url.
*/
function sendMediaMessage(payload){
  // payload = { type: 'gif' | 'image', url: '...' }
  if(!currentKey) { alert('Open a chat first'); return; }
  const timestamp = Date.now();
  const message = { from: 'brother', type: payload.type, url: payload.url };
  // optionally include replyTo
  if(replyToText){ message.replyTo = replyToText.msgKey; replyToText=null; replyPreviewContainer.innerHTML=''; }
  db.ref('chats/' + currentKey + '/' + timestamp).set(message);
  document.getElementById("sendSound").play().catch(()=>{});
}

/* ===== Override send button to allow sending text or GIF/image URLs typed in ===== */
document.getElementById('sendBtn').addEventListener('click', sendReply);

const originalSendReply = window.sendReply || function(){};
window.sendReply = function(){
  const txtEl = document.getElementById('replyInput');
  const text = (txtEl.value || '').trim();
  if(!currentKey) return;
  if(!text && !replyToText) return; // nothing to send
  // if text is a direct image/GIF URL, send as media
  if(text.match(/^https?:\/\/.*\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || text.includes('giphy.com')) {
    sendMediaMessage({ type: 'gif', url: text });
    txtEl.value = '';
    return;
  }
  // else send as regular text
  const timestamp = Date.now();
  const message = { text, from:'brother' };
  if(replyToText){message.replyTo = replyToText.msgKey; replyToText=null; replyPreviewContainer.innerHTML='';}
  db.ref('chats/'+currentKey+'/'+timestamp).set(message);
  db.ref("status/brother/typing").set(false);
  try{ document.getElementById("sendSound").play(); }catch(e){}
  txtEl.value='';
  txtEl.style.height="auto";
  txtEl.focus();
};

/* ===== Render GIF / image in message bubble =====
   Modify your existing buildMessageBubble to handle `val.type === 'gif'` or `val.type === 'image'`.
   If you already have buildMessageBubble defined above, replace the rendering part with the snippet below.
*/
window.buildMessageBubble = function(msgKey, val) {
  const div = document.createElement('div');
  div.className = 'bubble ' + (val.from === 'user' ? 'from-user' : 'from-brother');
  div.setAttribute('data-msg-key', String(msgKey));
  div.id = 'msg_' + String(msgKey);
  div.style.position = 'relative'; // needed for media menu
  
  // reply arrow
  const arrow = document.createElement('div');
  arrow.className = 'reply-arrow';
  arrow.innerHTML = '↩';
  div.appendChild(arrow);
  attachSwipeHandlers(div, msgKey, val.text || '');
  
  // reply preview
  if (val.replyTo && messageStore[val.replyTo]) {
    const replyDiv = document.createElement('div');
    replyDiv.className = 'reply-box';
    const referenced = messageStore[val.replyTo];
    if (referenced && referenced.text) {
  const truncatedText = referenced.text.length > 120 ?
    referenced.text.slice(0, 120) + '…' : referenced.text;
  replyDiv.innerHTML = linkify(truncatedText);
} else {
  replyDiv.textContent = '[media]';
}
    
    replyDiv.addEventListener('click', (e) => {
      e.stopPropagation();
      e.stopImmediatePropagation(); // prevent long-press interference
      highlightAndScrollTo(val.replyTo);
    });
    
    div.prepend(replyDiv);
  }
  
  // media (image/gif)
  if (val.type === 'gif' || val.type === 'image') {
    const media = document.createElement('img');
    media.style.maxWidth = '100%';
    media.style.maxHeight = '260px';
    media.style.borderRadius = '8px';
    media.style.display = 'block';
    media.style.marginBottom = '6px';
    media.src = val.url;
    media.alt = val.type;
    div.appendChild(media);
    
    // ⋮ menu for media
    const menuBtn = document.createElement('button');
    menuBtn.innerHTML = '⋮';
    menuBtn.className = 'menu-btn';
    menuBtn.style.position = 'absolute';
    menuBtn.style.top = '6px';
    menuBtn.style.right = '6px';
    menuBtn.style.background = 'transparent';
    menuBtn.style.border = 'none';
    menuBtn.style.fontSize = '18px';
    menuBtn.style.cursor = 'pointer';
    
    const menu = createDeleteMenu(msgKey);
    div.appendChild(menu);
    
    menuBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      menu.style.display = (menu.style.display === 'none') ? 'block' : 'none';
    });
    
    document.addEventListener('click', () => { menu.style.display = 'none'; });
    div.appendChild(menuBtn);
    
    if (val.text) {
  const textNode = document.createElement('div');
  textNode.innerHTML = linkify(val.text);
  div.appendChild(textNode);
}
    
} else {
  // text message
  const textNode = document.createElement('div');
  textNode.innerHTML = linkify(val.text || '');
  div.appendChild(textNode);
  
  // long press support - modified to ignore link clicks
  let pressTimer;
  const startPress = (e) => {
    // Don't start long press if clicking on a link or reply box
    if (e.target.closest('.message-link') || e.target.closest('.reply-box')) return;
    
    e.preventDefault();
    pressTimer = setTimeout(() => {
      if (confirm('Delete this message?')) {
        const chatKey = currentKey;
        db.ref('chats/' + chatKey + '/' + msgKey).remove()
          .then(() => console.log('Text deleted:', msgKey))
          .catch(err => console.error('Failed to delete text:', err));
      }
    }, 700);
  };
    const cancelPress = () => clearTimeout(pressTimer);
    
    div.addEventListener('mousedown', startPress);
    div.addEventListener('mouseup', cancelPress);
    div.addEventListener('mouseleave', cancelPress);
    div.addEventListener('touchstart', startPress);
    div.addEventListener('touchend', cancelPress);
    div.addEventListener('touchmove', cancelPress);
  }
  
  // timestamp
  const timeNode = document.createElement('div');
  timeNode.className = 'msg-time';
  timeNode.textContent = new Date(Number(msgKey)).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
  div.appendChild(timeNode);
  
  return div;
};

// helper to create delete menu for media
function createDeleteMenu(msgKey) {
  const menu = document.createElement('div');
  menu.className = 'menu-popup';
  menu.style.position = 'absolute';
  menu.style.top = '28px';
  menu.style.right = '6px';
  menu.style.background = 'grey';
  menu.style.border = '1px solid #ccc';
  menu.style.borderRadius = '6px';
  menu.style.padding = '4px 0';
  menu.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
  menu.style.display = 'none';
  menu.style.zIndex = 100;
  
  const delOption = document.createElement('div');
  delOption.textContent = 'Delete';
  delOption.style.padding = '6px 12px';
  delOption.style.cursor = 'pointer';
  delOption.addEventListener('mouseover', () => { delOption.style.background = '#f0f0f0'; });
  delOption.addEventListener('mouseout', () => { delOption.style.background = 'transparent'; });
  
  delOption.addEventListener('click', (e) => {
    e.stopPropagation();
    menu.style.display = 'none';
    if (!confirm('Delete this message?')) return;
    const chatKey = currentKey;
    db.ref('chats/' + chatKey + '/' + msgKey).remove()
      .then(() => console.log('Deleted:', msgKey))
      .catch(err => console.error('Failed to delete:', err));
  });
  
  menu.appendChild(delOption);
  return menu;
}
</script>
<script>
  //highlight reply bubble 
  
  
  function highlightAndScrollTo(msgKey) {
  if (!msgKey) return;
  const id = 'msg_' + msgKey;
  let target = document.getElementById(id) || document.querySelector('[data-msg-key="'+msgKey+'"]');
  if (!target) return;

  target.scrollIntoView({ behavior: 'smooth', block: 'center' });

  // Apply grey/orange highlight temporarily
  target.classList.add('message-highlight');
  setTimeout(() => {
    target.classList.remove('message-highlight');
  }, 2000);
}
</script>
<!-- your existing page content -->



<!-- Modern Lightbox -->
<!-- WhatsApp Style Full Screen Lightbox -->
<div id="lightbox" class="lightbox" aria-hidden="true">
  <div class="lightbox-header">
    <button class="lightbox-close" aria-label="Close">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" />
      </svg>
    </button>
    <div class="lightbox-counter" id="lightboxCounter"></div>
  </div>
  
  <div class="lightbox-content">
    <div class="lightbox-image-container">
      <img id="lightboxImg" class="lightbox-image" src="" alt="">
    </div>
    
    <!-- Navigation arrows -->
    <button class="lightbox-nav lightbox-prev" aria-label="Previous" style="visibility:hidden">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" />
      </svg>
    </button>
    <button style="visibility:hidden" class="lightbox-nav lightbox-next" aria-label="Next">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
        <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" />
      </svg>
    </button>
  </div>
  
  <div class="lightbox-footer">
    <div class="lightbox-toolbar">
      <a id="lightboxDownload" class="lightbox-btn download-btn" download>
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" />
        </svg>
        Download
      </a>
      <button id="lightboxSave" class="lightbox-btn save-btn">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z" />
        </svg>
        Save to Collection
      </button>
    </div>
  </div>
</div>

<!-- Notification -->
<div id="notification" class="notification">
  <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
    <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" />
  </svg>
  <span id="notificationText">Image saved to collection!</span>
</div>
  <!-- LIGHTBOX SCRIPT -->
<script>// MODERN LIGHTBOX SCRIPT - COMPLETE FIXED VERSION
(function(){
    const messagesEl = document.getElementById('messages');
    const lightbox = document.getElementById('lightbox');
    const lImg = document.getElementById('lightboxImg');
    const btnClose = lightbox.querySelector('.lightbox-close');
    const btnPrev = lightbox.querySelector('.lightbox-prev');
    const btnNext = lightbox.querySelector('.lightbox-next');
    const btnDownload = document.getElementById('lightboxDownload');
    const btnSave = document.getElementById('lightboxSave');
    const counter = document.getElementById('lightboxCounter');
    const notification = document.getElementById('notification');
    const notificationText = document.getElementById('notificationText');

    let gallery = [], idx = 0;
    let isZoomed = false;
    let scale = 1;
    let lastScale = 1;
    let posX = 0, posY = 0;
    let startX = 0, startY = 0;
    let isDragging = false;
    let isPinching = false;
    let savedCollection = JSON.parse(localStorage.getItem('savedCollection')) || [];
    let touchStartX = 0;
    let touchStartY = 0;

    // Initialize
    function initializeLightbox() {
        const addImageHandlers = (img) => {
            if (img.hasAttribute('data-lightbox-handler') ||
                img.closest('.selection-checkbox') ||
                img.closest('.menu-popup')) {
                return;
            }

            img.style.cursor = 'zoom-in';
            img.setAttribute('data-lightbox-handler', 'true');

            img.addEventListener('click', function(e) {
                if (!window.isSelectionMode &&
                    !e.target.closest('button') &&
                    !e.target.closest('.menu-btn')) {
                    openAt(this.src);
                    e.stopPropagation();
                    e.preventDefault();
                }
            });
        };

        // Add handlers to existing images
        messagesEl.querySelectorAll('img[src]').forEach(addImageHandlers);

        // Watch for new images
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                mutation.addedNodes.forEach(function(node) {
                    if (node.nodeType === 1) {
                        if (node.tagName === 'IMG') {
                            addImageHandlers(node);
                        }
                        if (node.querySelectorAll) {
                            node.querySelectorAll('img[src]').forEach(addImageHandlers);
                        }
                    }
                });
            });
        });

        observer.observe(messagesEl, {
            childList: true,
            subtree: true
        });

        console.log('Lightbox initialized');
    }

    // Save image to chat background collection
    function saveToCollection(imageSrc) {
        // Get uploaded images from localStorage
        let uploadedImages = JSON.parse(localStorage.getItem('uploadedBackgrounds')) || [];
        
        // Check if image already exists
        const existingImage = uploadedImages.find(img => img.url === imageSrc);
        
        if (!existingImage) {
            // Create image data
            const imageData = {
                url: imageSrc,
                name: `Saved_${Date.now()}`,
                uploadedAt: Date.now(),
                type: 'saved'
            };
            
            // Add to uploaded images
            uploadedImages.push(imageData);
            localStorage.setItem('uploadedBackgrounds', JSON.stringify(uploadedImages));
            
            // Add to saved images grid
            addImageToSavedCollection(imageSrc, imageData.name);
            
            showNotification('Image saved to collection!');
            console.log('Image saved to background collection');
        } else {
            showNotification('Image already in collection');
        }
    }

    // Add image to saved collection grid
    function addImageToSavedCollection(imageUrl, imageName) {
        const savedImagesGrid = document.getElementById('savedImagesGrid');
        
        if (!savedImagesGrid) {
            console.log('Saved images grid not found, will add when available');
            return;
        }
        
        // Check if already exists
        const existingImage = Array.from(savedImagesGrid.querySelectorAll('.image-option'))
            .find(opt => opt.getAttribute('data-image') === imageUrl);
        
        if (existingImage) return;
        
        // Create image option
        const imageOption = document.createElement('div');
        imageOption.className = 'image-option';
        imageOption.setAttribute('data-image', imageUrl);
        imageOption.setAttribute('data-name', imageName);
        imageOption.style.backgroundImage = `url('${imageUrl}')`;
        imageOption.title = imageName;
        
        // Add click handler
        imageOption.addEventListener('click', function(e) {
            e.stopPropagation();
            
            document.querySelectorAll('.color-option, .gradient-option, .image-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            this.classList.add('selected');
            selectedBackground = this.getAttribute('data-image');
            selectedType = 'image';
            
            showImageActions(this, imageUrl, imageName);
        });
        
        // Add remove button
        addRemoveButtonToImage(imageOption, imageUrl, imageName);
        
        savedImagesGrid.appendChild(imageOption);
    }

    // Helper function for remove button
    function addRemoveButtonToImage(imageOption, imageUrl, imageName) {
        if (!imageName.startsWith('Default')) {
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-image-btn';
            removeBtn.innerHTML = '×';
            removeBtn.title = 'Remove image';
            
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeUploadedImage(imageUrl, imageName, imageOption);
            });
            
            imageOption.appendChild(removeBtn);
        }
    }

    // Remove image function
    function removeUploadedImage(imageUrl, imageName, imageElement) {
        if (confirm(`Remove "${imageName}" from collection?`)) {
            let uploadedImages = JSON.parse(localStorage.getItem('uploadedBackgrounds')) || [];
            uploadedImages = uploadedImages.filter(img => img.url !== imageUrl);
            localStorage.setItem('uploadedBackgrounds', JSON.stringify(uploadedImages));
            
            imageElement.remove();
            
            if (selectedBackground === imageUrl && selectedType === 'image') {
                selectedBackground = null;
                selectedType = null;
            }
        }
    }

    // Show notification
    function showNotification(message) {
        if (!notification) return;
        
        notificationText.textContent = message;
        notification.classList.add('show');
        setTimeout(() => {
            notification.classList.remove('show');
        }, 2000);
    }

    // Build gallery
    function buildGallery(){
        gallery = Array.from(messagesEl.querySelectorAll('img[src]'))
            .filter(img => !img.closest('.selection-checkbox') && 
                          !img.closest('.menu-popup') &&
                          img.src && img.src !== '')
            .map(img => img.src);
    }

    // Open lightbox
    function openAt(src){
        buildGallery();
        idx = gallery.indexOf(src);
        if(idx === -1) {
            gallery = [src];
            idx = 0;
        }
        show();
    }

    // Show lightbox
    function show(){
        if (gallery.length === 0) return;

        lImg.src = gallery[idx];
        resetZoom();
        lightbox.classList.add('active');
        document.body.style.overflow = 'hidden';

        // Set download link
        btnDownload.href = gallery[idx];
        btnDownload.setAttribute('download', 'image_' + Date.now() + '.jpg');

        // Update counter
        updateCounter();

        // Show/hide nav buttons
        btnPrev.style.display = gallery.length > 1 ? 'block' : 'none';
        btnNext.style.display = gallery.length > 1 ? 'block' : 'none';
    }

    // Close lightbox
    function close(){
        lightbox.classList.remove('active');
        document.body.style.overflow = '';
        resetZoom();
    }

    // Previous image
    function prev(){
        idx = (idx - 1 + gallery.length) % gallery.length;
        resetZoom();
        lImg.src = gallery[idx];
        updateCounter();
    }

    // Next image
    function next(){
        idx = (idx + 1) % gallery.length;
        resetZoom();
        lImg.src = gallery[idx];
        updateCounter();
    }

    // Update counter
    function updateCounter() {
        counter.textContent = (gallery.length > 1) ? (idx + 1) + ' / ' + gallery.length : '';
    }

    // ZOOM FUNCTIONALITY
    function toggleZoom() {
        if (scale > 1) {
            resetZoom();
        } else {
            zoomIn();
        }
    }

    function zoomIn() {
        scale = 2;
        updateTransform();
        lImg.classList.add('zoomed');
        isZoomed = true;
    }

    function resetZoom() {
        scale = 1;
        posX = 0;
        posY = 0;
        updateTransform();
        lImg.classList.remove('zoomed', 'dragging');
        isZoomed = false;
        isDragging = false;
    }

    function updateTransform() {
        lImg.style.transform = `scale(${scale}) translate(${posX}px, ${posY}px)`;
    }

    // TOUCH GESTURES
    function handleTouchStart(e) {
        if (e.touches.length === 1) {
            // Single touch - prepare for drag or swipe
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            startX = touch.clientX - posX;
            startY = touch.clientY - posY;
            
            if (isZoomed) {
                isDragging = true;
                lImg.classList.add('dragging');
            }
        } else if (e.touches.length === 2) {
            // Two fingers - pinch to zoom
            isPinching = true;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            lastScale = scale;
            
            // Calculate initial distance
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            touchStartDistance = Math.sqrt(dx * dx + dy * dy);
        }
    }

    function handleTouchMove(e) {
        if (e.touches.length === 1 && isDragging) {
            // Single touch drag
            const touch = e.touches[0];
            posX = touch.clientX - startX;
            posY = touch.clientY - startY;
            
            // Limit drag boundaries
            const maxX = lImg.offsetWidth * (scale - 1) / 2;
            const maxY = lImg.offsetHeight * (scale - 1) / 2;
            
            posX = Math.max(-maxX, Math.min(maxX, posX));
            posY = Math.max(-maxY, Math.min(maxY, posY));
            
            updateTransform();
        } else if (e.touches.length === 2 && isPinching) {
            // Pinch to zoom
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (touchStartDistance > 0) {
                scale = Math.max(1, Math.min(3, lastScale * (distance / touchStartDistance)));
                updateTransform();
                
                if (scale > 1) {
                    lImg.classList.add('zoomed');
                    isZoomed = true;
                }
            }
        }
    }

    function handleTouchEnd(e) {
        if (e.touches.length === 0) {
            // All touches ended
            isDragging = false;
            isPinching = false;
            lImg.classList.remove('dragging');
            
            // Check for swipe gesture
            if (!isZoomed && e.changedTouches.length === 1) {
                const touch = e.changedTouches[0];
                const deltaX = touch.clientX - touchStartX;
                const deltaY = touch.clientY - touchStartY;
                
                // Only handle horizontal swipes with minimal vertical movement
                if (Math.abs(deltaX) > 50 && Math.abs(deltaY) < 30) {
                    if (deltaX > 0) {
                        // Swipe right - previous
                        prev();
                    } else {
                        // Swipe left - next
                        next();
                    }
                }
            }
        }
    }

    // MOUSE EVENTS
    function handleMouseDown(e) {
        if (!isZoomed) return;
        
        isDragging = true;
        lImg.classList.add('dragging');
        startX = e.clientX - posX;
        startY = e.clientY - posY;
    }

    function handleMouseMove(e) {
        if (!isDragging) return;
        
        posX = e.clientX - startX;
        posY = e.clientY - startY;
        
        // Limit drag boundaries
        const maxX = lImg.offsetWidth * (scale - 1) / 2;
        const maxY = lImg.offsetHeight * (scale - 1) / 2;
        
        posX = Math.max(-maxX, Math.min(maxX, posX));
        posY = Math.max(-maxY, Math.min(maxY, posY));
        
        updateTransform();
    }

    function handleMouseUp() {
        isDragging = false;
        lImg.classList.remove('dragging');
    }

    // DOUBLE TAP ZOOM
    let lastTap = 0;
    function handleDoubleTap(e) {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        
        if (tapLength < 300 && tapLength > 0) {
            toggleZoom();
            e.preventDefault();
        }
        
        lastTap = currentTime;
    }

    // EVENT LISTENERS
    btnClose.addEventListener('click', close);
    btnPrev.addEventListener('click', prev);
    btnNext.addEventListener('click', next);
    btnSave.addEventListener('click', () => saveToCollection(gallery[idx]));

    // Image interactions
    lImg.addEventListener('click', (e) => {
        if (!isDragging) {
            toggleZoom();
        }
    });

    lImg.addEventListener('dblclick', handleDoubleTap);

    // Mouse events
    lImg.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    // Touch events
    lImg.addEventListener('touchstart', handleTouchStart);
    lImg.addEventListener('touchmove', handleTouchMove);
    lImg.addEventListener('touchend', handleTouchEnd);

    // Close on background click
    lightbox.addEventListener('click', function(e) {
        if (e.target === lightbox) {
            close();
        }
    });

    // Keyboard navigation
    document.addEventListener('keydown', function(e){
        if(!lightbox.classList.contains('active')) return;

        switch(e.key) {
            case 'Escape': close(); break;
            case 'ArrowLeft': prev(); break;
            case 'ArrowRight': next(); break;
            case ' ': toggleZoom(); break;
        }
    });

    // Initialize
    initializeLightbox();

    // Expose to global scope
    window.openLightbox = openAt;
    window.closeLightbox = close;
})();</script>

    <!-- Color Customization Modal -->
<div id="colorModal" class="color-modal" aria-hidden="true">
  <div class="color-modal-content">
    <h3 id="colorModalTitle" style="margin-bottom: 20px;">Customize Colors</h3>
    
    <div id="colorOptions">
      <!-- Color options will be dynamically inserted here -->
    </div>
    
    <div class="modal-actions">
      <button class="modal-btn secondary" id="cancelColorBtn">Cancel</button>
      <button class="modal-btn primary" id="saveColorBtn">Save Changes</button>
    </div>
  </div>
</div>
<script>
  // Settings menu functionality
const settingsToggle = document.getElementById('settingsToggle');
const settingsMenu = document.getElementById('settingsMenu');
const colorModal = document.getElementById('colorModal');
const colorModalTitle = document.getElementById('colorModalTitle');
const colorOptions = document.getElementById('colorOptions');
const cancelColorBtn = document.getElementById('cancelColorBtn');
const saveColorBtn = document.getElementById('saveColorBtn');
// Simple cancel button functionality
cancelColorBtn.addEventListener('click', () => {
  colorModal.classList.remove('open');
});

let currentMode = 'light'; // Track which mode we're customizing

// Default color schemes
// Default color schemes
// Default color schemes
const defaultColors = {
  light: {
    userBubble: '#DDF2ED',
    brotherBubble: '#006B61',
    chatHeader: '#DDF2ED',
    inputArea: '#DDF2ED',
    messagesBg: '#E9FEF9',
    chatListBg: '#DFF2EC',
    chatItemBg: '#EAFDF9',
    
    previewText: '#666666',
    // NEW COLOR OPTIONS
    stalkColor: '#2563eb',
    bubuTextColor: '#000000',
    lastSeenColor: '#666666',
    onlineColor: '#25D366',
    typingColor: '#25D366',
    picBorderOnline: '#25D366',
    picBorderOffline: '#FFA500',
    svgColor: '#3A4F4A',
    brotherTextColor: '#FFFFFF',
    brotherTimeColor: '#E5E5E5',
    userTextColor: '#000000',
    userTimeColor: '#666666',
    messageLinkColor: '#075E54' // ADD THIS LINE
  },
  dark: {
    userBubble: '#13221F',
    brotherBubble: '#005047',
    chatHeader: '#13221F',
    inputArea: '#13221F',
    messagesBg: '#031813',
    chatListBg: '#12221F',
    chatItemBg: '#061613',
    
    previewText: '#B7CAC6',
    // NEW COLOR OPTIONS
    stalkColor: '#B7CAC6',
    bubuTextColor: '#B7CAC6',
    lastSeenColor: '#B7CAC6',
    onlineColor: '#25D366',
    typingColor: '#25D366',
    picBorderOnline: '#25D366',
    picBorderOffline: '#FFA500',
    svgColor: '#B7CAC6',
    brotherTextColor: '#FFFFFF',
    brotherTimeColor: '#E5E5E5',
    userTextColor: '#B7CAC6',
    userTimeColor: '#B7CAC6',
    messageLinkColor: '#075E54' // ADD THIS LINE
  }
};
let customColors = JSON.parse(localStorage.getItem('customColors')) || {
  light: {...defaultColors.light},
  dark: {...defaultColors.dark}
};

// Toggle settings menu
settingsToggle.addEventListener('click', (e) => {
  e.stopPropagation();
  settingsMenu.style.display = settingsMenu.style.display === 'block' ? 'none' : 'block';
});

// Close settings menu when clicking outside
document.addEventListener('click', () => {
  settingsMenu.style.display = 'none';
});

// Settings menu actions
document.querySelectorAll('.menu-item').forEach(item => {
  item.addEventListener('click', (e) => {
    const action = e.target.dataset.action;
    
    switch(action) {
      case 'toggle-dark':
        enableDarkMode();
        break;
      case 'toggle-light':
        disableDarkMode();
        break;
      case 'customize-dark':
        openColorCustomization('dark');
        break;
      case 'customize-light':
        openColorCustomization('light');
        break;
      case 'reset-colors':
        resetColorsToDefault();
        break;
      case 'chat-background':
openBackgroundPicker();
break;  
    }
    
    settingsMenu.style.display = 'none';
  });
});

// Dark mode functions
function enableDarkMode() {
  document.body.classList.add('dark');
  localStorage.setItem('darkMode', 'enabled');
  applyCustomColors('dark');
}

function disableDarkMode() {
  document.body.classList.remove('dark');
  localStorage.setItem('darkMode', 'disabled');
  applyCustomColors('light');
}
// ADVANCED COLOR PICKER WITH WHEEL - REPLACE EXISTING COLOR PICKER CODE
class AdvancedColorPicker {
  constructor(container, currentColor, onColorChange) {
    this.container = container;
    this.currentColor = currentColor;
    this.onColorChange = onColorChange;
    this.hue = 0;
    this.saturation = 100;
    this.brightness = 100;
    
    this.init();
    this.updateFromHex(currentColor);
  }

  init() {
    this.container.innerHTML = this.getTemplate();
    this.bindEvents();
    this.updateUI();
  }

  getTemplate() {
    return `
      <div class="color-picker-header">
        <div class="color-picker-title">Color Picker</div>
        <button class="color-picker-close" onclick="this.closest('.color-picker-dropdown').classList.remove('show')">×</button>
      </div>

      <div class="color-wheel-container" id="colorWheel">
        <div class="color-wheel"></div>
        <div class="wheel-cursor" style="display: none;"></div>
      </div>

      <div class="brightness-control" id="brightnessControl">
        <div class="brightness-cursor"></div>
      </div>

      <div class="current-color-preview">
        <div class="color-preview-large" id="largeColorPreview"></div>
        <div class="color-values">
          <div class="hex-value" id="hexValue">#000000</div>
          <div class="rgb-value" id="rgbValue">rgb(0, 0, 0)</div>
        </div>
      </div>

      <div class="color-inputs-grid">
        <div class="color-input-group">
          <label class="color-input-label">HEX</label>
          <input type="text" class="color-channel-input" id="hexInput" value="#000000" maxlength="7">
        </div>
        <div class="color-input-group">
          <label class="color-input-label">R</label>
          <input type="number" class="color-channel-input" id="redInput" min="0" max="255" value="0">
        </div>
        <div class="color-input-group">
          <label class="color-input-label">G</label>
          <input type="number" class="color-channel-input" id="greenInput" min="0" max="255" value="0">
        </div>
        <div class="color-input-group">
          <label class="color-input-label">B</label>
          <input type="number" class="color-channel-input" id="blueInput" min="0" max="255" value="0">
        </div>
        <div class="color-input-group">
          <label class="color-input-label">H</label>
          <input type="number" class="color-channel-input" id="hueInput" min="0" max="360" value="0">
        </div>
        <div class="color-input-group">
          <label class="color-input-label">S</label>
          <input type="number" class="color-channel-input" id="saturationInput" min="0" max="100" value="100">
        </div>
        <div class="color-input-group">
          <label class="color-input-label">V</label>
          <input type="number" class="color-channel-input" id="valueInput" min="0" max="100" value="100">
        </div>
      </div>

      <div class="preset-colors">
        <div class="preset-title">Preset Colors</div>
        <div class="preset-grid" id="presetGrid"></div>
      </div>

      <div class="color-picker-actions">
        <button class="color-picker-btn" onclick="this.closest('.color-picker-dropdown').classList.remove('show')">Cancel</button>
        <button class="color-picker-btn primary" id="confirmColor">Apply Color</button>
      </div>
    `;
  }

  bindEvents() {
    // Color wheel events
    const wheel = this.container.querySelector('#colorWheel');
    wheel.addEventListener('mousedown', this.startWheelInteraction.bind(this));
    wheel.addEventListener('touchstart', this.startWheelInteraction.bind(this));

    // Brightness control events
    const brightness = this.container.querySelector('#brightnessControl');
    brightness.addEventListener('mousedown', this.startBrightnessInteraction.bind(this));
    brightness.addEventListener('touchstart', this.startBrightnessInteraction.bind(this));

    // Input events
    this.container.querySelector('#hexInput').addEventListener('input', this.onHexInput.bind(this));
    this.container.querySelector('#redInput').addEventListener('input', this.onRgbInput.bind(this));
    this.container.querySelector('#greenInput').addEventListener('input', this.onRgbInput.bind(this));
    this.container.querySelector('#blueInput').addEventListener('input', this.onRgbInput.bind(this));
    this.container.querySelector('#hueInput').addEventListener('input', this.onHsvInput.bind(this));
    this.container.querySelector('#saturationInput').addEventListener('input', this.onHsvInput.bind(this));
    this.container.querySelector('#valueInput').addEventListener('input', this.onHsvInput.bind(this));

    // Confirm button
    this.container.querySelector('#confirmColor').addEventListener('click', this.confirmColor.bind(this));

    // Load preset colors
    this.loadPresetColors();
  }

  startWheelInteraction(e) {
    e.preventDefault();
    const wheel = this.container.querySelector('#colorWheel');
    const rect = wheel.getBoundingClientRect();
    
    const moveHandler = (moveEvent) => {
      const clientX = moveEvent.clientX || (moveEvent.touches && moveEvent.touches[0].clientX);
      const clientY = moveEvent.clientY || (moveEvent.touches && moveEvent.touches[0].clientY);
      
      const x = clientX - rect.left - rect.width / 2;
      const y = clientY - rect.top - rect.height / 2;
      
      const distance = Math.sqrt(x * x + y * y);
      const maxDistance = rect.width / 2;
      
      if (distance <= maxDistance) {
        let angle = Math.atan2(y, x) * (180 / Math.PI);
        if (angle < 0) angle += 360;
        
        const saturation = Math.min(100, (distance / maxDistance) * 100);
        
        this.hue = Math.round(angle);
        this.saturation = Math.round(saturation);
        this.updateFromHSV();
      }
    };
    
    const upHandler = () => {
      document.removeEventListener('mousemove', moveHandler);
      document.removeEventListener('touchmove', moveHandler);
      document.removeEventListener('mouseup', upHandler);
      document.removeEventListener('touchend', upHandler);
    };
    
    document.addEventListener('mousemove', moveHandler);
    document.addEventListener('touchmove', moveHandler);
    document.addEventListener('mouseup', upHandler);
    document.addEventListener('touchend', upHandler);
    
    moveHandler(e);
  }

  startBrightnessInteraction(e) {
    e.preventDefault();
    const control = this.container.querySelector('#brightnessControl');
    const rect = control.getBoundingClientRect();
    
    const moveHandler = (moveEvent) => {
      const clientX = moveEvent.clientX || (moveEvent.touches && moveEvent.touches[0].clientX);
      let x = clientX - rect.left;
      x = Math.max(0, Math.min(rect.width, x));
      
      this.brightness = Math.round((x / rect.width) * 100);
      this.updateFromHSV();
    };
    
    const upHandler = () => {
      document.removeEventListener('mousemove', moveHandler);
      document.removeEventListener('touchmove', moveHandler);
      document.removeEventListener('mouseup', upHandler);
      document.removeEventListener('touchend', upHandler);
    };
    
    document.addEventListener('mousemove', moveHandler);
    document.addEventListener('touchmove', moveHandler);
    document.addEventListener('mouseup', upHandler);
    document.addEventListener('touchend', upHandler);
    
    moveHandler(e);
  }

  onHexInput(e) {
    const hex = e.target.value;
    if (this.isValidHex(hex)) {
      this.updateFromHex(hex);
    }
  }

  onRgbInput() {
    const r = parseInt(this.container.querySelector('#redInput').value) || 0;
    const g = parseInt(this.container.querySelector('#greenInput').value) || 0;
    const b = parseInt(this.container.querySelector('#blueInput').value) || 0;
    this.updateFromRGB(r, g, b);
  }

  onHsvInput() {
    const h = parseInt(this.container.querySelector('#hueInput').value) || 0;
    const s = parseInt(this.container.querySelector('#saturationInput').value) || 0;
    const v = parseInt(this.container.querySelector('#valueInput').value) || 0;
    this.hue = h;
    this.saturation = s;
    this.brightness = v;
    this.updateFromHSV();
  }

  updateFromHex(hex) {
    hex = hex.replace('#', '');
    if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    this.updateFromRGB(r, g, b);
  }

  updateFromRGB(r, g, b) {
    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    b = Math.max(0, Math.min(255, b));
    
    const [h, s, v] = this.rgbToHsv(r, g, b);
    this.hue = h;
    this.saturation = s;
    this.brightness = v;
    
    this.updateUI();
  }

  updateFromHSV() {
    this.updateUI();
  }

  rgbToHsv(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const delta = max - min;
    
    let h = 0;
    let s = max === 0 ? 0 : delta / max;
    let v = max;
    
    if (delta !== 0) {
      switch (max) {
        case r: h = (g - b) / delta + (g < b ? 6 : 0); break;
        case g: h = (b - r) / delta + 2; break;
        case b: h = (r - g) / delta + 4; break;
      }
      h /= 6;
    }
    
    return [
      Math.round(h * 360),
      Math.round(s * 100),
      Math.round(v * 100)
    ];
  }

  hsvToRgb(h, s, v) {
    h = h / 360;
    s = s / 100;
    v = v / 100;
    
    let r, g, b;
    
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    
    switch (i % 6) {
      case 0: r = v; g = t; b = p; break;
      case 1: r = q; g = v; b = p; break;
      case 2: r = p; g = v; b = t; break;
      case 3: r = p; g = q; b = v; break;
      case 4: r = t; g = p; b = v; break;
      case 5: r = v; g = p; b = q; break;
    }
    
    return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255)
    ];
  }

  updateUI() {
    const [r, g, b] = this.hsvToRgb(this.hue, this.saturation, this.brightness);
    const hex = this.rgbToHex(r, g, b);
    
    // Update wheel cursor
    const wheel = this.container.querySelector('#colorWheel');
    const wheelRect = wheel.getBoundingClientRect();
    const radius = wheelRect.width / 2;
    const angle = (this.hue * Math.PI) / 180;
    const distance = (this.saturation / 100) * radius;
    
    const x = radius + Math.cos(angle) * distance;
    const y = radius + Math.sin(angle) * distance;
    
    const cursor = this.container.querySelector('.wheel-cursor');
    cursor.style.display = 'block';
    cursor.style.left = x + 'px';
    cursor.style.top = y + 'px';
    cursor.style.color = `hsl(${this.hue}, 100%, 50%)`;
    
    // Update brightness cursor
    const brightnessControl = this.container.querySelector('#brightnessControl');
    const brightnessCursor = this.container.querySelector('.brightness-cursor');
    const brightnessPos = (this.brightness / 100) * brightnessControl.offsetWidth;
    brightnessCursor.style.left = brightnessPos + 'px';
    brightnessCursor.style.background = `rgb(${r}, ${g}, ${b})`;
    
    // Update color preview
    const preview = this.container.querySelector('#largeColorPreview');
    preview.style.background = `rgb(${r}, ${g}, ${b})`;
    
    // Update values
    this.container.querySelector('#hexValue').textContent = hex;
    this.container.querySelector('#rgbValue').textContent = `rgb(${r}, ${g}, ${b})`;
    
    this.container.querySelector('#hexInput').value = hex;
    this.container.querySelector('#redInput').value = r;
    this.container.querySelector('#greenInput').value = g;
    this.container.querySelector('#blueInput').value = b;
    this.container.querySelector('#hueInput').value = this.hue;
    this.container.querySelector('#saturationInput').value = this.saturation;
    this.container.querySelector('#valueInput').value = this.brightness;
    
    this.currentColor = hex;
  }

  rgbToHex(r, g, b) {
    return '#' + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }).join('');
  }

  isValidHex(hex) {
    return /^#?([0-9A-F]{3}){1,2}$/i.test(hex);
  }

  loadPresetColors() {
    const presets = [
      '#FF3B30', '#FF9500', '#FFCC00', '#4CD964', '#5AC8FA', '#007AFF', '#5856D6', '#FF2D55',
      '#8E8E93', '#C7C7CC', '#EFEFF4', '#000000', '#1D1D1F', '#FFFFFF', '#FFD60A', '#32D74B',
      '#64D2FF', '#0A84FF', '#5E5CE6', '#BF5AF2', '#FF375F', '#FF9F0A', '#FFD60A', '#30D158'
    ];
    
    const grid = this.container.querySelector('#presetGrid');
    grid.innerHTML = presets.map(color => `
      <div class="preset-swatch" style="background: ${color}" onclick="colorPickers.get(this.closest('.color-picker-dropdown')).selectPreset('${color}')"></div>
    `).join('');
  }

  selectPreset(color) {
    this.updateFromHex(color);
  }

  confirmColor() {
    if (this.onColorChange) {
      this.onColorChange(this.currentColor);
    }
    this.container.classList.remove('show');
  }
}

// Global color pickers manager
const colorPickers = new Map();

// ENHANCED COLOR OPTION CREATION - REPLACE EXISTING FUNCTION
// ENHANCED COLOR OPTION CREATION - FIXED VERSION
function createColorOptionWithPicker(key, label, value, mode) {
  const optionDiv = document.createElement('div');
  optionDiv.className = 'color-option1';
  
  const labelEl = document.createElement('label');
  labelEl.textContent = label;
  
  const inputContainer = document.createElement('div');
  inputContainer.className = 'color-input-container';
  
  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'color-input';
  input.value = value;
  input.dataset.colorKey = key;
  input.dataset.mode = mode;
  input.placeholder = '#000000 or color name';
  
  const pickerToggle = document.createElement('div');
  pickerToggle.className = 'color-picker-toggle';
  pickerToggle.innerHTML = '<div class="color-preview" style="background: ' + value + '"></div>';
  
  const pickerDropdown = document.createElement('div');
  pickerDropdown.className = 'color-picker-dropdown';
  
  // Create color picker instance
  const colorPicker = new AdvancedColorPicker(pickerDropdown, value, (newColor) => {
    input.value = newColor;
    const preview = pickerToggle.querySelector('.color-preview');
    preview.style.background = newColor;
    input.dispatchEvent(new Event('input', { bubbles: true }));
  });
  
  colorPickers.set(pickerDropdown, colorPicker);
  
  // Toggle picker dropdown - FIXED VERSION
  pickerToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    const isShowing = pickerDropdown.classList.contains('show');
    
    // Close all other pickers
    document.querySelectorAll('.color-picker-dropdown.show').forEach(dropdown => {
      if (dropdown !== pickerDropdown) {
        dropdown.classList.remove('show');
      }
    });
    
    if (!isShowing) {
      // Position the dropdown relative to the toggle button
      const toggleRect = pickerToggle.getBoundingClientRect();
      pickerDropdown.style.position = 'fixed';
      pickerDropdown.style.top = Math.min(toggleRect.bottom + 5, window.innerHeight - 400) + 'px';
      pickerDropdown.style.left = Math.min(toggleRect.left, window.innerWidth - 350) + 'px';
      pickerDropdown.style.zIndex = '10000';
      
      pickerDropdown.classList.add('show');
    } else {
      pickerDropdown.classList.remove('show');
    }
  });
  
  // Update input when color changes
  input.addEventListener('input', () => {
    const preview = pickerToggle.querySelector('.color-preview');
    preview.style.background = input.value;
  });
  
  inputContainer.appendChild(input);
  inputContainer.appendChild(pickerToggle);
  
  optionDiv.appendChild(labelEl);
  optionDiv.appendChild(inputContainer);
  
  // Append dropdown to body instead of toggle to avoid positioning issues
  document.body.appendChild(pickerDropdown);
  
  return optionDiv;
}
// Close color pickers when clicking outside
document.addEventListener('click', (e) => {
  if (!e.target.closest('.color-picker-toggle') && !e.target.closest('.color-picker-dropdown')) {
    document.querySelectorAll('.color-picker-dropdown.show').forEach(dropdown => {
      dropdown.classList.remove('show');
    });
  }
});

// KEEP YOUR EXISTING openColorCustomization FUNCTION BUT UPDATE IT:
function openColorCustomization(mode) {
  currentMode = mode;
  colorModalTitle.textContent = `Customize ${mode === 'dark' ? 'Dark' : 'Light'} Mode Colors`;
  
  // Clear previous options
  colorOptions.innerHTML = '';
  
  // Create color options with enhanced pickers
  const colors = customColors[mode];
  const colorLabels = {
    userBubble: 'Her Msg bubble color',
    brotherBubble: 'Your Msg bubble Color',
    chatHeader: 'Chat header background',
    inputArea: 'Input Area Color',
    messagesBg: 'Msgs area background',
    chatListBg: 'Home pg background',
    chatItemBg: 'Email box colour',
    stalkColor: 'S talk Text Color',
    bubuTextColor: 'Bubu Text Color',
    lastSeenColor: 'Last Seen Text Color',
    onlineColor: 'Online Text Color',
    typingColor: 'Typing Text Color',
    picBorderOnline: 'Pic Border (Online)',
    picBorderOffline: 'Pic Border (Offline)',
    svgColor: 'SVG Icons Color',
    brotherTextColor: 'Your Msgs Text',
    brotherTimeColor: 'Your Msgs Time',
    userTextColor: 'Her Msgs Text',
    userTimeColor: 'Her Messages Time',
    messageLinkColor: 'Message Link Color'
  };
  
  Object.keys(colors).forEach(key => {
    const optionDiv = createColorOptionWithPicker(key, colorLabels[key] || key, colors[key], mode);
    colorOptions.appendChild(optionDiv);
  });
  
  colorModal.classList.add('open');
}

// KEEP YOUR EXISTING saveColorChanges FUNCTION:
function saveColorChanges() {
  // Collect all color values from enhanced inputs
  const inputs = colorOptions.querySelectorAll('.color-input');
  inputs.forEach(input => {
    const key = input.dataset.colorKey;
    const value = input.value.trim();
    const mode = input.dataset.mode;
    
    // Only update if value is not empty
    if (value) {
      customColors[mode][key] = value;
    }
  });
  
  // Save to localStorage
  localStorage.setItem('customColors', JSON.stringify(customColors));
  
  // Apply the changes
  applyCustomColors(currentMode);
  
  // Close modal
  colorModal.classList.remove('open');
}

// Update the event listener for save button
saveColorBtn.addEventListener('click', saveColorChanges);

function updatePseudoElementStyles(mode, colors) {
  // Remove existing style element if it exists
  const existingStyle = document.getElementById('custom-colors-style');
  if (existingStyle) {
    existingStyle.remove();
  }
  
  // Create new style element
  const style = document.createElement('style');
  style.id = 'custom-colors-style';
  
  // Add comprehensive styles for all elements
  style.textContent = `
  
${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .message-link {
color: ${colors.messageLinkColor} !important;
}
${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .reply-box a,
${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .reply-preview-text a {
color: ${colors.messageLinkColor} !important;
}

/* For the opposite mode */
${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .message-link {
color: ${colors.messageLinkColor} !important;
}
${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .reply-box a,
${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .reply-preview-text a {
color: ${colors.messageLinkColor} !important;
}


  
  
  
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #inboxHeader {
      color: ${colors.stalkColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #chatTitle {
      color: ${colors.bubuTextColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #typingIndicator {
      color: ${colors.lastSeenColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .from-user {
      background: ${colors.userBubble} !important;
      color: ${colors.userTextColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .from-user::after {
      background: ${colors.userBubble} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .from-brother {
      background: ${colors.brotherBubble} !important;
      color: ${colors.brotherTextColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .from-brother::after {
      background: ${colors.brotherBubble} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #chatHeader {
      background: ${colors.chatHeader} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #chat {
      background: ${colors.chatHeader} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #inputControls {
      background: ${colors.inputArea} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #sendBtn {
      background: ${colors.inputArea} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #messages {
      background: ${colors.messagesBg} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} #list {
      background: ${colors.chatListBg} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .chat-item {
      background: ${colors.chatItemBg} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} body {
      color: ${colors.textColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .chat-preview {
      color: ${colors.previewText} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} svg {
      stroke: ${colors.svgColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .from-user .msg-time {
      color: ${colors.userTimeColor} !important;
    }
    ${mode === 'dark' ? 'body.dark' : 'body:not(.dark)'} .from-brother .msg-time {
      color: ${colors.brotherTimeColor} !important;
    }
    
    /* Light mode specific overrides */
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #inboxHeader {
      color: ${colors.stalkColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #chatTitle {
      color: ${colors.bubuTextColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #typingIndicator {
      color: ${colors.lastSeenColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .from-user {
      background: ${colors.userBubble} !important;
      color: ${colors.userTextColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .from-user::after {
      background: ${colors.userBubble} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .from-brother {
      background: ${colors.brotherBubble} !important;
      color: ${colors.brotherTextColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .from-brother::after {
      background: ${colors.brotherBubble} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #chatHeader {
      background: ${colors.chatHeader} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #chat {
      background: ${colors.chatHeader} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #inputControls {
      background: ${colors.inputArea} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #sendBtn {
      background: ${colors.inputArea} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #messages {
      background: ${colors.messagesBg} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} #list {
      background: ${colors.chatListBg} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .chat-item {
      background: ${colors.chatItemBg} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} body {
      color: ${colors.textColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .chat-preview {
      color: ${colors.previewText} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} svg {
      stroke: ${colors.svgColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .from-user .msg-time {
      color: ${colors.userTimeColor} !important;
    }
    ${mode !== 'dark' ? 'body:not(.dark)' : 'body.dark'} .from-brother .msg-time {
      color: ${colors.brotherTimeColor} !important;
    }
  `;
  
  document.head.appendChild(style);
}
// Function to update profile picture border based on status
// Function to update profile picture border based on status
function updateProfilePictureBorder(isOnline) {
  const userLogo = document.getElementById('userLogo');
  if (userLogo) {
    const currentMode = document.body.classList.contains('dark') ? 'dark' : 'light';
    const colors = customColors[currentMode];
    userLogo.style.border = `3px solid ${isOnline ? colors.picBorderOnline : colors.picBorderOffline}`;
  }
}
// Apply custom colors to the UI
// Apply custom colors to the UI - FIXED VERSION
// Apply custom colors to the UI - SIMPLIFIED VERSION
function applyCustomColors(mode) {
  const colors = customColors[mode];
  
  // Set dark mode class
  if (mode === 'dark') {
    document.body.classList.add('dark');
  } else {
    document.body.classList.remove('dark');
  }
  
  // Update all styles via CSS
  updatePseudoElementStyles(mode, colors);
  
  // Update theme color meta tag
  updateThemeColor();
  
  // Force a re-render of any existing messages
  if (currentKey && Object.keys(messageStore).length > 0) {
    const tempStore = { ...messageStore };
    messageStore = {};
    messagesEl.innerHTML = '';
    lastRenderedDate = null;
    processAndRenderMessages(tempStore);
  }
}
// Update the reset background button to reset everything
document.addEventListener('DOMContentLoaded', function() {
  const resetBackgroundBtn = document.getElementById('resetBackgroundBtn');
  
  if (resetBackgroundBtn) {
    // Remove any existing event listeners
    resetBackgroundBtn.replaceWith(resetBackgroundBtn.cloneNode(true));
    const newResetBtn = document.getElementById('resetBackgroundBtn');
    
    newResetBtn.addEventListener('click', function() {
      if (confirm('Are you sure you want to reset ALL backgrounds (chat background, home background, and profile picture) to default?')) {
        // 1. Reset Chat Background
        resetChatBackground();
        
        // 2. Reset Home Background
        resetHomeBackground();
        
        // 3. Reset Profile Picture (DP)
        resetProfilePicture();
        
        // Close the modal
        closeBackgroundPicker();
        
        alert('All backgrounds and profile picture have been reset to default!');
      }
    });
  }
});

// Function to reset chat background (your existing function)
function resetChatBackground() {
  const messagesEl = document.getElementById('messages');
  
  // Remove custom background class
  messagesEl.classList.remove('custom-background');
  
  // Remove inline styles
  messagesEl.removeAttribute('style');
  
  // Remove custom background styles
  const existingStyle = document.getElementById('custom-background-style');
  if (existingStyle) {
    existingStyle.remove();
  }
  
  // Remove from localStorage
  localStorage.removeItem('chatBackground');
  
  console.log('Chat background reset to default');
}

// Function to reset home background
function resetHomeBackground() {
  console.log('Resetting home background...');
  
  const listEl = document.getElementById('list');
  
  // Remove the home background style
  const existingStyle = document.getElementById('home-background-style');
  if (existingStyle) {
    existingStyle.remove();
    console.log('Removed home background style');
  }
  
  // Remove the applied class
  listEl.classList.remove('home-background-applied');
  
  // Remove from localStorage
  localStorage.removeItem('homeBackground');
  
  // Force reflow
  void listEl.offsetWidth;
  
  // Restore default colors
  const currentMode = document.body.classList.contains('dark') ? 'dark' : 'light';
  applyCustomColors(currentMode);
  
  console.log('Home background reset complete');
}

// Function to reset profile picture (DP)
function resetProfilePicture() {
  const userLogo = document.getElementById('userLogo');
  if (userLogo) {
    // Reset to default logo
    userLogo.src = 'chat_logo.png';
    // Remove from localStorage
    localStorage.removeItem('userProfilePicture');
    console.log('Profile picture reset to default');
  }
}
// Reset all colors to default
function resetColorsToDefault() {
  if (confirm('Are you sure you want to reset all colors to default?')) {
    customColors = {
      light: {...defaultColors.light},
      dark: {...defaultColors.dark}
    };
    
    localStorage.setItem('customColors', JSON.stringify(customColors));
    
    // Apply default colors based on current mode
    const currentMode = document.body.classList.contains('dark') ? 'dark' : 'light';
    applyCustomColors(currentMode);
    
    alert('Colors have been reset to default.');
  }
}

// Update theme color meta tag
function updateThemeColor() {
  const themeMeta = document.getElementById('theme-color-meta');
  const currentMode = document.body.classList.contains('dark') ? 'dark' : 'light';
  
  if (currentMode === 'dark') {
    themeMeta.setAttribute('content', customColors.dark.chatHeader);
  } else {
    themeMeta.setAttribute('content', customColors.light.chatHeader);
  }
}

// Initialize colors on page load
document.addEventListener('DOMContentLoaded', () => {
  // Check if dark mode is enabled
  if (localStorage.getItem('darkMode') === 'enabled') {
    document.body.classList.add('dark');
  }
  
  // Apply custom colors
  const currentMode = document.body.classList.contains('dark') ? 'dark' : 'light';
  applyCustomColors(currentMode);
});

// Initialize profile picture border on page load
document.addEventListener('DOMContentLoaded', function() {
  // Set initial border color (offline by default)
  updateProfilePictureBorder(false);
});
</script>
  <!-- Add this to your existing HTML, preferably near the other modals -->
<div id="advancedSettingsModal" class="color-modal" aria-hidden="true">
  <div class="color-modal-content">
    <h3 id="advancedSettingsTitle" style="margin-bottom: 20px;">Advanced Settings</h3>
    
    <div class="settings-tabs">
      <button class="tab-btn active" data-tab="sizes">Sizes</button>
      <button class="tab-btn" data-tab="animations">Animations</button>
      <button class="tab-btn" data-tab="layout">Layout</button>
    </div>
    
    <div id="sizesTab" class="tab-content active">
      <div class="settings-group">
        <h4>Header Text Sizes</h4>
        <div class="setting-item">
          <label>Stalk Text Size</label>
          <input type="number" id="stalkSize" min="10" max="40" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Bubu Text Size</label>
          <input type="number" id="bubuSize" min="10" max="30" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Status Text Size</label>
          <input type="number" id="statusSize" min="8" max="20" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
      </div>
      
      <div class="settings-group">
        <h4>Message Text Sizes</h4>
        <div class="setting-item">
          <label>User Message Text</label>
          <input type="number" id="userTextSize" min="12" max="24" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>User Message Time</label>
          <input type="number" id="userTimeSize" min="8" max="16" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Brother Message Text</label>
          <input type="number" id="brotherTextSize" min="12" max="24" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Brother Message Time</label>
          <input type="number" id="brotherTimeSize" min="8" max="16" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
      </div>
      
      <div class="settings-group">
        <h4>Chat List Sizes</h4>
        <div class="setting-item">
          <label>Chat Name Size</label>
          <input type="number" id="chatNameSize" min="12" max="24" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Chat Preview Size</label>
          <input type="number" id="chatPreviewSize" min="10" max="20" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
      </div>
    </div>
    
<div id="animationsTab" class="tab-content">
  <div class="settings-group">
    <h4>Message Animations</h4>
    <div class="setting-item">
      <label>Animation Duration</label>
      <input type="number" id="animationDuration" min="0.1" max="2" step="0.1" class="size-input">
      <span class="unit">s</span>
    </div>
    <div class="setting-item">
      <label>Animation Type</label>
      <select id="animationType">
        <option value="bubblePop">Bubble Pop</option>
        <option value="fadeIn">Fade In</option>
        <option value="slideUp">Slide Up</option>
        <option value="slideInLeft">Slide In Left</option>
        <option value="slideInRight">Slide In Right</option>
        <option value="bounce">Bounce</option>
        <option value="flip">Flip</option>
        <option value="zoom">Zoom</option>
        <option value="typewriter">Typewriter</option>
        <option value="wave">Wave Effect</option>
        <option value="pulse">Pulse</option>
        <option value="shake">Shake</option>
        <option value="swing">Swing</option>
        <option value="tada">Tada</option>
        <option value="wobble">Wobble</option>
        <option value="jello">Jello</option>
        <option value="heartbeat">Heartbeat</option>
        <option value="rubberBand">Rubber Band</option>
        <option value="lightSpeed">Light Speed</option>
        <option value="rollIn">Roll In</option>
        <option value="rotateIn">Rotate In</option>
        <option value="none">None</option>
      </select>
    </div>
    <div class="setting-item" style="display:none">
      <label>Highlight Duration</label>
      <input type="number" id="highlightDuration" min="0.5" max="5" step="0.5" class="size-input">
      <span class="unit">s</span>
    </div>
  </div>
  
  <!-- HEARTS CUSTOMIZATION SECTION -->
  <div class="settings-group" style="margin-top: 30px; padding-top: 20px;">
    <h4>💖 Hearts Animation</h4>
    
    <div class="setting-item">
      <label>Enable Hearts</label>
      <input type="checkbox" id="enableHearts" checked>
    </div>
    
    <div class="setting-item">
      <label>Animation Type</label>
      <select id="heartAnimationType">
        <option value="fall">Falling</option>
        <option value="rise">Rising</option>
        <option value="float">Floating</option>
        <option value="explosion">Explosion</option>
        <option value="spiral">Spiral</option>
      </select>
    </div>
    
    <div class="setting-item">
      <label>Duration</label>
      <input type="number" id="heartAnimationDuration" min="1" max="10" step="0.5" value="3" class="size-input">
      <span class="unit">s</span>
    </div>
    
    <div class="setting-item" style="display: none;">
      <label>Quantity</label>
      <input type="number" id="heartQuantity" min="5" max="100" step="5" value="25" class="size-input">
      <span class="unit">hrt</span>
    </div>
    
    <div class="setting-item">
      <label>Min Size</label>
      <input type="number" id="heartMinSize" min="10" max="50" step="2" value="20" class="size-input">
      <span class="unit">px</span>
    </div>
    
    <div class="setting-item">
      <label>Max Size</label>
      <input type="number" id="heartMaxSize" min="20" max="100" step="5" value="35" class="size-input">
      <span class="unit">px</span>
    </div>
    

  </div>
  
  <div class="settings-group">
    <h4>Custom Words</h4>
    <div id="customWordsContainer">
      <div class="custom-word-item" style="display: flex; gap: 8px; margin-bottom: 8px; padding: 8px;  border-radius: 6px;">
        <input type="text" class="custom-word" value="love" placeholder="Word" style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
        <input type="text" class="custom-emoji" value="❤️" placeholder="Emoji" maxlength="5" style="width: 60px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
        <input type="number" class="custom-quantity" value="25" min="5" max="100" style="width: 70px; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
        <button onclick="removeCustomWord(0)" style="background: #ef4444; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer;">×</button>
      </div>
      <div class="custom-word-item" style="display: flex; gap: 8px; margin-bottom: 8px; padding: 8px; background: #f8f9fa; border-radius: 6px;">
        <input type="text" class="custom-word" value="bubu" placeholder="Word" style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
        <input type="text" class="custom-emoji" value="😘" placeholder="Emoji" maxlength="5" style="width: 60px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
        <input type="number" class="custom-quantity" value="30" min="5" max="100" style="width: 70px; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
        <button onclick="removeCustomWord(1)" style="background: #ef4444; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer;">×</button>
      </div>
    </div>
    
    <button onclick="addCustomWord()" style="background: #2563eb; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; margin-top: 10px;">+ Add Word</button>
  </div>
  
  
  <div class="settings-group" style="display: none;">
    <h4>Colors</h4>
    <div class="setting-item">
      <label>Color Theme</label>
      <select id="heartColorTheme" onchange="toggleCustomColors()">
        <option value="random">Random</option>
        <option value="reds">Reds</option>
        <option value="pinks">Pinks</option>
        <option value="rainbow">Rainbow</option>
        <option value="custom">Custom</option>
      </select>
    </div>
    
    <div id="customColorsContainer" style="display: none; margin-top: 10px;">
      <div class="setting-item">
        <label>Color 1</label>
        <input type="color" id="customColor1" value="#ff4081">
      </div>
      <div class="setting-item">
        <label>Color 2</label>
        <input type="color" id="customColor2" value="#f44336">
      </div>
      <div class="setting-item">
        <label>Color 3</label>
        <input type="color" id="customColor3" value="#e91e63">
      </div>
    </div>
  </div>
  
  <div class="settings-group">
    <h4>Triggers</h4>
    <div class="setting-item">
      <label>On Send</label>
      <input type="checkbox" id="triggerOnSend" checked>
    </div>
    <div class="setting-item">
      <label>On Receive</label>
      <input type="checkbox" id="triggerOnReceive" checked>
    </div>
    <div class="setting-item">
      <label>Cooldown</label>
      <input type="number" id="heartCooldown" min="1" max="30" step="1" value="3" class="size-input">
      <span class="unit">s</span>
    </div>
  </div>
  
  <div class="settings-group">
    <h4>Test</h4>
    <button onclick="previewHeartsAnimation()" style="background: #10B981; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; margin-right: 10px;">Preview</button>
    <button onclick="testAllCustomWords()" style="background: #8B5CF6; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer;">Test All</button>
  </div>
</div>

    <div id="layoutTab" class="tab-content">
      <div class="settings-group">
        <h4>Border Radius</h4>
        <div class="setting-item">
          <label>Messages Container</label>
          <input type="number" id="messagesRadius" min="0" max="50" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Message Bubbles</label>
          <input type="number" id="bubbleRadius" min="0" max="30" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Input Area</label>
          <input type="number" id="inputRadius" min="0" max="30" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Chat Items</label>
          <input type="number" id="chatItemRadius" min="0" max="30" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
      </div>
      
      <div class="settings-group">
        <h4>Message Width</h4>
        <div class="setting-item">
          <label>Max Message Width</label>
          <input type="number" id="messageMaxWidth" min="50" max="90" step="1" class="size-input">
          <span class="unit">%</span>
        </div>
      </div>
      
      <div class="settings-group">
        <h4>Spacing</h4>
        <div class="setting-item">
          <label>Message Spacing</label>
          <input type="number" id="messageSpacing" min="2" max="20" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
        <div class="setting-item">
          <label>Input Area Height</label>
          <input type="number" id="inputHeight" min="40" max="120" step="1" class="size-input">
          <span class="unit">px</span>
        </div>
      </div>
    </div>
    
    <div class="modal-actions">
      <button class="modal-btn secondary" id="cancelAdvancedBtn">Cancel</button>
      <button class="modal-btn secondary" id="resetAdvancedBtn">Reset to Default</button>
      <button class="modal-btn primary" id="saveAdvancedBtn">Save Changes</button>
    </div>
  </div>
  
</div>

<style>


  /* Settings Tabs */
.settings-tabs {
  display: flex;
  border-bottom: 1px solid #ccc;
  margin-bottom: 20px;
}

.tab-btn {

  flex: 1;
  padding: 10px;
  background: none;
  border: none;
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.2s;
}

.tab-btn.active {
  border-bottom: 2px solid #2563eb;
  font-weight: bold;
}

.tab-content {
  display: none;
  max-height: 50vh;
  overflow-y: auto;
}

.tab-content.active {
  display: block;
}

/* Settings Groups */
.settings-group {
  margin-bottom: 25px;
  padding-bottom: 15px;
  border-bottom: 1px solid #eee;
}

.settings-group h4 {
  margin-bottom: 15px;
  color: #2563eb;
  font-size: 16px;
}

.setting-item {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
  gap: 10px;
}

.setting-item label {
  flex: 1;
  min-width: 160px;
  font-size: 14px;
}

.size-input, .setting-item select {
  background: #DDF2ED;
  width: 80px;
  padding: 6px 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
}

.unit {
  width: 30px;
  font-size: 14px;
  color: #666;
}

/* Dark mode adjustments */
body.dark .settings-group {
  border-bottom-color: #2A3A36;
}

body.dark .settings-group h4 {
  color: #5ac8fa;
}
body.dark .tab-btn{
  color:#B7CAC6;
}

body.dark .size-input, 
body.dark .setting-item select {
  background: #061613;
  color: #B7CAC6;
  border-color: #2A3A36;
}

body.dark .unit {
  color: #B7CAC6;
}
</style>

<script>
// Advanced settings functionality
const advancedSettingsModal = document.getElementById('advancedSettingsModal');
const cancelAdvancedBtn = document.getElementById('cancelAdvancedBtn');
const saveAdvancedBtn = document.getElementById('saveAdvancedBtn');
const resetAdvancedBtn = document.getElementById('resetAdvancedBtn');

// Default settings values
const defaultSettings = {
  // Sizes
  stalkSize: 28,
  bubuSize: 18,
  statusSize: 12,
  userTextSize: 18,
  userTimeSize: 10,
  brotherTextSize: 18,
  brotherTimeSize: 10,
  chatNameSize: 16,
  chatPreviewSize: 14,
  
  // Animations
  animationDuration: 0.3,
  animationType: 'bubblePop',
  highlightDuration: 2.2,
  
  // Layout
  messagesRadius: 33,
  bubbleRadius: 16,
  inputRadius: 24,
  chatItemRadius: 16,
  messageMaxWidth: 75,
  messageSpacing: 6,
  inputHeight: 52
};

// Load settings from localStorage or use defaults
let currentSettings = JSON.parse(localStorage.getItem('advancedSettings')) || {...defaultSettings};

// Tab functionality
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    // Remove active class from all tabs and contents
    document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    // Add active class to clicked tab and corresponding content
    btn.classList.add('active');
    const tabId = btn.dataset.tab + 'Tab';
    document.getElementById(tabId).classList.add('active');
  });
});

// Open advanced settings
function openAdvancedSettings() {
  // Populate form with current settings
  populateSettingsForm();
  advancedSettingsModal.classList.add('open');
}

// Populate form with current settings
function populateSettingsForm() {
  // Sizes
  document.getElementById('stalkSize').value = currentSettings.stalkSize;
  document.getElementById('bubuSize').value = currentSettings.bubuSize;
  document.getElementById('statusSize').value = currentSettings.statusSize;
  document.getElementById('userTextSize').value = currentSettings.userTextSize;
  document.getElementById('userTimeSize').value = currentSettings.userTimeSize;
  document.getElementById('brotherTextSize').value = currentSettings.brotherTextSize;
  document.getElementById('brotherTimeSize').value = currentSettings.brotherTimeSize;
  document.getElementById('chatNameSize').value = currentSettings.chatNameSize;
  document.getElementById('chatPreviewSize').value = currentSettings.chatPreviewSize;
  
  // Animations
  document.getElementById('animationDuration').value = currentSettings.animationDuration;
  document.getElementById('animationType').value = currentSettings.animationType;
  document.getElementById('highlightDuration').value = currentSettings.highlightDuration;
  
  // Layout
  document.getElementById('messagesRadius').value = currentSettings.messagesRadius;
  document.getElementById('bubbleRadius').value = currentSettings.bubbleRadius;
  document.getElementById('inputRadius').value = currentSettings.inputRadius;
  document.getElementById('chatItemRadius').value = currentSettings.chatItemRadius;
  document.getElementById('messageMaxWidth').value = currentSettings.messageMaxWidth;
  document.getElementById('messageSpacing').value = currentSettings.messageSpacing;
  document.getElementById('inputHeight').value = currentSettings.inputHeight;
}

// Save advanced settings
function saveAdvancedSettings() {
  // Collect all settings from form
  const newSettings = {
    // Sizes
    stalkSize: parseInt(document.getElementById('stalkSize').value) || defaultSettings.stalkSize,
    bubuSize: parseInt(document.getElementById('bubuSize').value) || defaultSettings.bubuSize,
    statusSize: parseInt(document.getElementById('statusSize').value) || defaultSettings.statusSize,
    userTextSize: parseInt(document.getElementById('userTextSize').value) || defaultSettings.userTextSize,
    userTimeSize: parseInt(document.getElementById('userTimeSize').value) || defaultSettings.userTimeSize,
    brotherTextSize: parseInt(document.getElementById('brotherTextSize').value) || defaultSettings.brotherTextSize,
    brotherTimeSize: parseInt(document.getElementById('brotherTimeSize').value) || defaultSettings.brotherTimeSize,
    chatNameSize: parseInt(document.getElementById('chatNameSize').value) || defaultSettings.chatNameSize,
    chatPreviewSize: parseInt(document.getElementById('chatPreviewSize').value) || defaultSettings.chatPreviewSize,
    
    // Animations
    animationDuration: parseFloat(document.getElementById('animationDuration').value) || defaultSettings.animationDuration,
    animationType: document.getElementById('animationType').value || defaultSettings.animationType,
    highlightDuration: parseFloat(document.getElementById('highlightDuration').value) || defaultSettings.highlightDuration,
    
    // Layout
    messagesRadius: parseInt(document.getElementById('messagesRadius').value) || defaultSettings.messagesRadius,
    bubbleRadius: parseInt(document.getElementById('bubbleRadius').value) || defaultSettings.bubbleRadius,
    inputRadius: parseInt(document.getElementById('inputRadius').value) || defaultSettings.inputRadius,
    chatItemRadius: parseInt(document.getElementById('chatItemRadius').value) || defaultSettings.chatItemRadius,
    messageMaxWidth: parseInt(document.getElementById('messageMaxWidth').value) || defaultSettings.messageMaxWidth,
    messageSpacing: parseInt(document.getElementById('messageSpacing').value) || defaultSettings.messageSpacing,
    inputHeight: parseInt(document.getElementById('inputHeight').value) || defaultSettings.inputHeight
  };
  
  // Update current settings
  currentSettings = {...newSettings};
  
  // Save to localStorage
  localStorage.setItem('advancedSettings', JSON.stringify(currentSettings));
  
  // Apply the settings
  applyAdvancedSettings();
  
  // Close modal
  advancedSettingsModal.classList.remove('open');
}

// Reset to default settings
function resetAdvancedSettings() {
  if (confirm('Are you sure you want to reset all advanced settings to default?')) {
    currentSettings = {...defaultSettings};
    localStorage.setItem('advancedSettings', JSON.stringify(currentSettings));
    applyAdvancedSettings();
    populateSettingsForm();
    alert('Advanced settings have been reset to default.');
  }
}

// Apply advanced settings to the UI
function applyAdvancedSettings() {
  // Remove existing style element if it exists
  const existingStyle = document.getElementById('advanced-settings-style');
  if (existingStyle) {
    existingStyle.remove();
  }
  
  // Create new style element
  const style = document.createElement('style');
  style.id = 'advanced-settings-style';
  
  // Build CSS based on current settings
  let css = `
    /* Header Text Sizes */
    #inboxHeader {
      font-size: ${currentSettings.stalkSize}px !important;
    }
    #chatTitle {
      font-size: ${currentSettings.bubuSize}px !important;
    }
    #typingIndicator {
      font-size: ${currentSettings.statusSize}px !important;
    }
    
    /* Message Text Sizes */
    .from-user > div:not(.reply-box):not(.msg-time) {
      font-size: ${currentSettings.userTextSize}px !important;
    }
    .from-user .msg-time {
      font-size: ${currentSettings.userTimeSize}px !important;
    }
    .from-brother > div:not(.reply-box):not(.msg-time) {
      font-size: ${currentSettings.brotherTextSize}px !important;
    }
    .from-brother .msg-time {
      font-size: ${currentSettings.brotherTimeSize}px !important;
    }
    
    /* Chat List Sizes */
    .chat-name {
      font-size: ${currentSettings.chatNameSize}px !important;
    }
    .chat-preview {
      font-size: ${currentSettings.chatPreviewSize}px !important;
    }
    
    /* Layout Settings */
    #messages {
      border-top-left-radius: ${currentSettings.messagesRadius}px !important;
      border-top-right-radius: ${currentSettings.messagesRadius}px !important;
    }
    .bubble {
      border-radius: ${currentSettings.bubbleRadius}px !important;
      max-width: ${currentSettings.messageMaxWidth}% !important;
      margin: ${currentSettings.messageSpacing}px 0 !important;
    }
    #inputControls {
      border-radius: ${currentSettings.inputRadius}px !important;
      min-height: ${currentSettings.inputHeight}px !important;
    }
    .chat-item {
      border-radius: ${currentSettings.chatItemRadius}px !important;
    }
    
    /* Animation Settings */
    .bubble {
      animation-duration: ${currentSettings.animationDuration}s !important;
    }
    .message-highlight {
      animation-duration: ${currentSettings.highlightDuration}s !important;
    }
  `;
  
  // Add animation-specific styles
  if (currentSettings.animationType === 'fadeIn') {
    css += `
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      .bubble {
        animation-name: fadeIn !important;
      }
    `;
  } else if (currentSettings.animationType === 'slideUp') {
    css += `
      @keyframes slideUp {
        from { 
          opacity: 0;
          transform: translateY(20px);
        }
        to { 
          opacity: 1;
          transform: translateY(0);
        }
      }
      .bubble {
        animation-name: slideUp !important;
      }
    `;
  } else if (currentSettings.animationType === 'none') {
    css += `
      .bubble {
        animation: none !important;
      }
    `;
  }
  
  style.textContent = css;
  document.head.appendChild(style);
  
  // Update bubble tail positions based on new radius
  updateBubbleTails();
}

// Update bubble tail positions based on current border radius
function updateBubbleTails() {
  // Remove existing tail styles
  const existingTailStyle = document.getElementById('bubble-tail-style');
  if (existingTailStyle) {
    existingTailStyle.remove();
  }
  
  const tailStyle = document.createElement('style');
  tailStyle.id = 'bubble-tail-style';
  
  const tailSize = 12;
  const borderRadius = currentSettings.bubbleRadius;
  
  tailStyle.textContent = `
    .from-user::after {
      border-bottom-left-radius: ${Math.min(borderRadius / 4, 4)}px !important;
    }
    .from-brother::after {
      border-bottom-right-radius: ${Math.min(borderRadius / 4, 4)}px !important;
    }
  `;
  
  document.head.appendChild(tailStyle);
}

// Event listeners
cancelAdvancedBtn.addEventListener('click', () => {
  advancedSettingsModal.classList.remove('open');
});

saveAdvancedBtn.addEventListener('click', saveAdvancedSettings);

resetAdvancedBtn.addEventListener('click', resetAdvancedSettings);

// Initialize settings on page load
document.addEventListener('DOMContentLoaded', () => {
  applyAdvancedSettings();
});

// Add this menu item to your existing settings menu HTML:
// <div class="menu-item" data-action="advanced-settings">⚙️ Advanced Settings</div>

// And add this event listener to handle the new menu item:
document.addEventListener('click', (e) => {
  if (e.target.dataset.action === 'advanced-settings') {
    openAdvancedSettings();
  }
});
</script>

<script>
// Enhanced Animation System - FIXED VERSION
function applyMessageAnimation(bubble, animationType, duration, isUser) {
  const animationClasses = [
    'animate-fadeIn', 'animate-slideUp', 'animate-slideInLeft', 'animate-slideInRight',
    'animate-bounce', 'animate-flip', 'animate-zoom', 'animate-wave', 'animate-pulse',
    'animate-shake', 'animate-swing', 'animate-tada', 'animate-wobble', 'animate-jello',
    'animate-heartbeat', 'animate-rubberBand', 'animate-lightSpeed', 'animate-rollIn', 'animate-rotateIn'
  ];
  
  bubble.classList.remove(...animationClasses);
  
  if (animationType !== 'none') {
    bubble.classList.add(`animate-${animationType}`);
    bubble.style.animationDuration = `${duration}s`;
    
    // Special handling for directional animations
    if ((animationType === 'slideInLeft' && !isUser) || 
        (animationType === 'slideInRight' && isUser)) {
      bubble.classList.remove(`animate-${animationType}`);
      bubble.classList.add(`animate-${animationType === 'slideInLeft' ? 'slideInRight' : 'slideInLeft'}`);
    }
    
    applySpecialEffects(bubble);
  }
}
// Function to reset home background


// Add event listener for reset
document.addEventListener('click', (e) => {
  if (e.target.dataset.action === 'reset-home-background') {
    resetHomeBackground();
  }
});
function applySpecialEffects(bubble) {
  const settings = getCurrentAnimationSettings();
  
  bubble.classList.remove('ripple-effect', 'glow-effect', 'float-effect');
  
  if (settings.particleEffects) {
    createParticleEffect(bubble);
  }
  
  if (settings.rippleEffect) {
    bubble.classList.add('ripple-effect');
  }
  
  if (settings.glowEffect) {
    bubble.classList.add('glow-effect');
  }
  
  if (settings.floatingAnimation) {
    bubble.classList.add('float-effect');
  }
}

function createParticleEffect(element) {
  const rect = element.getBoundingClientRect();
  const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
  
  for (let i = 0; i < 8; i++) {
    setTimeout(() => {
      const particle = document.createElement('div');
      particle.style.cssText = `
        position: fixed;
        width: 6px;
        height: 6px;
        background: ${colors[Math.floor(Math.random() * colors.length)]};
        border-radius: 50%;
        pointer-events: none;
        z-index: 1000;
        left: ${rect.left + rect.width / 2}px;
        top: ${rect.top + rect.height / 2}px;
      `;
      
      document.body.appendChild(particle);
      
      const angle = Math.random() * Math.PI * 2;
      const distance = 20 + Math.random() * 30;
      const duration = 0.5 + Math.random() * 0.5;
      
      particle.animate([
        { transform: 'translate(0, 0) scale(1)', opacity: 1 },
        { transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`, opacity: 0 }
      ], {
        duration: duration * 1000,
        easing: 'cubic-bezier(0.215, 0.610, 0.355, 1.000)'
      }).onfinish = () => particle.remove();
    }, i * 50);
  }
}

function applyChatItemAnimation(chatItem, animationType, duration) {
  if (animationType !== 'none') {
    chatItem.classList.add(`animate-${animationType}`);
    chatItem.style.animationDuration = `${duration}s`;
  }
}

function applyUnreadPulseEffect(badge) {
  const settings = getCurrentAnimationSettings();
  if (settings.unreadPulse) {
    badge.classList.add('pulse-effect');
  } else {
    badge.classList.remove('pulse-effect');
  }
}

function getCurrentAnimationSettings() {
  return {
    animationType: currentSettings.animationType,
    animationDuration: currentSettings.animationDuration,
    staggerMessages: currentSettings.staggerMessages,
    staggerDelay: currentSettings.staggerDelay,
    particleEffects: currentSettings.particleEffects,
    rippleEffect: currentSettings.rippleEffect,
    glowEffect: currentSettings.glowEffect,
    floatingAnimation: currentSettings.floatingAnimation,
    chatItemAnimation: currentSettings.chatItemAnimation,
    unreadPulse: currentSettings.unreadPulse
  };
}

// Override the buildMessageBubble function to include animations
const originalBuildMessageBubble = window.buildMessageBubble;
window.buildMessageBubble = function(msgKey, val) {
  const div = originalBuildMessageBubble(msgKey, val);
  
  const settings = getCurrentAnimationSettings();
  const isUser = val.from === 'user';
  
  // Apply animation
  if (settings.animationType !== 'none') {
    applyMessageAnimation(div, settings.animationType, settings.animationDuration, isUser);
  }
  
  // Apply stagger effect if enabled
  if (settings.staggerMessages) {
    const index = Object.keys(messageStore).indexOf(msgKey);
    div.style.animationDelay = `${index * settings.staggerDelay}s`;
  }
  
  // Handle typewriter animation
  if (settings.animationType === 'typewriter' && val.text) {
    handleTypewriterAnimation(div, val, settings);
  }
  
  return div;
};

// Override renderChatsOptimized to include chat item animations
const originalRenderChatsOptimized = renderChatsOptimized;
renderChatsOptimized = function(chatListData) {
  originalRenderChatsOptimized(chatListData);
  
  const settings = getCurrentAnimationSettings();
  const chatItems = document.querySelectorAll('.chat-item');
   
  chatItems.forEach((item, index) => {
    if (settings.chatItemAnimation !== 'none') {
      applyChatItemAnimation(item, settings.chatItemAnimation, 0.5);
      item.style.animationDelay = `${index * 0.1}s`;
    }
    
    // Apply unread pulse effect
    const badge = item.querySelector('.unread-badge');
    if (badge) {
      applyUnreadPulseEffect(badge);
    }
  });
};

// Typewriter animation handler
function applyTypewriterAnimation(element, text, duration) {
  const originalText = element.textContent;
  element.textContent = '';
  element.style.overflow = 'hidden';
  element.style.whiteSpace = 'nowrap';
  element.style.borderRight = '2px solid';
  
  const length = text.length;
  const interval = duration / length;
  let i = 0;
  
  const typeInterval = setInterval(() => {
    if (i < length) {
      element.textContent += text.charAt(i);
      i++;
    } else {
      clearInterval(typeInterval);
      setTimeout(() => {
        element.style.borderRight = 'none';
        element.style.whiteSpace = 'normal';
        element.style.overflow = 'visible';
      }, 500);
    }
  }, interval);
}

function handleTypewriterAnimation(div, val, settings) {
  const textElement = div.querySelector('div:not(.reply-box):not(.msg-time)');
  if (textElement) {
    const text = textElement.textContent;
    textElement.textContent = '';
    setTimeout(() => {
      applyTypewriterAnimation(textElement, text, settings.animationDuration);
    }, 100);
  }
}

// Enhanced applyAdvancedSettings function
function applyAdvancedSettings() {
  const existingStyle = document.getElementById('advanced-settings-style');
  if (existingStyle) {
    existingStyle.remove();
  }
  
  const style = document.createElement('style');
  style.id = 'advanced-settings-style';
  
  let css = `
    /* Header Text Sizes */
    #inboxHeader {
      font-size: ${currentSettings.stalkSize}px !important;
    }
    #chatTitle {
      font-size: ${currentSettings.bubuSize}px !important;
    }
    #typingIndicator {
      font-size: ${currentSettings.statusSize}px !important;
    }
    
    /* Message Text Sizes */
    .from-user > div:not(.reply-box):not(.msg-time) {
      font-size: ${currentSettings.userTextSize}px !important;
    }
    .from-user .msg-time {
      font-size: ${currentSettings.userTimeSize}px !important;
    }
    .from-brother > div:not(.reply-box):not(.msg-time) {
      font-size: ${currentSettings.brotherTextSize}px !important;
    }
    .from-brother .msg-time {
      font-size: ${currentSettings.brotherTimeSize}px !important;
    }
    
    /* Chat List Sizes */
    .chat-name {
      font-size: ${currentSettings.chatNameSize}px !important;
    }
    .chat-preview {
      font-size: ${currentSettings.chatPreviewSize}px !important;
    }
    
    /* Layout Settings */
    #messages {
      border-top-left-radius: ${currentSettings.messagesRadius}px !important;
      border-top-right-radius: ${currentSettings.messagesRadius}px !important;
    }
    .bubble {
      border-radius: ${currentSettings.bubbleRadius}px !important;
      max-width: ${currentSettings.messageMaxWidth}% !important;
      margin: ${currentSettings.messageSpacing}px 0 !important;
    }
    #inputControls {
      border-radius: ${currentSettings.inputRadius}px !important;
      min-height: ${currentSettings.inputHeight}px !important;
    }
    .chat-item {
      border-radius: ${currentSettings.chatItemRadius}px !important;
    }
    
    /* Animation Settings */
    .bubble {
      animation-duration: ${currentSettings.animationDuration}s !important;
    }
    
    .message-highlight {
      animation-duration: ${currentSettings.highlightDuration}s !important;
    }
    
    /* Animation-specific styles */
    ${currentSettings.animationType === 'fadeIn' ? `
      .bubble { animation-name: fadeIn !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'slideUp' ? `
      .bubble { animation-name: slideUp !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'slideInLeft' ? `
      .bubble { animation-name: slideInLeft !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'slideInRight' ? `
      .bubble { animation-name: slideInRight !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'bounce' ? `
      .bubble { animation-name: bounce !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'flip' ? `
      .bubble { animation-name: flip !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'zoom' ? `
      .bubble { animation-name: zoom !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'wave' ? `
      .bubble { animation-name: wave !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'pulse' ? `
      .bubble { animation-name: pulse !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'shake' ? `
      .bubble { animation-name: shake !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'swing' ? `
      .bubble { animation-name: swing !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'tada' ? `
      .bubble { animation-name: tada !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'wobble' ? `
      .bubble { animation-name: wobble !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'jello' ? `
      .bubble { animation-name: jello !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'heartbeat' ? `
      .bubble { animation-name: heartbeat !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'rubberBand' ? `
      .bubble { animation-name: rubberBand !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'lightSpeed' ? `
      .bubble { animation-name: lightSpeed !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'rollIn' ? `
      .bubble { animation-name: rollIn !important; }
    ` : ''}
    
    ${currentSettings.animationType === 'rotateIn' ? `
      .bubble { animation-name: rotateIn !important; }
    ` : ''}
    
    /* Stagger animation delays */
    ${currentSettings.staggerMessages ? `
      .bubble:nth-child(n) {
        animation-delay: calc(var(--stagger-index, 0) * ${currentSettings.staggerDelay}s);
      }
    ` : ''}
  `;
  
  style.textContent = css;
  document.head.appendChild(style);
  
  updateBubbleTails();
  
  // Re-render messages to apply new animations
  if (currentKey && Object.keys(messageStore).length > 0) {
    const tempStore = { ...messageStore };
    messageStore = {};
    messagesEl.innerHTML = '';
    lastRenderedDate = null;
    processAndRenderMessages(tempStore);
  }
}

function updateBubbleTails() {
  const existingTailStyle = document.getElementById('bubble-tail-style');
  if (existingTailStyle) {
    existingTailStyle.remove();
  }
  
  const tailStyle = document.createElement('style');
  tailStyle.id = 'bubble-tail-style';
  
  const tailSize = 12;
  const borderRadius = currentSettings.bubbleRadius;
  
  tailStyle.textContent = `
    .from-user::after {
      border-bottom-left-radius: ${Math.min(borderRadius / 4, 4)}px !important;
    }
    .from-brother::after {
      border-bottom-right-radius: ${Math.min(borderRadius / 4, 4)}px !important;
    }
  `;
  
  document.head.appendChild(tailStyle);
}

// Initialize animations on page load
document.addEventListener('DOMContentLoaded', function() {
  // Apply animations to existing messages
  setTimeout(() => {
    const bubbles = document.querySelectorAll('.bubble');
    const settings = getCurrentAnimationSettings();
    
    bubbles.forEach((bubble, index) => {
      const isUser = bubble.classList.contains('from-user');
      if (settings.animationType !== 'none') {
        applyMessageAnimation(bubble, settings.animationType, settings.animationDuration, isUser);
      }
      
      if (settings.staggerMessages) {
        bubble.style.animationDelay = `${index * settings.staggerDelay}s`;
      }
    });
  }, 100);
});

</script>
<script>
  // Toggle settings menu with animation
  settingsToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    const isShowing = settingsMenu.classList.contains('show');
    
    if (isShowing) {
      settingsMenu.classList.remove('show');
      // Wait for animation to complete before hiding
      setTimeout(() => {
        settingsMenu.style.display = 'none';
      }, 200);
    } else {
      settingsMenu.style.display = 'block';
      // Trigger animation after display
      setTimeout(() => {
        settingsMenu.classList.add('show');
      }, 10);
    }
  });
  
  // Close when clicking outside
  document.addEventListener('click', () => {
    settingsMenu.classList.remove('show');
    setTimeout(() => {
      settingsMenu.style.display = 'none';
    }, 200);
  });
  
  // ADD this to your existing JavaScript
// Add click event only to the profile picture
document.getElementById('userLogo').addEventListener('click', function(e) {
  e.stopPropagation();
  openProfileTab();
});

function openProfileTab() {
  const profileTab = document.getElementById('profileTab');
  if (profileTab) {
    profileTab.style.display = 'block';
    loadProfileData();
    loadSharedMedia();
  }
}

function closeProfileTab() {
  const profileTab = document.getElementById('profileTab');
  if (profileTab) {
    profileTab.style.display = 'none';
  }
}

function loadProfileData() {
  // Load current profile data from existing elements
  const profilePic = document.getElementById('userLogo').src;
  const profileName = document.getElementById('chatTitle').textContent;
  
  document.getElementById('profilePicLarge').src = profilePic;
  document.getElementById('profileNameDisplay').textContent = profileName;
}

function loadSharedMedia() {
  // Load shared images/GIFs from the current chat
  const mediaGrid = document.getElementById('mediaGrid');
  if (!mediaGrid || !currentKey) return;
  
  mediaGrid.innerHTML = '';
  
  // Get all media messages from the current chat
  const mediaMessages = Object.values(messageStore).filter(msg =>
    (msg.type === 'image' || msg.type === 'gif') && msg.url
  );
  
  mediaMessages.forEach(msg => {
    const mediaItem = document.createElement('div');
    mediaItem.className = 'media-item';
    mediaItem.onclick = () => {
      if (window.openLightbox) {
        window.openLightbox(msg.url);
      }
    };
    
    const img = document.createElement('img');
    img.src = msg.url;
    img.alt = 'Shared media';
    img.loading = 'lazy';
    
    mediaItem.appendChild(img);
    mediaGrid.appendChild(mediaItem);
  });
  
  if (mediaMessages.length === 0) {
    mediaGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: #666; padding: 20px;">No media shared yet</p>';
  }
}



function editProfilePicture() {
  // Open background picker without closing profile tab
  const backgroundModal = document.getElementById('backgroundModal');
  const profileTab = document.getElementById('profileTab');
  
  // Ensure background modal appears above profile tab
  backgroundModal.style.zIndex = '10001';
  profileTab.style.zIndex = '9999';
  
  openBackgroundPicker();
  
  // Switch to images tab
  setTimeout(() => {
    const imagesTabBtn = document.querySelector('.bg-tab-btn[data-tab="images"]');
    if (imagesTabBtn) {
      imagesTabBtn.click();
    }
  }, 100);
}

// Add this to your JavaScript
function initializeSharedMediaTabs() {
  const tabs = document.querySelectorAll('.shared-media-tab');
  const tabContents = document.querySelectorAll('.shared-media-tab-content');
  
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      // Remove active class from all tabs and contents
      tabs.forEach(t => t.classList.remove('active'));
      tabContents.forEach(c => c.classList.remove('active'));
      
      // Add active class to clicked tab
      tab.classList.add('active');
      
      // Show corresponding content
      const tabId = tab.dataset.tab + 'Tab';
      document.getElementById(tabId).classList.add('active');
      
      // Load content for the active tab
      loadSharedMediaContent(tab.dataset.tab);
    });
  });
}

function loadSharedMediaContent(type) {
  if (!currentKey) return;
  
  const mediaGrid = document.getElementById('mediaGrid');
  const gifsGrid = document.getElementById('gifsGrid');
  const linksGrid = document.getElementById('linksGrid');
  
  // Clear existing content
  mediaGrid.innerHTML = '';
  gifsGrid.innerHTML = '';
  linksGrid.innerHTML = '';
  
  // Get all messages from current chat
  const messages = Object.values(messageStore);
  
  messages.forEach(msg => {
    if (type === 'media' && msg.type === 'image' && msg.url) {
      addMediaItem(mediaGrid, msg.url, 'image');
    } else if (type === 'gifs' && msg.type === 'gif' && msg.url) {
      addMediaItem(gifsGrid, msg.url, 'gif');
    } else if (type === 'links' && msg.text) {
      const links = extractLinks(msg.text);
      links.forEach(link => {
        if (isYouTubeLink(link)) {
          addYouTubePreview(linksGrid, link, msg);
        } else {
          addLinkPreview(linksGrid, link, msg);
        }
      });
    }
  });
  
  // Show empty state if no content
  showEmptyState(mediaGrid, type === 'media');
  showEmptyState(gifsGrid, type === 'gifs');
  showEmptyState(linksGrid, type === 'links');
}

function addMediaItem(container, url, type) {
  const mediaItem = document.createElement('div');
  mediaItem.className = 'media-item';
  mediaItem.onclick = () => {
    if (window.openLightbox) {
      window.openLightbox(url);
    }
  };
  
  const img = document.createElement('img');
  img.src = url;
  img.alt = type === 'gif' ? 'Shared GIF' : 'Shared image';
  img.loading = 'lazy';
  
  mediaItem.appendChild(img);
  container.appendChild(mediaItem);
}

function addYouTubePreview(container, url, message) {
  const videoId = extractYouTubeVideoId(url);
  if (!videoId) return;
  
  const preview = document.createElement('div');
  preview.className = 'link-preview';
  preview.onclick = () => window.open(url, '_blank');
  
  preview.innerHTML = `
    <div class="link-url">${url}</div> 
    <div class="youtube-preview">
      <img src="https://img.youtube.com/vi/${videoId}/hqdefault.jpg" alt="YouTube thumbnail">
    </div>
    <div class="message-preview" style="font-size: 12px; color: #666; margin-top: 8px;">
      ${message.text.substring(0, 100)}${message.text.length > 100 ? '...' : ''}
    </div>
  `;
  
  container.appendChild(preview);
}
     
function addLinkPreview(container, url, message) {
  const preview = document.createElement('div');
  preview.className = 'link-preview';
  preview.onclick = () => window.open(url, '_blank');
  
  preview.innerHTML = `
    <div class="link-url">${url}</div>
    <div class="message-preview" style="font-size: 12px; color: #666; margin-top: 8px;">
      ${message.text.substring(0, 100)}${message.text.length > 100 ? '...' : ''}
    </div>
  `;
  
  container.appendChild(preview);
}

function extractLinks(text) {
  const urlRegex = /(https?:\/\/[^\s]+)/g;
  return text.match(urlRegex) || [];
}

function isYouTubeLink(url) {
  return url.includes('youtube.com') || url.includes('youtu.be');
}
   
function extractYouTubeVideoId(url) {
  const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
  const match = url.match(regExp);
  return (match && match[7].length === 11) ? match[7] : false;
}

function showEmptyState(container, isActive) {
  if (isActive && container.children.length === 0) {
    container.innerHTML = `
      <div style="grid-column: 1 / -1; text-align: center; color: #666; padding: 40px;">
        No ${container.id.replace('Grid', '').toLowerCase()} shared yet
      </div>
    `;
  }
}

// Initialize when profile tab opens
function loadSharedMedia() {
  initializeSharedMediaTabs();
  loadSharedMediaContent('media'); // Load media by default
}
</script>
<!-- Selection Toolbar -->
<div id="selectionToolbar">
  <div class="selected-count" id="selectedCount">0 selected</div>
  <div class="selection-actions">
    <button class="selection-action" id="deleteSelected" title="Delete">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" />
      </svg>
    </button>
    <button class="selection-action" id="copySelected" title="Copy">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" />
      </svg>
    </button>
  <button class="selection-action" id="closeSelection" title="Cancel">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" />
      </svg>
    </button>
  </div>
</div>
<style>
/* Make background modal appear above profile tab */


.background-modal {
    z-index: 10001 !important;
}

/* More specific CSS overrides */
#messages.custom-background {
  background-size: cover !important;
  background-position: center !important;
  background-repeat: no-repeat !important;
  background-attachment: fixed !important;
  background: inherit !important;
}

/* Force override for different background types */
#messages.custom-background[style*="background-color"] {
  background-color: inherit !important;
}

#messages.custom-background[style*="gradient"] {
  background: inherit !important;
  background-image: inherit !important;
}

#messages.custom-background[style*="background-image"] {
  background-image: inherit !important;
  background-size: cover !important;
  background-position: center !important;
  background-repeat: no-repeat !important;
  background-attachment: fixed !important;
}
/* Remove button for saved images */
.image-option {
  position: relative;
}

.remove-image-btn {
  position: absolute;
  top: -8px;
  right: -8px;
  width: 20px;
  height: 20px;
  background: #ff4444;
  color: white;
  border: none;
  border-radius: 50%;
  font-size: 12px;
  cursor: pointer;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10;
}

.image-option:hover .remove-image-btn {
  display: flex;
}

.remove-image-btn:hover {
  background: #cc0000;
  transform: scale(1.1);
}
/* Close button for background modal */
.background-modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.background-close-btn {
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: #666;
  padding: 5px;
  border-radius: 4px;
}

.background-close-btn:hover {
  background: #f0f0f0;
  color: #333;
}

body.dark .background-close-btn {
  color: #B7CAC6;
}

body.dark .background-close-btn:hover {
  background: #2A3A36;
  color: #fff;
}
/* Image Actions Menu Styles */
/* Image Actions Menu Styles - IMPROVED POSITIONING */
.image-actions-menu {
  background: #DDF2ED;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  border: 1px solid #ccc;
  min-width: 80px;
  z-index: 1000;
  max-width: 47%;
}

.action-menu-content {
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.image-action-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  background: none;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  color: #3A4F4A;
  transition: all 0.2s ease;
  width: 100%;
  text-align: left;
}

.image-action-btn:hover {
  background: rgba(37, 99, 235, 0.1);
  color: #2563eb;
}

.image-action-btn svg {
  flex-shrink: 0;
}

/* Dark mode styles */
body.dark .image-actions-menu {
  background: #13221F;
  border-color: #2A3A36;
  color: #B7CAC6;
}

body.dark .image-action-btn {
  color: #B7CAC6;
}

body.dark .image-action-btn:hover {
  background: rgba(37, 99, 235, 0.2);
  color: #5ac8fa;
}
/* Ensure home background displays properly */
#list.home-background-applied {
  background-image: inherit !important;
  background-size: inherit !important;
  background-position: inherit !important;
  background-repeat: inherit !important;
  background-attachment: inherit !important;
}

/* Smooth transitions for background changes */
#list {
  transition: background-image 0.3s ease;
}

/* URL Input Section Styling */
#imageUrlInput {
  background: #DDF2ED;
  border: 1px solid #ccc;
  color: #3A4F4A;
  font-size: 14px;
}

#imageUrlInput:focus {
  outline: none;
  border-color: #2563eb;
  box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
}

body.dark #imageUrlInput {
  background: #061613;
  border-color: #2A3A36;
  color: #B7CAC6;
}

body.dark #imageUrlInput:focus {
  border-color: #5ac8fa;
  box-shadow: 0 0 0 2px rgba(90, 200, 250, 0.1);
}

/* URL upload button specific styling */
.upload-btn[style*="background: #10B981"] {
  background: #10B981 !important;
}

.upload-btn[style*="background: #10B981"]:hover {
  background: #059669 !important;
}

/* Notification above lightbox */
.notification {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #25D366;
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    z-index: 10010; /* Higher than lightbox z-index */
    display: none;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    font-weight: 500;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.notification.show {
    display: flex;
    animation: slideDown 0.3s ease;
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

/* Success and Error notification types */
.notification.success {
    background: #25D366;
}

.notification.error {
    background: #FF3B30;
}

.notification.info {
    background: #007AFF;
}

/* Lightbox z-index adjustment */
.lightbox {
    z-index: 10000; /* Lower than notification */
}

.lightbox-header,
.lightbox-footer,
.lightbox-nav {
    z-index: 10001; /* Higher than lightbox background but lower than notification */
}


/* Profile Tab Styles - ADD these */
.profile-tab {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #DDF2ED;
  z-index: 9999;
  overflow-y: auto;
}

body.dark .profile-tab {
  background: #13221F;
}

.profile-header {
  background: #DDF2ED;
  padding: 10px 20px 5px;
  display: flex;
  align-items: center;
  gap: 15px;
  position: sticky;
  top: 0;
}

body.dark .profile-header {
  background: #13221F;
}

.back-btn {
  background: none;
  border: none;
  color: #075E54;
  cursor: pointer;
  padding: 8px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

body.dark .back-btn {
  color: #B7CAC6;
}

.profile-info {
  text-align: center;
  padding: 20px;
}

.profile-pic-large {
  width: 300px;
  height: 300px;
  border-radius: 50%;
  margin: 0 auto 15px;
  border: 3px solid #DDF2ED;
}

.profile-name {
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 5px;
  color: #000;
}

body.dark .profile-name {
  color: #B7CAC6;
}

.profile-status {
  color: #666;
  font-size: 14px;
}

body.dark .profile-status {
  color: #B7CAC6;
}

.profile-actions {
  background: #E9FEF9;
  margin: 20px;
  border-radius: 12px;
  overflow: hidden;
}

body.dark .profile-actions {
  background: #031813;
}

.profile-action-item {
  display: flex;
  align-items: center;
  padding: 15px 20px;
  border-bottom: 1px solid #E5E5E5;
  cursor: pointer;
  transition: background-color 0.2s;
}

body.dark .profile-action-item {
  border-bottom-color: #2A3A36;
}

.profile-action-item:last-child {
  border-bottom: none;
}

.profile-action-item:hover {
  background-color: rgba(0, 0, 0, 0.05);
}

body.dark .profile-action-item:hover {
  background-color: rgba(255, 255, 255, 0.05);
}

.action-icon {
  margin-right: 15px;
  font-size: 20px;
}

.action-text {
  flex: 1;
  font-size: 16px;
  color: #000;
}

body.dark .action-text {
  color: #B7CAC6;
}

.action-arrow {
  color: #666;
  font-size: 18px;
}

.media-section {
  margin: 20px;
}

.section-title {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 15px;
  color: #075E54;
}

body.dark .section-title {
  color: #B7CAC6;
}

.media-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 5px;
}

.media-item {
  aspect-ratio: 1;
  border-radius: 8px;
  overflow: hidden;
  cursor: pointer;
  background: #f0f0f0;
}

.media-item img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform 0.2s;
}

.media-item:hover img {
  transform: scale(1.05);
}
</style>
<!-- ADD this HTML before closing </body> tag -->
<div id="profileTab" class="profile-tab" style="display: none;">
  <div class="profile-header">
    <button class="back-btn" onclick="closeProfileTab()">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" />
      </svg>
    </button>
    <h2 style="margin: 0; flex: 1;">Profile</h2>
  </div>
  
  <div class="profile-info">
    <img id="profilePicLarge" class="profile-pic-large" src="" alt="Profile Picture">
    <div class="profile-name" id="profileNameDisplay">Bubu😘</div>
    <div class="profile-status">Hey there! I am using S Talk</div>
  </div>
  
  <div class="profile-actions">
    <div class="profile-action-item" onclick="editProfilePicture()">
      <div class="action-icon">📷</div>
      <div class="action-text">Edit profile picture</div>
      <div class="action-arrow">›</div>
    </div>
    <div class="profile-action-item" onclick="editProfileName()">
      <div class="action-icon">✏️</div>
      <div class="action-text">Edit name</div>
      <div class="action-arrow">›</div>
    </div>
  </div>


<!-- Replace your existing timers-section with this -->
<div class="timers-section">
  <div class="timer-status" id="timerStatus">
    <span id="syncStatus">⏳ Syncing time...</span>
    <button onclick="manualTimeSync()" class="sync-btn">Sync Now</button>
  </div>
  
  <div class="timer-card">
    <div class="timer-title">💕 Our Relationship Journey</div>
    <div class="timer-display" id="relationshipTimer">
      <div class="time-unit">
        <span class="time-value" id="years">0</span>
        <span class="time-label">years</span>
      </div>
      <div class="time-unit">
        <span class="time-value" id="months">0</span>
        <span class="time-label">months</span>
      </div>
      <div class="time-unit">
        <span class="time-value" id="days">0</span>
        <span class="time-label">days</span>
      </div>
    </div>
  </div>
  
  <div class="timer-card">
    <div class="timer-title">🎉 Next Anniversary</div>
    <div class="timer-display" id="anniversaryCountdown">
      <div class="countdown-grid">
        <div class="countdown-item">
          <div class="countdown-number" id="annivMonths">0</div>
          <div class="countdown-label">months</div>
        </div>
        <div class="countdown-item">
          <div class="countdown-number" id="annivDays">0</div>
          <div class="countdown-label">days</div>
        </div>
        <div class="countdown-item">
          <div class="countdown-number" id="annivHours">0</div>
          <div class="countdown-label">hours</div>
        </div>
        <div class="countdown-item">
          <div class="countdown-number" id="annivMinutes">0</div>
          <div class="countdown-label">mins</div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="timer-card">
    <div class="timer-title">🎂 Her Special Day</div>
    <div class="timer-display" id="userBirthdayCountdown">
      <div class="countdown-grid">
        <div class="countdown-item">
          <div class="countdown-number" id="userBdayMonths">0</div>
          <div class="countdown-label">months</div>
        </div>
        <div class="countdown-item">
          <div class="countdown-number" id="userBdayDays">0</div>
          <div class="countdown-label">days</div>
        </div>
        <div class="countdown-item">
          <div class="countdown-number" id="userBdayHours">0</div>
          <div class="countdown-label">hours</div>
        </div>
        <div class="countdown-item">
          <div class="countdown-number" id="userBdayMinutes">0</div>
          <div class="countdown-label">mins</div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="timer-card">
    <div class="timer-title">🎂 Your special day</div>
    <div class="timer-display" id="brotherBirthdayCountdown">
      <div class="countdown-grid">
        <div class="countdown-item">
          <div class="countdown-number" id="brotherBdayMonths">0</div>
          <div class="countdown-label">months</div>
        </div>
        <div class="countdown-item">
          <div class="countdown-number" id="brotherBdayDays">0</div>
          <div class="countdown-label">days</div>
        </div>
        <div class="countdown-item">
          <div class="countdown-number" id="brotherBdayHours">0</div>
          <div class="countdown-label">hours</div>
        </div>
        <div class="countdown-item">
          <div class="countdown-number" id="brotherBdayMinutes">0</div>
          <div class="countdown-label">mins</div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="media-section">
  <div class="section-title">Shared Media</div>
  
  <div class="shared-media-tabs">
    <button class="shared-media-tab active" data-tab="media">Media</button>
    <button class="shared-media-tab" data-tab="gifs">GIFs</button>
    <button class="shared-media-tab" data-tab="links">Links</button>
  </div>
  
  <div class="shared-media-content">
    <div id="mediaTab" class="shared-media-tab-content active">
      <div class="media-grid" id="mediaGrid">
        <!-- Images will be populated here -->
      </div>
    </div>
    
    <div id="gifsTab" class="shared-media-tab-content">
      <div class="media-grid" id="gifsGrid">
        <!-- GIFs will be populated here -->
      </div>
    </div>
    
    <div id="linksTab" class="shared-media-tab-content">
      <div class="links-grid" id="linksGrid" style="
      margin-top: 10px;
      margin-left: -10px;
      
      width: 315px;
      ">
        <!-- Links with previews will be populated here -->
      </div>
    </div>
  </div>
</div>
</div>
<style>/* Shared Media Tabs - Exact Profile Style */
.shared-media-tabs {
display: flex;
border-bottom: 1px solid #E5E5E5;
margin: 10px 10px 0;
background: #E9FEF9;
border-radius: 12px 12px 0 0;
overflow: hidden;
margin-left: 1px!important;
min-width: 320px;
}

body.dark .shared-media-tabs {
background: #031813;
border-bottom-color: #2A3A36;
}

.shared-media-tab {
flex: 1;
padding: 12px 8px;
background: none;
border: none;
cursor: pointer;
font-size: 14px;
font-weight: 500;
color: #666;
transition: all 0.3s ease;
border-bottom: 3px solid transparent;
}

.shared-media-tab.active {
color: #075E54;
border-bottom-color: #075E54;
background: rgba(7, 94, 84, 0.1);
}

body.dark .shared-media-tab {
color: #B7CAC6;
}

body.dark .shared-media-tab.active {
color: #25D366;
border-bottom-color: #25D366;
background: rgba(37, 211, 102, 0.1);
}

.shared-media-tab-content {
display: none;
padding: 0 20px 20px;
}

.shared-media-tab-content.active {
display: block;
}

/* Media Grid */
.media-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
gap: 8px;
margin-top: 16px;
}

.media-item {
aspect-ratio: 1;
border-radius: 12px;
overflow: hidden;
cursor: pointer;
background: #E9FEF9;
border: 2px solid transparent;
transition: all 0.3s ease;
}

.media-item:hover {
transform: translateY(-2px);
border-color: #075E54;
box-shadow: 0 4px 12px rgba(7, 94, 84, 0.2);
}

.media-item img {
width: 100%;
height: 100%;
object-fit: cover;
}

body.dark .media-item {
background: #031813;
border-color: #2A3A36;
}

body.dark .media-item:hover {
border-color: #25D366;
box-shadow: 0 4px 12px rgba(37, 211, 102, 0.2);
}

/* Links Container */
.links-container {
display: flex;
flex-direction: column;
gap: 12px;

margin-top: 16px;

}

.link-preview {
  min-width: 318px!important;
  margin-left: -2px;
background: #E9FEF9;
border-radius: 12px;
padding: 16px;
border: 1px solid #E5E5E5;
cursor: pointer;
transition: all 0.3s ease;
text-decoration: none;
color: inherit;
}

body.dark .link-preview {
background: #031813;
border-color: #2A3A36;

}

.link-preview:hover {
transform: translateY(-2px);
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.link-preview-content {
display: flex;
gap: 12px;
align-items: flex-start;

}

.link-thumbnail {
width: 80px;
height: 60px;
border-radius: 8px;
object-fit: cover;
flex-shrink: 0;
background: #f0f0f0;

}

.link-info {
flex: 1;
min-width: 0;

}

.link-title {
  
font-weight: 600;
font-size: 16px;
margin-bottom: 4px;
color: #000;
line-height: 1.3;
display: -webkit-box;
-webkit-line-clamp: 2;
-webkit-box-orient: vertical;
overflow: hidden;
}

body.dark .link-title {
color: #B7CAC6;
}

.link-description {
  
font-size: 14px;
color: #666;
line-height: 1.4;
display: -webkit-box;
-webkit-line-clamp: 2;
-webkit-box-orient: vertical;
overflow: hidden;
margin-bottom: 4px;
}

body.dark .link-description {
color: #B7CAC6;
}

.link-domain {
font-size: 12px;
color: #075E54;
font-weight: 500;
}

body.dark .link-domain {
color: #25D366;
}

/* YouTube Preview */
.youtube-preview {
position: relative;
border-radius: 12px;
overflow: hidden;
background: #000;
}

.youtube-thumbnail {
width: 100%;
height: 180px;
object-fit: cover;
}

.youtube-play-button {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 60px;
height: 60px;
background: rgba(255, 0, 0, 0.8);
border-radius: 50%;
display: flex;
align-items: center;
justify-content: center;
color: white;
font-size: 24px;
transition: all 0.3s ease;
}

.youtube-preview:hover .youtube-play-button {
background: rgba(255, 0, 0, 1);
transform: translate(-50%, -50%) scale(1.1);
}

/* Empty State */
.no-content-message {
text-align: center;
color: #666;
padding: 40px 20px;
font-style: italic;
}

body.dark .no-content-message {
color: #B7CAC6;
}

/* Responsive */
@media (max-width: 480px) {
.shared-media-tabs {
margin: 15px 15px 0;
}

.shared-media-tab {
font-size: 12px;
padding: 10px 4px;
}

.shared-media-tab-content {
padding: 0 15px 15px;
}

.media-grid {
grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
gap: 6px;
}

.link-preview-content {
flex-direction: column;
}

.link-thumbnail {
width: 100%;
height: 120px;
}

.youtube-thumbnail {
height: 150px;
}
}</style>
<!-- Add this CSS for the hearts animation -->
<!-- Add this CSS for the hearts animation -->
<style>
/* Falling Hearts Animation */
.heart-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9999;
  overflow: hidden;
}

.heart {
  position: absolute;
  top: -50px;
  font-size: 24px;
  color: #ff4081;
  animation: fall linear forwards;
  text-shadow: 0 0 5px rgba(255, 64, 129, 0.7);
  z-index: 9999;
  user-select: none;
}

@keyframes fall {
  to {
    transform: translateY(calc(100vh + 50px)) rotate(360deg);
    opacity: 0;
  }
}
/* Heart Animation Types */
@keyframes heartFall {
  to {
    transform: translateY(calc(100vh + 50px)) rotate(360deg);
    opacity: 0;
  }
}

@keyframes heartRise {
  from {
    transform: translateY(0) rotate(0deg);
    opacity: 1;
  }
  to {
    transform: translateY(-100vh) rotate(-360deg);
    opacity: 0;
  }
}

@keyframes heartFloat {
  0%, 100% {
    transform: translateY(0) translateX(0);
  }
  25% {
    transform: translateY(-20px) translateX(10px);
  }
  50% {
    transform: translateY(-40px) translateX(-10px);
  }
  75% {
    transform: translateY(-20px) translateX(10px);
  }
}

@keyframes heartExplosion {
  from {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
  to {
    transform: 
      translate(
        calc(-50% + cos(var(--angle)) * var(--distance)),
        calc(-50% + sin(var(--angle)) * var(--distance))
      ) 
      scale(0);
    opacity: 0;
  }
}

@keyframes heartSpiral {
  0% {
    transform: translate(-50%, -50%) rotate(0deg) scale(1);
    opacity: 1;
  }
  100% {
    transform: 
      translate(
        calc(-50% + cos(360deg) * 200px),
        calc(-50% + sin(360deg) * 200px)
      ) 
      rotate(720deg) scale(0);
    opacity: 0;
  }
}

.heart {
  position: fixed;
  pointer-events: none;
  z-index: 9999;
  user-select: none;
  animation-timing-function: linear;
}

/* Different heart colors for variety */
.heart.pink { color: #ff4081; }
.heart.red { color: #f44336; }
.heart.purple { color: #e91e63; }
.heart.deep-pink { color: #c2185b; }
</style>

<!-- Add this HTML for the hearts container -->
<div id="heartContainer" class="heart-container"></div>
<script>
  // Fixed hearts implementation - hook directly into Firebase send
  let heartsEnabled = false;
  let isHeartsActive = false;
  
  function showHearts() {
    if (!heartsEnabled) return;
    
    const container = document.getElementById('heartContainer');
    if (!container) return;
    
    // Prevent multiple heart storms from stacking
    if (isHeartsActive) return;
    isHeartsActive = true;
    
    const heartColors = ['pink', 'red', 'purple', 'deep-pink'];
    
    for (let i = 0; i < 25; i++) {
      setTimeout(() => {
        const heart = document.createElement('div');
        heart.className = 'heart ' + heartColors[Math.floor(Math.random() * heartColors.length)];
        heart.innerHTML = '❤️';
        heart.style.left = Math.random() * 100 + '%';
        heart.style.animationDuration = (3 + Math.random() * 2) + 's';
        heart.style.fontSize = (20 + Math.random() * 15) + 'px';
        
        container.appendChild(heart);
        
        // Remove heart after animation completes
        setTimeout(() => {
          if (heart.parentNode === container) {
            container.removeChild(heart);
          }
        }, 5000);
      }, i * 150);
    }
    
    // Reset the active flag after the heart storm completes
    setTimeout(() => {
      isHeartsActive = false;
    }, 4000);
  }
  
  // Improved keyword detection function
  function containsHeartKeywords(text) {
    if (!text) return false;
    
    const lowerText = text.toLowerCase();
    
    // Exact word matching (not partial matches)
    const words = lowerText.split(/\s+/);
    
    // Check for exact words
    const hasExactMatch = words.some(word => {
      const cleanWord = word.replace(/[^\w]/g, ''); // Remove punctuation
      return cleanWord === 'love' || cleanWord === 'bubu' || cleanWord === 'jaan';
    });
    
    // Check for heart emoji
    const hasHeartEmoji = text.includes('💖') || text.includes('❤️') || text.includes('😍');
    
    return hasExactMatch || hasHeartEmoji;
  }
  
  let lastTriggerTime = 0;
  
  // Enable hearts only after page is fully loaded and user interacts
  document.addEventListener('DOMContentLoaded', function() {
    // Disable hearts initially
    heartsEnabled = false;
    
    // Enable hearts when user starts typing or after 3 seconds
    const enableHearts = function() {
      heartsEnabled = true;
      console.log('Hearts enabled! Will show when sending messages with keywords.');
      
      // Remove event listeners after first activation
      document.removeEventListener('click', enableHearts);
      document.removeEventListener('touchstart', enableHearts);
      document.removeEventListener('focus', enableHearts);
    };
    
    // Enable on user interaction
    document.addEventListener('click', enableHearts);
    document.addEventListener('touchstart', enableHearts);
    
    // Also enable after 3 seconds automatically
    setTimeout(enableHearts, 3000);
    
    // METHOD 1: Override the Firebase database set function
    const originalSet = db.ref().set;
    if (originalSet) {
      db.ref().set = function(...args) {
        console.log('Firebase set called:', args);
        
        // Check if this is a message send operation
        const path = this.toString();
        if (path.includes('chats/') && path.includes('/brother')) {
          const messageData = args[0];
          if (messageData && messageData.text && containsHeartKeywords(messageData.text)) {
            const currentTime = Date.now();
            if (currentTime - lastTriggerTime > 3000) {
              lastTriggerTime = currentTime;
              console.log('🎯 Hearts triggered from FIREBASE SEND:', messageData.text);
              showHearts();
            }
          }
        }
        
        return originalSet.apply(this, args);
      };
      console.log('Firebase set function overridden');
    }
    
    // METHOD 2: Hook into your sendReply function directly
    if (typeof window.sendReply === 'function') {
      const originalSendReply = window.sendReply;
      window.sendReply = function() {
        const replyInput = document.getElementById('replyInput');
        if (replyInput && heartsEnabled) {
          const text = replyInput.value;
          const currentTime = Date.now();
          
          if (containsHeartKeywords(text) && (currentTime - lastTriggerTime > 3000)) {
            lastTriggerTime = currentTime;
            console.log('🎯 Hearts triggered from SENDREPLY FUNCTION:', text);
            showHearts();
          }
        }
        
        return originalSendReply.apply(this, arguments);
      };
      console.log('sendReply function overridden');
    }
    
    // METHOD 3: Monitor the send button with proper event capturing
    const sendBtn = document.getElementById('sendBtn');
    if (sendBtn) {
      // Remove any existing listeners and add new one
      const newSendBtn = sendBtn.cloneNode(true);
      sendBtn.parentNode.replaceChild(newSendBtn, sendBtn);
      
      newSendBtn.addEventListener('click', function(e) {
        console.log('Send button clicked!');
        const replyInput = document.getElementById('replyInput');
        
        if (heartsEnabled && replyInput) {
          const text = replyInput.value;
          const currentTime = Date.now();
          
          console.log('Send button - checking text:', text);
          
          if (containsHeartKeywords(text) && (currentTime - lastTriggerTime > 3000)) {
            lastTriggerTime = currentTime;
            console.log('🎯 Hearts triggered from SEND BUTTON CLICK:', text);
            showHearts();
          }
        }
        
        // Also call the original send functionality
        if (typeof window.sendReply === 'function') {
          window.sendReply();
        }
      }, true); // Use capturing to catch the event early
      
      console.log('Send button listener added with capturing');
    }
    
    // METHOD 4: Watch for new brother messages as backup
    setTimeout(() => {
      const messagesEl = document.getElementById('messages');
      if (messagesEl) {
        let lastMessageCount = document.querySelectorAll('.bubble.from-brother').length;
        
        const checkForNewSentMessages = () => {
          const currentMessageCount = document.querySelectorAll('.bubble.from-brother').length;
          if (currentMessageCount > lastMessageCount) {
            // New message was added
            const brotherMessages = document.querySelectorAll('.bubble.from-brother');
            const latestMessage = brotherMessages[brotherMessages.length - 1];
            const text = latestMessage.textContent || '';
            const currentTime = Date.now();
            
            if (containsHeartKeywords(text) && (currentTime - lastTriggerTime > 3000)) {
              lastTriggerTime = currentTime;
              console.log('🎯 Hearts triggered from NEW SENT MESSAGE DETECTION:', text.substring(0, 50));
              showHearts();
            }
            
            lastMessageCount = currentMessageCount;
          }
        };
        
        // Check every 500ms for new messages
        setInterval(checkForNewSentMessages, 500);
        console.log('Started interval check for new sent messages');
      }
    }, 2000);
  });
  
  // TEST FUNCTION - You can call this in browser console to test: testHearts()
  window.testHearts = function() {
    heartsEnabled = true;
    showHearts();
    console.log('Hearts test triggered!');
  };
  
  // DEBUG: Check what's happening when you send
  window.debugSend = function() {
    console.log('=== SEND DEBUG ===');
    console.log('heartsEnabled:', heartsEnabled);
    console.log('sendReply function:', typeof window.sendReply);
    console.log('sendBtn:', document.getElementById('sendBtn'));
    console.log('replyInput:', document.getElementById('replyInput'));
    console.log('db.ref:', typeof db.ref);
    
    // Test the keyword detection
    console.log('Keyword test - love:', containsHeartKeywords('love'));
    console.log('Keyword test - hello:', containsHeartKeywords('hello'));
    console.log('=== END DEBUG ===');
  };
</script>
<script>
// Hearts settings system
const defaultHeartsSettings = {
  enabled: true,
  animationType: 'fall',
  animationDuration: 3,
  quantity: 25,
  minSize: 20,
  maxSize: 35,
  
  colorTheme: 'random',
  customColors: ['#ff4081', '#f44336', '#e91e63'],
  triggerOnSend: true,
  triggerOnReceive: true,
  cooldown: 3,
  customWords: [
    { word: 'love', emoji: '❤️', quantity: 25 },
    { word: 'bubu', emoji: '😘', quantity: 30 },
    { word: 'babu', emoji: '💖', quantity: 20 }
  ]
};

// Load hearts settings
let heartsSettings = JSON.parse(localStorage.getItem('heartsSettings')) || {...defaultHeartsSettings};

// Initialize hearts settings in the form
function initializeHeartsSettings() {
  if (!document.getElementById('enableHearts')) {
    console.log('Hearts settings form not ready yet');
    return;
  }
  
  console.log('Initializing hearts settings from storage:', heartsSettings);
  
  // Set form values from saved settings
  document.getElementById('enableHearts').checked = heartsSettings.enabled;
  document.getElementById('heartAnimationType').value = heartsSettings.animationType;
  document.getElementById('heartAnimationDuration').value = heartsSettings.animationDuration;
  document.getElementById('heartQuantity').value = heartsSettings.quantity;
  document.getElementById('heartMinSize').value = heartsSettings.minSize;
  document.getElementById('heartMaxSize').value = heartsSettings.maxSize;
 
  document.getElementById('heartColorTheme').value = heartsSettings.colorTheme;
  document.getElementById('triggerOnSend').checked = heartsSettings.triggerOnSend;
  document.getElementById('triggerOnReceive').checked = heartsSettings.triggerOnReceive;
  document.getElementById('heartCooldown').value = heartsSettings.cooldown;
  
  // Set custom colors
  document.getElementById('customColor1').value = heartsSettings.customColors[0];
  document.getElementById('customColor2').value = heartsSettings.customColors[1];
  document.getElementById('customColor3').value = heartsSettings.customColors[2];
  
  // Load custom words
  loadCustomWords();
  
  // Toggle custom colors visibility
  toggleCustomColors();
}

// Save hearts settings to localStorage
function saveHeartsSettings() {
  console.log('Saving hearts settings...');
  
  // Get values from form
  heartsSettings.enabled = document.getElementById('enableHearts').checked;
  heartsSettings.animationType = document.getElementById('heartAnimationType').value;
  heartsSettings.animationDuration = parseFloat(document.getElementById('heartAnimationDuration').value) || 3;
  heartsSettings.quantity = parseInt(document.getElementById('heartQuantity').value) || 25;
  heartsSettings.minSize = parseInt(document.getElementById('heartMinSize').value) || 20;
  heartsSettings.maxSize = parseInt(document.getElementById('heartMaxSize').value) || 35;

  heartsSettings.colorTheme = document.getElementById('heartColorTheme').value || 'random';
  heartsSettings.triggerOnSend = document.getElementById('triggerOnSend').checked;
  heartsSettings.triggerOnReceive = document.getElementById('triggerOnReceive').checked;
  heartsSettings.cooldown = parseInt(document.getElementById('heartCooldown').value) || 3;
  
  // Save custom colors
  heartsSettings.customColors = [
    document.getElementById('customColor1').value,
    document.getElementById('customColor2').value,
    document.getElementById('customColor3').value
  ];
  
  // Save custom words
  const wordItems = document.querySelectorAll('.custom-word-item');
  heartsSettings.customWords = [];
  wordItems.forEach(item => {
    const word = item.querySelector('.custom-word').value.trim();
    const emoji = item.querySelector('.custom-emoji').value.trim();
    const quantity = parseInt(item.querySelector('.custom-quantity').value) || 25;
    
    if (word && emoji) {
      heartsSettings.customWords.push({
        word: word.toLowerCase(),
        emoji: emoji,
        quantity: quantity
      });
    }
  });
  
  // Save to localStorage
  localStorage.setItem('heartsSettings', JSON.stringify(heartsSettings));
  console.log('Hearts settings saved successfully!', heartsSettings);
}

// Reset hearts settings to default
function resetHeartsSettings() {
  console.log('Resetting hearts settings to default...');
  heartsSettings = {...defaultHeartsSettings};
  localStorage.setItem('heartsSettings', JSON.stringify(heartsSettings));
  initializeHeartsSettings();
}

// Load custom words into UI
function loadCustomWords() {
  const container = document.getElementById('customWordsContainer');
  if (!container) {
    console.log('Custom words container not found');
    return;
  }
  
  container.innerHTML = '';
  
  heartsSettings.customWords.forEach((wordObj, index) => {
    const wordDiv = document.createElement('div');
    wordDiv.className = 'custom-word-item';
    wordDiv.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px; padding: 8px; background: #f8f9fa; border-radius: 6px;';
    wordDiv.innerHTML = `
      <input type="text" class="custom-word" value="${wordObj.word}" placeholder="Word" style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
      <input type="text" class="custom-emoji" value="${wordObj.emoji}" placeholder="Emoji" maxlength="5" style="width: 60px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
      <input type="number" class="custom-quantity" value="${wordObj.quantity}" min="5" max="100" style="width: 70px; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
      <button onclick="removeCustomWord(${index})" style="background: #ef4444; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer;">×</button>
    `;
    container.appendChild(wordDiv);
  });
}

// Toggle custom colors visibility
function toggleCustomColors() {
  const container = document.getElementById('customColorsContainer');
  if (container) {
    const theme = document.getElementById('heartColorTheme').value;
    container.style.display = theme === 'custom' ? 'block' : 'none';
  }
}

// Hearts animation functions
// Update the showHearts function to use the selected animation type
window.showHearts = function(customText = '') {
  if (!heartsSettings.enabled) {
    console.log('Hearts are disabled');
    return;
  }
  
  const container = document.getElementById('heartContainer');
  if (!container) {
    console.log('Heart container not found');
    return;
  }
  
  if (window.isHeartsActive) {
    console.log('Hearts already active');
    return;
  }
  
  window.isHeartsActive = true;
  console.log('Showing hearts with animation type:', heartsSettings.animationType);
  
  // 🚨 CRITICAL FIX: Use ONLY custom words, never default emoji
  let emojiToUse = '❤️'; // Fallback only
  let quantityToUse = heartsSettings.quantity;
  
  if (customText) {
    const matchedWord = heartsSettings.customWords.find(wordObj =>
      customText.toLowerCase().includes(wordObj.word.toLowerCase())
    );
    if (matchedWord) {
      emojiToUse = matchedWord.emoji;
      quantityToUse = matchedWord.quantity;
      console.log('Using custom emoji:', emojiToUse, 'for word:', matchedWord.word);
    } else {
      // 🚨 DON'T use default emoji for unmatched words
      console.log('No custom word match found, not showing hearts');
      window.isHeartsActive = false;
      return;
    }
  } else {
    // 🚨 If no custom text provided, don't show default hearts
    console.log('No custom text provided, not showing hearts');
    window.isHeartsActive = false;
    return;
  }
  
  // Get colors
  const colors = getHeartColors();
  
  container.innerHTML = '';
  
  for (let i = 0; i < quantityToUse; i++) {
    setTimeout(() => {
      const heart = document.createElement('div');
      heart.className = 'heart';
      heart.innerHTML = emojiToUse;
      heart.style.left = Math.random() * 100 + '%';
      heart.style.animationDuration = heartsSettings.animationDuration + 's';
      heart.style.fontSize = (heartsSettings.minSize + Math.random() * (heartsSettings.maxSize - heartsSettings.minSize)) + 'px';
      heart.style.color = colors[Math.floor(Math.random() * colors.length)];
      
      // Apply the selected animation type
      applyHeartAnimation(heart, heartsSettings.animationType);
      
      container.appendChild(heart);
      setTimeout(() => heart.remove(), heartsSettings.animationDuration * 1000);
    }, i * 50);
  }
  
  setTimeout(() => { window.isHeartsActive = false; }, heartsSettings.animationDuration * 1000);
};

// Function to apply different animation types
function applyHeartAnimation(heart, animationType) {
  // Reset any existing animation
  heart.style.animation = '';
  
  switch (animationType) {
    case 'fall':
      heart.style.animation = `heartFall ${heartsSettings.animationDuration}s linear forwards`;
      heart.style.top = '-50px';
      break;
      
    case 'rise':
      heart.style.animation = `heartRise ${heartsSettings.animationDuration}s linear forwards`;
      heart.style.top = '100vh';
      heart.style.bottom = 'auto';
      break;
      
    case 'float':
      heart.style.animation = `heartFloat ${heartsSettings.animationDuration}s ease-in-out infinite`;
      heart.style.top = Math.random() * 100 + 'vh';
      break;
      
    case 'explosion':
      const angle = Math.random() * Math.PI * 2;
      const distance = 100 + Math.random() * 200;
      heart.style.animation = `heartExplosion ${heartsSettings.animationDuration}s ease-out forwards`;
      heart.style.setProperty('--angle', angle + 'rad');
      heart.style.setProperty('--distance', distance + 'px');
      heart.style.top = '50%';
      heart.style.left = '50%';
      break;
      
    case 'spiral':
      heart.style.animation = `heartSpiral ${heartsSettings.animationDuration}s linear forwards`;
      heart.style.top = '50%';
      heart.style.left = '50%';
      break;
      
    default:
      heart.style.animation = `heartFall ${heartsSettings.animationDuration}s linear forwards`;
      heart.style.top = '-50px';
  }
}

function getHeartColors() {
  switch (heartsSettings.colorTheme) {
    case 'reds': return ['#ff4081', '#f44336', '#e91e63', '#c2185b'];
    case 'pinks': return ['#ff4081', '#e91e63', '#ad1457', '#f8bbd0'];
    case 'rainbow': return ['#ff4081', '#ff9800', '#ffeb3b', '#4caf50', '#2196f3', '#9c27b0'];
    case 'custom': return heartsSettings.customColors;
    default: return ['#ff4081', '#f44336', '#e91e63', '#c2185b', '#ff9800', '#4caf50'];
  }
}

window.previewHeartsAnimation = function() {
  console.log('Previewing hearts with current form values...');
  // Save current form values first
  saveHeartsSettings();
  window.showHearts('love');
};

window.testAllCustomWords = function() {
  console.log('Testing all custom words...');
  saveHeartsSettings();
  heartsSettings.customWords.forEach((wordObj, index) => {
    setTimeout(() => {
      window.showHearts(wordObj.word);
    }, index * 4000);
  });
};

window.addCustomWord = function() {
  heartsSettings.customWords.push({ word: 'new', emoji: '❤️', quantity: 25 });
  loadCustomWords();
};

window.removeCustomWord = function(index) {
  heartsSettings.customWords.splice(index, 1);
  loadCustomWords();
};

// Override your existing saveAdvancedSettings function
document.addEventListener('DOMContentLoaded', function() {
  // Wait for the save button to exist, then override its behavior
  const checkSaveButton = setInterval(() => {
    const saveBtn = document.getElementById('saveAdvancedBtn');
    if (saveBtn) {
      console.log('Found save button, overriding behavior...');
      
      // Remove existing click listeners and add new one
      const newSaveBtn = saveBtn.cloneNode(true);
      saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
      
      newSaveBtn.addEventListener('click', function() {
        console.log('Save Advanced button clicked - saving ALL settings including hearts...');
        
        // Save hearts settings
        saveHeartsSettings();
        
        // Call original save function if it exists
        if (typeof window.saveAdvancedSettings === 'function') {
          window.saveAdvancedSettings();
        }
        
        alert('All settings (including hearts) saved successfully!');
      });
      
      clearInterval(checkSaveButton);
    }
  }, 500);

  // Also override reset button
  const checkResetButton = setInterval(() => {
    const resetBtn = document.getElementById('resetAdvancedBtn');
    if (resetBtn) {
      console.log('Found reset button, overriding behavior...');
      
      const newResetBtn = resetBtn.cloneNode(true);
      resetBtn.parentNode.replaceChild(newResetBtn, resetBtn);
      
      newResetBtn.addEventListener('click', function() {
        console.log('Reset Advanced button clicked - resetting ALL settings including hearts...');
        
        if (confirm('Are you sure you want to reset ALL settings (including hearts) to default?')) {
          // Reset hearts settings
          resetHeartsSettings();
          
          // Call original reset function if it exists
          if (typeof window.resetAdvancedSettings === 'function') {
            window.resetAdvancedSettings();
          }
          
          alert('All settings (including hearts) reset to default!');
        }
      });
      
      clearInterval(checkResetButton);
    }
  }, 500);

  // Initialize hearts settings when animations tab opens
  const animationsTab = document.getElementById('animationsTab');
  if (animationsTab) {
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          if (animationsTab.classList.contains('active')) {
            console.log('Animations tab opened - initializing hearts settings');
            setTimeout(initializeHeartsSettings, 100);
          }
        }
      });
    });
    observer.observe(animationsTab, { attributes: true });
  }

  // Initialize hearts state
  window.isHeartsActive = false;
  
  // Setup enhanced hearts for message sending
  window.setupEnhancedHearts();
});

// Enhanced hearts for message detection
window.setupEnhancedHearts = function() {
  const originalSendReply = window.sendReply;
  if (typeof originalSendReply === 'function') {
    window.sendReply = function() {
      const replyInput = document.getElementById('replyInput');
      
      if (replyInput && heartsSettings.enabled && heartsSettings.triggerOnSend) {
        const text = replyInput.value;
        const currentTime = Date.now();
        const cooldown = heartsSettings.cooldown * 1000;
        
        if (window.containsHeartKeywords(text) && (currentTime - window.lastTriggerTime > cooldown)) {
          window.lastTriggerTime = currentTime;
          const matchedWord = window.getMatchedWord(text);
          console.log('Hearts triggered from message send:', text);
          window.showHearts(matchedWord);
        }
      }
      
      return originalSendReply.apply(this, arguments);
    };
    console.log('Enhanced hearts setup complete');
  }
  
  window.lastTriggerTime = 0;
};

// Keyword detection
window.containsHeartKeywords = function(text) {
  if (!text || !heartsSettings.enabled) return false;
  
  const lowerText = text.toLowerCase();
  
  // Check custom words
  const hasCustomWord = heartsSettings.customWords.some(wordObj => 
    lowerText.includes(wordObj.word)
  );
  
  // Check default words
  const hasDefaultWord = lowerText.includes('love') || 
                        lowerText.includes('bubu') || 
                        lowerText.includes('babu');
  
  return hasCustomWord || hasDefaultWord;
};

window.getMatchedWord = function(text) {
  if (!text) return '';
  const lowerText = text.toLowerCase();
  const matchedWord = heartsSettings.customWords.find(wordObj => 
    lowerText.includes(wordObj.word)
  );
  return matchedWord ? matchedWord.word : '';
};

// Hearts CSS
const heartCSS = `
@keyframes heartFall {
  to {
    transform: translateY(calc(100vh + 50px)) rotate(360deg);
    opacity: 0;
  }
}
.heart {
  position: fixed;
  pointer-events: none;
  z-index: 9999;
  user-select: none;
  animation-timing-function: linear;
}
`;
document.head.insertAdjacentHTML('beforeend', `<style>${heartCSS}</style>`);

console.log('Hearts system loaded! Settings will save with Advanced Settings buttons.');
</script>
<style>
  /* Animation Tabs - Clean Input Styling */
#animationsTab .setting-item input[type="text"],
#animationsTab .setting-item input[type="number"],
#animationsTab .setting-item input[type="color"],
#animationsTab .setting-item select {
  background: #DDF2ED;
  border: 1px solid #ccc;
  color: #3A4F4A;
  padding: 6px 8px;
  border-radius: 4px;
  font-size: 14px;
  width: auto;
}

/* Dark mode for animation tab inputs */
body.dark #animationsTab .setting-item input[type="text"],
body.dark #animationsTab .setting-item input[type="number"],
body.dark #animationsTab .setting-item input[type="color"],
body.dark #animationsTab .setting-item select {
  background: #061613;
  border: 1px solid #2A3A36;
  color: #B7CAC6;
}

/* Remove duplicate backgrounds from custom words container */
#customWordsContainer {
  padding: 0;
  margin-bottom: 10px;
  background: transparent !important;
}

/* Remove background from custom word items - make them transparent */
.custom-word-item {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
  padding: 0;
  background: transparent !important;
  border: none !important;
}

/* Custom word inputs - standalone without containers */
.custom-word-item input {
  background: #DDF2ED !important;
  border: 1px solid #ccc !important;
  color: #3A4F4A !important;
  padding: 6px 8px;
  border-radius: 4px;
  font-size: 14px;
}

body.dark .custom-word-item input {
  background: #061613 !important;
  border: 1px solid #2A3A36 !important;
  color: #B7CAC6 !important;
}

/* Focus states */
#animationsTab .setting-item input:focus,
#animationsTab .setting-item select:focus {
  outline: none;
  border-color: #2563eb;
  box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
}

body.dark #animationsTab .setting-item input:focus,
body.dark #animationsTab .setting-item select:focus {
  border-color: #5ac8fa;
  box-shadow: 0 0 0 2px rgba(90, 200, 250, 0.1);
}

/* Remove background from settings groups in animation tab */
#animationsTab .settings-group {
  background: transparent;
  padding: 0;
  border-radius: 0;
  margin-bottom: 25px;
}

body.dark #animationsTab .settings-group {
  background: transparent;
}

/* Keep the section headers but remove extra backgrounds */
#animationsTab .settings-group h4 {
  color: #2563eb;
  margin-bottom: 15px;
  font-size: 16px;
  
  padding-bottom: 8px;
  background: transparent;
}

body.dark #animationsTab .settings-group h4 {
  color: #5ac8fa;
  
  background: transparent;
}

/* Checkbox styling */
#animationsTab .setting-item input[type="checkbox"] {
  width: 18px;
  height: 18px;
  accent-color: #2563eb;
}

body.dark #animationsTab .setting-item input[type="checkbox"] {
  accent-color: #5ac8fa;
}

/* Buttons in animation tab */
#animationsTab button {
  background: #2563eb;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s ease;
}

#animationsTab button:hover {
  background: #1d4ed8;
  transform: translateY(-1px);
}

body.dark #animationsTab button {
  background: #5ac8fa;
  color: #13221F;
}

body.dark #animationsTab button:hover {
  background: #47b8e8;
}

/* Remove button specific styling */
.custom-word-item button {
  background: #ef4444 !important;
  color: white;
  border: none;
  padding: 6px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
}

.custom-word-item button:hover {
  background: #dc2626 !important;
}


/* Custom word items - fixed width */
.custom-word-item {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
  padding: 0;
  background: transparent !important;
  border: none !important;
  align-items: center;
}

/* Custom word input - reduced width */
.custom-word-item .custom-word {
  width: 80px !important; /* Reduced from full width */
  background: #DDF2ED !important;
  border: 1px solid #ccc !important;
  color: #3A4F4A !important;
  padding: 6px 8px;
  border-radius: 4px;
  font-size: 14px;
}

.custom-word-item .custom-emoji {
  width: 50px !important; /* Slightly smaller for emoji */
  background: #DDF2ED !important;
  border: 1px solid #ccc !important;
  color: #3A4F4A !important;
  padding: 6px 8px;
  border-radius: 4px;
  font-size: 14px;
  text-align: center;
}

.custom-word-item .custom-quantity {
  width: 60px !important; /* Fixed width for quantity */
  background: #DDF2ED !important;
  border: 1px solid #ccc !important;
  color: #3A4F4A !important;
  padding: 6px 8px;
  border-radius: 4px;
  font-size: 14px;
}


</style>
<style>
/* ===== COMPLETELY NEW TIMER LOGIC ===== */

/* Timer Container */




/* Timer Status */
.timer-status {
    text-align: center;
    margin-bottom: 15px;
    padding: 10px;
    border-radius: 10px;
    background: rgba(0, 107, 97, 0.1);
    font-size: 14px;
}

.sync-btn {
    background: #2563eb;
    color: white;
    border: none;
    padding: 4px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    margin-left: 10px;
}

.sync-btn:hover {
    background: #1d4ed8;
}

/* Timer Cards */
.timer-card {
    background: #E9FEF9;
    border-radius: 15px;
    padding: 20px;
    margin: 15px 0;
  
    transition: all 0.3s ease;
}

body.dark .timer-card {
    background: #031813;
  
}

.timer-title {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 15px;
    color: #006B61;
    text-align: center;
}

body.dark .timer-title {
    color: #DDF2ED;
}

/* Relationship Timer Display */
.timer-display {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    flex-wrap: wrap;
}

.time-unit {
    text-align: center;
    padding: 10px 15px;
    background: #DDF2ED;
    border-radius: 10px;

    min-width: 80px;
}

body.dark .time-unit {
    background: #13221F;
    
}

.time-value {
    display: block;
    font-size: 24px;
    font-weight: bold;
    color: #006B61;
    line-height: 1.2;
}

body.dark .time-value {
    color: #25D366;
}

.time-label {
    display: block;
    font-size: 12px;
    color: #3A4F4A;
    text-transform: uppercase;
    margin-top: 5px;
}

body.dark .time-label {
    color: #B7CAC6;
}

/* Countdown Grid */
.countdown-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    width: 100%;
    max-width: 400px;
    margin: 0 auto;
}

.countdown-item {
    background: #DDF2ED;
    padding: 12px 8px;
    border-radius: 10px;
    
    text-align: center;
    transition: all 0.3s ease;
}

body.dark .countdown-item {
    background: #13221F;
    
}

.countdown-number {
    font-size: 20px;
    font-weight: bold;
    color: #006B61;
    line-height: 1.2;
    display: block;
}

body.dark .countdown-number {
    color: #25D366;
}

.countdown-label {
    font-size: 11px;
    color: #3A4F4A;
    text-transform: uppercase;
    display: block;
    margin-top: 4px;
}

body.dark .countdown-label {
    color: #B7CAC6;
}



.countdown-item:hover {
    transform: scale(1.05);
    background: rgba(0, 107, 97, 0.1);
}

body.dark .countdown-item:hover {
    background: rgba(37, 211, 102, 0.1);
}

/* Status Colors */
.sync-status {
    padding: 4px 8px;
    border-radius: 4px;
    font-weight: 500;
}

.sync-status.syncing {
    background: #FFD700;
    color: #000;
}

.sync-status.success {
    background: #25D366;
    color: white;
}

.sync-status.error {
    background: #FF3B30;
    color: white;
}

/* Responsive Design */
@media (max-width: 768px) {
    .timers-section {
        margin: 10px;
        padding: 15px;
    }
    
    .timer-display {
        gap: 10px;
    }
    
    .time-unit {
        min-width: 70px;
        padding: 8px 12px;
    }
    
    .time-value {
        font-size: 20px;
    }
    
    .countdown-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
    }
    
    .countdown-item {
        padding: 10px 6px;
    }
    
    .countdown-number {
        font-size: 18px;
    }
}

@media (max-width: 480px) {
    .timer-display {
        flex-direction: column;
        gap: 8px;
    }
    
    .time-unit {
        width: 100%;
        max-width: 120px;
    }
    
    .countdown-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}

/* Animation for number changes */
@keyframes numberChange {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.time-value.updated, .countdown-number.updated {
    animation: numberChange 0.3s ease;
}

/* Today celebration style */
.today-celebration {
    background: linear-gradient(135deg, #25D366, #4CAF50) !important;
    color: white !important;
    border-color: #25D366 !important;
}

.today-celebration .countdown-number,
.today-celebration .time-value {
    color: white !important;
}

.today-celebration .countdown-label,
.today-celebration .time-label {
    color: rgba(255, 255, 255, 0.9) !important;
}
</style>
<script>
  // Completely new timer logic
class TimerManager {
  constructor() {
    this.relationshipStart = new Date('August 05, 2017');
    this.timeOffset = 0;
    this.isSynced = false;
    this.timerElements = {};
    this.init();
  }
  
  async init() {
    await this.syncTime();
    this.cacheElements();
    this.startTimers();
    setInterval(() => this.updateAllTimers(), 1000);
    setInterval(() => this.syncTime(), 60 * 60 * 1000); // Sync every hour
  }
  
  async syncTime() {
    try {
      this.updateSyncStatus('⏳ Syncing time...', 'syncing');
      const response = await fetch('https://worldtimeapi.org/api/ip');
      const data = await response.json();
      const serverTime = new Date(data.utc_datetime);
      this.timeOffset = serverTime - Date.now();
      this.isSynced = true;
      this.updateSyncStatus('✅ Using online time', 'success');
      return true;
    } catch (error) {
      this.isSynced = false;
      this.timeOffset = 0;
      this.updateSyncStatus('⚠️ Using device time', 'error');
      return false;
    }
  }
  
  updateSyncStatus(message, status) {
    const statusElement = document.getElementById('syncStatus');
    if (statusElement) {
      statusElement.textContent = message;
      statusElement.className = `sync-status ${status}`;
    }
  }
  
  cacheElements() {
    // Relationship timer
    this.timerElements.years = document.getElementById('years');
    this.timerElements.months = document.getElementById('months');
    this.timerElements.days = document.getElementById('days');
    
    // Anniversary countdown
    this.timerElements.annivMonths = document.getElementById('annivMonths');
    this.timerElements.annivDays = document.getElementById('annivDays');
    this.timerElements.annivHours = document.getElementById('annivHours');
    this.timerElements.annivMinutes = document.getElementById('annivMinutes');
    
    // User birthday
    this.timerElements.userBdayMonths = document.getElementById('userBdayMonths');
    this.timerElements.userBdayDays = document.getElementById('userBdayDays');
    this.timerElements.userBdayHours = document.getElementById('userBdayHours');
    this.timerElements.userBdayMinutes = document.getElementById('userBdayMinutes');
    
    // Brother birthday
    this.timerElements.brotherBdayMonths = document.getElementById('brotherBdayMonths');
    this.timerElements.brotherBdayDays = document.getElementById('brotherBdayDays');
    this.timerElements.brotherBdayHours = document.getElementById('brotherBdayHours');
    this.timerElements.brotherBdayMinutes = document.getElementById('brotherBdayMinutes');
  }
  
  getCurrentTime() {
    return this.isSynced ? new Date(Date.now() + this.timeOffset) : new Date();
  }
  
  updateAllTimers() {
    const now = this.getCurrentTime();
    this.updateRelationshipTimer(now);
    this.updateCountdowns(now);
  }
  
  updateRelationshipTimer(now) {
    const diff = now - this.relationshipStart;
    const years = Math.floor(diff / (1000 * 60 * 60 * 24 * 365.25));
    const months = Math.floor((diff % (1000 * 60 * 60 * 24 * 365.25)) / (1000 * 60 * 60 * 24 * 30.44));
    const days = Math.floor((diff % (1000 * 60 * 60 * 24 * 30.44)) / (1000 * 60 * 60 * 24));
    
    this.updateElementWithAnimation(this.timerElements.years, years);
    this.updateElementWithAnimation(this.timerElements.months, months);
    this.updateElementWithAnimation(this.timerElements.days, days);
  }
  
  updateCountdowns(now) {
    const currentYear = now.getFullYear();
    
    // Anniversary - September 23
    const anniversary = new Date(`September 23, ${currentYear}`);
    if (anniversary <= now) anniversary.setFullYear(currentYear + 1);
    this.updateSingleCountdown('anniversary', anniversary, now);
    
    // User Birthday - August 10
    const userBday = new Date(`August 10, ${currentYear}`);
    if (userBday <= now) userBday.setFullYear(currentYear + 1);
    this.updateSingleCountdown('userBday', userBday, now);
    
    // Brother Birthday - September 16
    const brotherBday = new Date(`September 16, ${currentYear}`);
    if (brotherBday <= now) brotherBday.setFullYear(currentYear + 1);
    this.updateSingleCountdown('brotherBday', brotherBday, now);
  }
  
  updateSingleCountdown(type, targetDate, now) {
    const diff = targetDate - now;
    
    if (diff <= 0) {
      this.showTodayCelebration(type);
      return;
    }
    
    const months = Math.floor(diff / (1000 * 60 * 60 * 24 * 30.44));
    const days = Math.floor((diff % (1000 * 60 * 60 * 24 * 30.44)) / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    
    const prefix = type === 'anniversary' ? 'anniv' : type === 'userBday' ? 'userBday' : 'brotherBday';
    
    this.updateElementWithAnimation(this.timerElements[`${prefix}Months`], months);
    this.updateElementWithAnimation(this.timerElements[`${prefix}Days`], days);
    this.updateElementWithAnimation(this.timerElements[`${prefix}Hours`], hours);
    this.updateElementWithAnimation(this.timerElements[`${prefix}Minutes`], minutes);
    
    this.removeTodayCelebration(type);
  }
  
  updateElementWithAnimation(element, value) {
    if (!element) return;
    
    const currentValue = parseInt(element.textContent) || 0;
    if (currentValue !== value) {
      element.textContent = value;
      element.classList.add('updated');
      setTimeout(() => element.classList.remove('updated'), 300);
    }
  }
  
  showTodayCelebration(type) {
    const element = document.getElementById(`${type}Countdown`);
    if (element) {
      element.classList.add('today-celebration');
      const message = type === 'anniversary' ? '🎉 Happy Anniversary!' :
        type === 'userBday' ? '🎂 Happy Birthday!' : '🎂 Happy Birthday!';
      element.innerHTML = `<div style="text-align: center; font-weight: bold; font-size: 18px;">${message}</div>`;
    }
  }
  
  removeTodayCelebration(type) {
    const element = document.getElementById(`${type}Countdown`);
    if (element) {
      element.classList.remove('today-celebration');
    }
  }
  
  startTimers() {
    this.updateAllTimers();
  }
}

// Initialize the timer system
let timerManager;

function initializeTimers() {
  timerManager = new TimerManager();
}

// Manual sync function
function manualTimeSync() {
  if (timerManager) {
    timerManager.syncTime();
  }
}

// Start timers when profile tab opens
function initializeProfileTimers() {
  setTimeout(() => {
    if (!timerManager) {
      initializeTimers();
    }
  }, 100);
}

// Make functions globally available
window.initializeTimers = initializeTimers;
window.manualTimeSync = manualTimeSync;
window.initializeProfileTimers = initializeProfileTimers;

// Auto-initialize
document.addEventListener('DOMContentLoaded', initializeTimers);

</script>
<style>
/* Progress Indicator Styles */
.progress-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}

.progress-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid transparent;
  border-top: 3px solid #006B61;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

body.dark .progress-spinner {
  border-top: 3px solid #25D366;
}

.progress-text {
  font-size: 16px;
  font-weight: 500;
  text-align: center;
}

.progress-count {
  font-size: 14px;
  opacity: 0.8;
  background: ${document.body.classList.contains('dark') ? '#031813' : '#C8E6E0'};
  padding: 4px 12px;
  border-radius: 12px;
  font-weight: 600;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Smooth transitions for theme changes */
#fileUploadProgress {
  transition: all 0.3s ease;
}

/* Success state (optional) */
.progress-success {
  background: #25D366 !important;
  color: white !important;
}

.progress-success .progress-spinner {
  border-top-color: white !important;
}
</style>
<style>
.new-message-notification {
position: fixed;
bottom: 80px;
left: 50%;
transform: translateX(-50%);
background: #DDF2ED;
color: grey;
padding: 12px 20px;
border-radius: 25px;
font-size: 14px;
cursor: pointer;
z-index: 1000;

display: none;
align-items: center;
gap: 8px;
animation: slideUp 0.3s ease;
/* Prevent swipe gestures */
touch-action: pan-y;
user-select: none;
-webkit-user-select: none;

}

body.dark .new-message-notification{
  background-color:#13221F ;
  color: #DDF2ED;
}

body.dark .new-message-notification .count{
  color: #DDF2ED;
}


/* Remove any swipe handlers from the notification */
.new-message-notification {
pointer-events: auto !important;
}

.new-message-notification * {
pointer-events: none !important;
}

.new-message-notification .count {
background: #075E54;
color: white;
border-radius: 50%;
width: 20px;
height: 20px;
display: flex;
align-items: center;
justify-content: center;
font-size: 12px;
font-weight: bold;
}

@keyframes slideUp {
from {
opacity: 0;
transform: translateX(-50%) translateY(20px);
}
to {
opacity: 1;
transform: translateX(-50%) translateY(0);
}
}



.new-messages-divider {
text-align: center;
margin: 10px 0;
position: relative;
}

.new-messages-divider::before {
content: '';
position: absolute;
top: 50%;
left: 0;
right: 0;
height: 1px;
background: #DDF2ED;
z-index: 1;
}

body.dark .new-messages-divider::before{
  background:#13221F;
}

.new-messages-divider span {
background: #DDF2ED;
padding: 5px 15px;
border-radius: 15px;
font-size: 12px;
color: grey;
font-weight: bold;
position: relative;
z-index: 2;
border: 1px solid #DDF2ED;
}

body.dark .new-messages-divider span{
background: #13221F;
color: #DDF2ED;
border-color: #13221F;
}


@keyframes pulseHighlight {
0% { background-color: rgba(37, 211, 102, 0.1); }
50% { background-color: rgba(37, 211, 102, 0.3); }
100% { background-color: transparent; }
}</style>
<div class="new-message-notification" id="newMessageNotification" onclick="scrollToNewMessages()">
  <div class="count" id="newMessageCount">1</div>
  <span>New messages</span>
</div>
</body>
</html>
