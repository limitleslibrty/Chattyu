<!DOCTYPE html>
<html>
<head>
  <link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#ffffff" id="theme-color-meta">

  
  
  <meta charset="utf-8">
  <title>Brother Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, interactive-widget=resizes-content">

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <script src="firebase-config.js"></script>

  <!-- Preload images for faster UI -->
  <link rel="preload" as="image" href="chat_logo.png">
  <link rel="preload" as="image" href="chat.png">
<!-- Emoji picker -->
<script src="https://cdn.jsdelivr.net/npm/@joeattardi/emoji-button@4.6.2/dist/index.min.js"></script>

<style>

.lightbox {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.9);
  z-index: 9999;
}
.lightbox.open { display: flex; }
.lightbox img {
  max-width: 90vw;
  max-height: 90vh;
}
.lightbox .btn {
  position: absolute;
  background: rgba(0,0,0,0.5);
  color: #fff;
  border: none;

  border-radius: 4px;
  cursor: pointer;
}
.lightbox .close { top: 10px; right: 10px; }
.lightbox .prev { left: 10px; top: 14%; transform: translateY(-50%); }
.lightbox .next { right: 5%;
left:70%; top: 14%; transform: translateY(-50%); }
.lightbox .download { bottom: 10px; right: 10px; }
.lightbox .counter { bottom: 10px; left: 10px; color:#fff; font-size:14px; }
/* Keep input area fully transparent */
#inputArea {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 10px;
  background: transparent;
  border-top: none;
  display: flex;
  flex-direction: column;
  z-index: 30;
}

/* textarea with slight transparent background for visibility */
#inputControls textarea,
#replyInput {
  background: rgba(255, 255, 255, 0.85);  /* almost solid white */
  border: 1px solid rgba(0,0,0,0.1);
  border-radius: 20px;
  padding: 8px 12px;
  color: #000;
  font-size: 15px;
  line-height: 1.3;
  flex: 1;
  resize: none;
}

/* buttons with subtle background */
#inputControls button,
#gifBtn, #attachBtn, #sendBtn {
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid rgba(0,0,0,0.1);
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: grey;
}

/* reply preview */
.reply-preview {
  background: rgba(255, 255, 255, 0.85);
  border-left: 4px solid #4caf50;
  color: #333;
  border-radius: 6px;
  font-size: 13px;
  margin-bottom: 6px;
  padding: 6px 10px;
}

/* dark mode overrides */
body.dark #inputControls textarea,
body.dark #replyInput {
  background: rgba(42,42,42,0.9);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.1);
}

body.dark #inputControls button {
  background: rgba(42,42,42,0.9);
  border: 1px solid rgba(255,255,255,0.1);
  color: #fff;
}

body.dark .reply-preview {
  background: rgba(42,42,42,0.85);
  color: #e5e5e5;
}



/* Compact WhatsApp-like icon buttons for GIF & Attach */
#inputControls {
  display: flex;
  align-items: center;   /* center vertically */
  gap: 2px;              /* small spacing between controls */
}

#inputControls button.icon-btn,
#gifBtn, /* fallback selector if you don't change HTML */
#attachBtn {
  width: 36px;
  height: 36px;
  margin-right: 1px;
  border-radius: 50%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;      /* icon / emoji size */
  line-height: 1;
  flex: 0 0 36px;       /* don't grow or shrink */
  cursor: pointer;
  border: 1px solid rgba(0,0,0,0.06);
  background: #ffffff;
  box-shadow: 0 1px 3px rgba(16,24,40,0.06);
  transition: transform 120ms ease, box-shadow 120ms ease;
}

/* make sure textarea doesn’t push icons out on small screens */
#inputControls textarea {
  flex: 1 1 auto;    /* textarea grows, icons keep fixed size */
  margin: 0;
}

/* slightly shrink the 'Send' button so it balances with icons */
#inputControls button#sendBtn {
  padding: 4px 6px;
  border-radius: 18px;
  margin-left: 2px;
  flex: 0 0 auto;
}



/* GIF picker modal */
#gifModal {
  position: fixed;
  left: 0; right: 0; top: 0; bottom: 0;
  display: none;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(4px);
  z-index: 9999;
}
#gifModal .panel {
  width: 92%;
  max-width: 720px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 12px 40px rgba(0,0,0,0.25);
  padding: 12px;
  max-height: 80vh;
  overflow: auto;
}
#gifModal .search {
  display:flex;
  gap:8px;
  margin-bottom:10px;
}
#gifResults {
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}
.gif-thumb {
  width: 30%;
  max-width: 160px;
  border-radius: 8px;
  cursor: pointer;
  object-fit: cover;
}
@media (max-width:480px){ .gif-thumb{ width: 48%; } }
</style>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html { height: 100%; font-family: 'Segoe UI', sans-serif; background: #f2f3f7; overflow-x: hidden; }

    #list, #chat { display: none; height: 100%; width: 100%; }
    #list.active, 
    
    #chat.active {
  display: flex;
  flex-direction: column;
  height: 100%;
}

    #messages { overflow-x: hidden; }

    #inboxHeader {
      padding: 25px 20px 10px;
      font-size: 28px;
      font-weight: 700;
      
      background: #ffffff;
      background-clip: text;
      color: transparent;
      background-image: linear-gradient(to right, #2563eb, #7c3aed);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      border-bottom: 1px solid #e5e7eb;
    }

    #searchBox {
      margin: 12px 20px 0;
      padding: 10px 15px;
      border-radius: 30px;
      border: 1px solid #ccc;
      outline: none;
      font-size: 15px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.04);
    }
    


    #list {
      background: linear-gradient(to bottom right, #f4f6f9, #e2e6ec);
      overflow-y: auto;
    }
    
    
    

    .chat-item {
      position: relative;
      background: #ffffff;
      padding: 15px 20px;
      margin: 12px 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .chat-item:hover { background: #e0ecff; transform: translateY(-2px); }
    .chat-name { font-size: 16px; font-weight: 600; color: #333; }
    .chat-preview { font-size: 14px; color: #666; margin-top: 4px; }
    .chat-time {
      position: absolute; right: 20px; top: 18px;
      font-size: 12px; color: #888;
    }
    


    #chatHeader {
  border: none !important;
  flex-shrink: 0;
  background: #DDF2ED;
  color: #000000;
  padding: 4px;
  font-weight: 400;
  font-size: 18px;
  display: flex;
  align-items: center;
  box-shadow: none !important;
  outline: none !important;
}

    #messages {
      flex: 1; padding: 10px; overflow-y: auto; display: flex; flex-direction: column;
      background-color: #E9FEF9;
      background-size: 110% 110%;
      background-repeat: no-repeat;
      background-position: center;
    }





/* Common bubble style */
.bubble {
  
  white-space: pre-wrap; 
  position: relative;
  margin: 6px 0;
  padding: 12px 16px;
  border-radius: 16px;
  max-width: 75%;
  font-size: 18px;
  line-height: 1.4;
  word-wrap: break-word;
}

/* User bubble (left) */
.from-user {
  background: #DDF2ED;
  align-self: flex-start;
  border-bottom-left-radius: 4px; /* smaller radius for tail corner */
}

/* Brother bubble (right) */
.from-brother {
  background: #006B61;
  align-self: flex-end;
  color:white;
  
  border-bottom-right-radius: 4px; /* smaller radius for tail corner */
}

/* Tail for user bubble (left) */
.from-user::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0; /* start from left corner */
  width: 12px;
  height: 12px;
  background: #DDF2ED;
  border-bottom-left-radius: 4px;
  clip-path: polygon(0 0, 0% 100%, 100% 100%);
}

/* Tail for brother bubble (right) */
.from-brother::after {
  content: '';
  position: absolute;
  bottom: 0;
  right: 0; /* start from right corner */
  width: 12px;
  height: 12px;
  background: #006B61;
  border-bottom-right-radius: 4px;
  clip-path: polygon(100% 0, 0% 100%, 100% 100%);
}





/* Brother bubble timestamp - */
.from-brother .msg-time {
  color: white !important;
}


    .msg-time {
      font-size: 10px; color: black; margin-top: 4px; align-self: flex-end;
    }

    .reply-box {
      font-size: 15px;
      color: #555;
      background: #E9FEF9;
      padding: 6px 10px;
      
      margin-bottom: 6px;
      border-radius: 8px;
    }

  #inputArea {
  flex-shrink: 0;
  display: flex;
  padding: 10px;
  background: transparent; /* ✅ transparent background */
  border-top: none;        /* ✅ no border */
  flex-direction: column;
  backdrop-filter: none;   /* ✅ no blur, fully clear */
}

    .reply-preview {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f0f0f0;
      padding: 6px 10px;
      border-left: 4px solid #4caf50;
      border-radius: 6px;
      font-size: 13px;
      margin-bottom: 6px;
      color: #333;
    }
    .reply-preview-text {
      flex: 1;
      white-space: normal;
      overflow: hidden;
      max-height: 3.2em;
    }
    .reply-preview button {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: #888;
    }
    
    .date-divider {
  text-align: center;
  margin: 10px auto;
  padding: 6px 14px;
  border-radius: 14px;
  font-size: 13px;
  font-weight: 600;
  color: #555;
  background: #e5e7eb;
  display: inline-block;
}

/* Dark mode divider */
body.dark .date-divider {
  background: #2a2a2a;
  color: #ddd;
}
  
  body.dark .from-user::after {
  background: #2a2a2a; /* matches dark bubble */
}
body.dark .from-brother::after {
  background: #056162; /* matches dark brother bubble */
}
    
    #inputControls { display: flex; align-items: flex-end; }
    #inputControls textarea {
      flex: 1;
      padding: 8px 12px;
      
      border: 1px solid #979595;
      border-radius: 20px;
      resize: none;
      overflow: hidden;
      font-size: 15px;
      line-height: 1.3;
      max-height: 80px;
    }
    #inputControls textarea:focus {
      border-color: #979595;
      outline: none;
    }
    #inputControls button {
      margin-left: 5px; 
      border: 1px solid #979595;
      background: #fff; color: #fff; border-radius: 20px;
    }

    .reply-arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      transition: opacity 0.2s ease;
      font-size: 18px;
      color: #4caf50;
    }
    .from-user .reply-arrow { left: -28px; }
    .from-brother .reply-arrow { right: -28px; }
    .bubble.show-arrow .reply-arrow { opacity: 1; }
    
    
    
    
    /* 🌙 DARK MODE FIX */
body.dark {
  background: #121212 !important;
  color: #e5e5e5 !important;
}



/* 🌙 Dark mode for search bar */
body.dark #searchBox {
  background: #2a2a2a !important;
  color: #ffffff !important;
  border: 1px solid #444 !important;
}

body.dark #searchBox::placeholder {
  color: #aaaaaa !important;
}



/* Inbox header */
body.dark #inboxHeader {
  background-image: linear-gradient(to right, #9333ea, #3b82f6) !important;
  color: #ffffff !important;
}




/* Inbox chat items (dark mode) */
body.dark .chat-item {
  background: #2a2a2a;          /* dark gray card */
  color: #fff;                  /* default text = white */
}

body.dark .chat-item .chat-name {
  color: #ffffff;               /* pure white for names */
}

body.dark .chat-item .chat-preview {
  color: #bbbbbb;               /* softer gray for preview */
}

body.dark .chat-item .chat-time {
  color: #888888;               /* dim gray for timestamp */
}


/* Chat list */
body.dark #list {
  background: #1e1e1e !important;
}

body.dark .chat-item {
  background: #2a2a2a !important;
  color: #ffffff !important;   /* chat list names = pure white */
}

body.dark .chat-item:hover {
  background: #333 !important;
}

body.dark .chat-item small,
body.dark .chat-item .preview {
  color: #cccccc !important; /* slightly brighter gray */
}

/* Chat header */
body.dark #chatHeader {
  background: #1e1e1e !important;
  color: #ffffff !important;
}

/* Messages area */
body.dark #messages {
  background: #121212 !important;
}

/* User bubbles */
body.dark .from-user {
  background: #2a2a2a !important;
  color: #ffffff !important;
}

/* Brother bubbles */
body.dark .from-brother {
  background: #056162 !important;
  color: #ffffff !important;
}

/* Chat bubble timestamp */
body.dark .msg-time {
  font-size: 11px !important;
  color: #ffffff !important;   /* full white */
  text-align: right !important;
  margin-top: 4px !important;
  display: block !important;
}


/* Reply box (dark mode) */
body.dark .reply-box {
  color: #e5e5e5;
  background: rgba(255,255,255,0.08);  /* soft white overlay */
  border-left: 3px solid #3b82f6;      /* nice blue accent */
}


    /* Reply preview (dark mode) */
body.dark .reply-preview {
  background: rgba(255, 255, 255, 0.08);  /* soft overlay on dark */
  border-left: 4px solid #3b82f6;         /* blue accent */
  color: #e5e5e5;
}

    /* Toggle button base */
#darkModeToggle {
  margin-left: auto;
  margin-right: 10px;
  padding: 6px 14px;
  border-radius: 20px;
  border: none;
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  transition: all 0.3s ease;
}

/* Light mode toggle */
body:not(.dark) #darkModeToggle {
background: #E9FEF9;   /* light gray */
  color: #111;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);

  
}


/* Dark mode toggle */
body.dark #darkModeToggle {
  background: #2a2a2a;   /* dark gray */
  color: #facc15;        /* warm yellow (sun icon) */
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

/* Hover effect */
#darkModeToggle:hover {
  transform: scale(1.05);
}
    
    
    
/* Light mode: flat grey highlight */
.bubble.message-highlight {
  background-color: #A1B790 !important;
}

/* Make the bubble tail match the highlight color (light) */
.bubble.message-highlight.from-user::after,
.bubble.message-highlight.from-brother::after {
  background-color: #A1B790 !important;
}

/* Dark mode: flat orange highlight */
body.dark .bubble.message-highlight {
  background-color: #E6A23ECC !important;
}

/* Make the bubble tail match the highlight color (dark) */
body.dark .bubble.message-highlight.from-user::after,
body.dark .bubble.message-highlight.from-brother::after {
  background-color: #E6A23ECC !important;
}
    .loading-indicator {
  text-align: center;
  padding: 10px;
  color: #666;
  font-style: italic;
  background: rgba(255, 255, 255, 0.8);
  border-radius: 8px;
  margin: 10px;
}

body.dark .loading-indicator {
  background: rgba(42, 42, 42, 0.8);
  color: #ccc;
}
    
    /* Styles for clickable links in messages */
.message-link {
  pointer-events: auto;
  color: #069;
  text-decoration: none;
  word-break: break-all;
}

body.dark .message-link {
  color: #5ac8fa;
}

.message-link:hover {
  text-decoration: underline;
}

/* For reply previews */
.reply-box a,
.reply-preview-text a {
  color: #069;
  text-decoration: none;
}

body.dark .reply-box a,
body.dark .reply-preview-text a {
  color: #5ac8fa;
}

.reply-box a:hover,
.reply-preview-text a:hover {
  text-decoration: underline;
}
  </style>
</head>
<body>

  

  
  
  <audio id="sendSound" src="send.mp3" preload="auto"></audio>
<audio id="receiveSound" src="receive.mp3" preload="auto"></audio>

  <div id="list" class="active">
    <div id="inboxHeader" style="margin-left: 10px;">S talk</div>
    <input type="text" id="searchBox" placeholder="Search chats..." oninput="filterChats()" />
    <div id="chatList"></div>
  </div>

  <div id="chat">
    <div id="chatHeader">
      
 <img id="userLogo" src="chat_logo.png"
     style="width:50px; height:50px; border:3px solid orange; border-radius:50%;
     margin-left: 5px;" />

      
<div style="margin-left:10px; display:flex; flex-direction:column;">
  <div id="chatTitle">Bubu😘</div>
  <div id="typingIndicator" style="font-size:12px; color:gray; display:none;">
    typing…
  </div>
</div>

<a href="videocall.html"
style="margin-left: auto;
margin-right: 5px;
margin-top: 8px;"> <!-- WhatsApp-like call icon (original) -->
<!-- WhatsApp-like call icon (transparent background) -->
<svg xmlns="http://www.w3.org/2000/svg"
     width="38" height="30" viewBox="0 0 24 24" role="img" aria-labelledby="title desc">
  <title id="title">Call</title>
  <desc id="desc">Phone handset icon</desc>

  <!-- handset only -->
  <path d="M6.62 10.79
           a15.466 15.466 0 006.59 6.59
           l2.2-2.2
           a1 1 0 01.95-.27
           c1.05.27 2.2.42 3.4.42
           a1 1 0 011 1V20
           a1 1 0 01-1 1
           C9.39 21 3 14.61 3 6
           a1 1 0 011-1h2.5
           a1 1 0 011 1
           c0 1.2.15 2.35.42 3.4
           .09.31.01.65-.27.95
           l-2.03 2.03z"
        fill="none" stroke="grey" stroke-width="1.3"
        stroke-linecap="round" stroke-linejoin="round" />

</svg></a>
      <button id="darkModeToggle" >
  🌙
</button>


    </div>
    <div id="messages"></div>
<div id="inputArea">
  <div id="replyPreviewContainer"></div>
  <div id="inputControls">
    
    <button id="gifBtn" title="GIF" >
      
      
      
      
   <svg xmlns="http://www.w3.org/2000/svg" 
     width="24" height="24" 
     fill="none" 
     stroke="grey" 
     stroke-width="2" 
     stroke-linecap="round" 
     stroke-linejoin="round">

  <!-- outer rounded square -->
  <rect x="3" y="3" width="18" height="18" rx="6" ry="6"/>

  <!-- eyes -->
  <circle cx="9" cy="10" r="1"/>
  <circle cx="15" cy="10" r="1"/>

  <!-- mouth with folded corner -->
  <path d="M8 15h4c1.5 0 3 1 3 2v1l3-3"/>
</svg>
      
      
    </button>
    <!-- optional file attach (works locally; to upload to Firebase Storage add storage SDK) -->
    <input id="attachFile" type="file" accept="image/*,video/gif" style="display:none" />
    <button id="attachBtn" title="Attach">
  <svg xmlns="http://www.w3.org/2000/svg" 
       width="24" height="24" 
       fill="none" 
       stroke="grey" 
       stroke-width="2" 
       stroke-linecap="round" 
       stroke-linejoin="round">
    <path d="M21.44 11.05l-9.19 9.19a5 5 0 0 1-7.07-7.07l9.19-9.19a3.5 3.5 0 0 1 4.95 4.95l-9.19 9.19a2 2 0 0 1-2.83-2.83l8.48-8.48" />
  </svg>

      
      
    </button>
    
    <textarea id="replyInput" placeholder="Type" rows="1" style="flex:1"></textarea>
    <button id="sendBtn">
      
  <!-- Up Arrow Icon -->
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="grey" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
    <path d="M12 19V5"></path>
    <path d="M5 12l7-7 7 7"></path>
  </svg>

    </button>
  </div>
</div>

<!-- GIF modal -->
<div id="gifModal" aria-hidden="true">
  <div class="panel">
    <div class="search">
            <button style="
      background: rgba(255, 255, 255, 0.9);
border: 1px solid rgba(0,0,0,0.1);
border-radius: 50%;
width: 36px;
height: 36px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
color: grey;
      
      " id="gifCloseBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="128" height="128" aria-hidden="true">
  <!-- circle background -->
  <circle cx="50" cy="50" r="44" fill="#CFCFF3" />
  <!-- left arrow (shaft + head). adjust stroke-width to change thickness -->
  <g fill="none" stroke="#2F3140" stroke-width="8" stroke-linecap="round" stroke-linejoin="round">
    <!-- shaft -->
    <path d="M70 50 H35" />
    <!-- head -->
    <path d="M45 33 L25 50 L45 67" />
  </g>
</svg></button>
   
      <input id="gifSearch" placeholder="Search GIFs (Tenor)" style="flex:1;padding:8px;border-radius:8px;border:1px solid #ccc" />
      <button id="gifSearchBtn" style="
      background: rgba(255, 255, 255, 0.9);
border: 1px solid rgba(0,0,0,0.1);
border-radius: 50%;
width: 36px;
height: 36px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
color: grey;
padding: 3px;
;"
      >
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <circle cx="11" cy="11" r="8" />
  <line x1="21" y1="21" x2="16.65" y2="16.65" />
</svg>
      </button>
 </div>
    <div id="gifResults"></div>
  </div>
</div>
  </div>
  
  
  
  <script>
  document.addEventListener("DOMContentLoaded", function() {
    if (!localStorage.getItem("authenticated")) {
      document.body.style.filter = "blur(8px)";
      
      setTimeout(() => {
        const raw = prompt("Enter password to access:");
        const entered = raw === null ? '' : raw.trim();
        
        // CORRECT encoded value for this scheme:
        // scheme: reverse the real password, then Base64-encode that reversed string.
        // For real password "8990" -> reversed "0998" -> base64 => "MDk5OA=="
        const encoded = "MDk5OA==";
        
        function decodePassword(enc) {
          try {
            const decoded = atob(enc); // Base64 decode -> "0998"
            return decoded.split('').reverse().join(''); // reverse -> "8990"
          } catch (e) {
            return null;
          }
        }
        
        const expected = decodePassword(encoded);
        
        if (entered && expected && entered === expected) {
          localStorage.setItem("authenticated", "true");
          alert("Access granted ✅");
          document.body.style.filter = "none";
        } else {
          alert("Wrong password ❌");
          location.reload();
        }
      }, 50);
    }
  });
</script>
 
 

<script>
const db = firebase.database();

const listEl = document.getElementById('list');
const chatEl = document.getElementById('chat');
const chatList = document.getElementById('chatList');
const messagesEl = document.getElementById('messages');
const replyInput = document.getElementById('replyInput');


// ---- Presence in the SAME typingIndicator div ----
let statusListener = null; // holds { ref, callback } for cleanup

function formatLastSeen(ts) {
  if (!ts) return 'Last seen: unknown';
  const d = new Date(Number(ts));
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today); yesterday.setDate(today.getDate() - 1);

  const timeStr = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });

  if (d.toDateString() === today.toDateString()) return 'Last seen today at ' + timeStr;
  if (d.toDateString() === yesterday.toDateString()) return 'Last seen yesterday at ' + timeStr;
  return 'Last seen ' + d.toLocaleDateString([], { day: 'numeric', month: 'short', year: 'numeric' }) + ' at ' + timeStr;
}

function subscribeToPresenceFor(chatKey) {
  // remove previous listener
  if (statusListener && statusListener.ref) {
    try { statusListener.ref.off('value', statusListener.callback); } catch(e) {}
    statusListener = null;
  }

  const typingEl = document.getElementById('typingIndicator');
  const userLogo = document.getElementById('userLogo');
  if (!typingEl) return;

  const statusRef = db.ref('status/' + chatKey);
  const callback = snap => {
    const statusObj = snap.val();
    let typing = false;
    let state = 'offline';
    let last_changed = null;

    if (statusObj) {
      if (typeof statusObj === 'object') {
        typing = !!statusObj.typing;
        state = statusObj.state || state;
        last_changed = statusObj.last_changed || null;
      } else if (typeof statusObj === 'string') {
        state = statusObj;
      }
    }

    // Show in same div
    if (typing) {
      typingEl.style.display = 'block';
      typingEl.textContent = 'typing…';
      typingEl.style.color = ''; // inherit or keep your css
      if (userLogo) userLogo.style.border = '3px solid green';
    } else {
      // not typing: online or last seen
      typingEl.style.display = 'block';
      if (state === 'online') {
        typingEl.textContent = 'online';
        typingEl.style.color = ''; // use CSS color or inline if you like
        if (userLogo) userLogo.style.border = '3px solid green';
      } else {
        typingEl.textContent = formatLastSeen(last_changed);
        typingEl.style.color = '';
        if (userLogo) userLogo.style.border = '3px solid orange';
      }
    }
  };

  statusListener = { ref: statusRef, callback };
  statusRef.on('value', callback);
}

// Ensure we subscribe when opening a chat
const oldOpenChat_forPresence = openChat;
openChat = function(key) {
  oldOpenChat_forPresence(key);
  // key in your app is the DB key (looks like you already use underscores)
  subscribeToPresenceFor(key);
};

// Optional: cleanup listener when going back to inbox
const oldPop = window.onpopstate;
window.addEventListener('popstate', function(event) {
  // remove presence listener when leaving chat view
  if (statusListener && statusListener.ref) {
    try { statusListener.ref.off('value', statusListener.callback); } catch(e) {}
    statusListener = null;
  }
  // also hide the typingIndicator when leaving
  const typingEl = document.getElementById('typingIndicator');
  if (typingEl) typingEl.style.display = 'none';

  if (typeof oldPop === 'function') oldPop(event);
});

/* ===== improved presence helper =====
   Replace your current setPresence(...) function with this.
*/




let _presenceHeartbeat = null;


function adjustMessagesPadding(){
  const input = document.getElementById('inputArea');
  const messages = document.getElementById('messages');
  if(!input || !messages) return;
  // add extra spacing for safe area
  const extra = 16;
  messages.style.paddingBottom = (input.offsetHeight + extra) + 'px';
}

// run on load and whenever window resizes or input changes
window.addEventListener('load', adjustMessagesPadding);
window.addEventListener('resize', adjustMessagesPadding);

// if your textarea auto-resizes, call adjustMessagesPadding on input
const txt = document.getElementById('replyInput');
if(txt){
  txt.addEventListener('input', function(){ 
    // if you have an auto-height script, run it first then adjust
    setTimeout(adjustMessagesPadding, 60);
  });
}


function linkify(text) {
  if (!text) return '';
  
  // Regular expression to match URLs
  const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
  
  // Replace URLs with anchor tags
  return text.replace(urlRegex, function(url) {
    // Shorten display text for long URLs (like WhatsApp does)
    const displayUrl = url.length > 30 ? url.substring(0, 27) + '...' : url;
    return '<a href="' + url + '" target="_blank" rel="noopener noreferrer" class="message-link">' + displayUrl + '</a>';
  });
}


function setPresence(userKey) {
  if (!userKey) return;
  const userStatusRef = db.ref('status/' + userKey);

  const makeOffline = () => ({
    state: 'offline',
    last_changed: Date.now(),
  });
  const makeOnline = () => ({
    state: 'online',
    last_changed: Date.now(),
  });

  // Clear any previous heartbeat
  if (_presenceHeartbeat) {
    clearInterval(_presenceHeartbeat);
    _presenceHeartbeat = null;
  }

  // Listen for connection status to RTDB servers
  db.ref('.info/connected').on('value', (snap) => {
    if (snap.val() === true) {
      // Ensure server will set offline when this client truly disconnects
      userStatusRef.onDisconnect().set(makeOffline()).catch(()=>{});

      // Immediately mark online
      userStatusRef.set(makeOnline()).catch(()=>{});

      // Start heartbeat to continually update last_changed so server
      // will not mark connection idle. 10s is a good compromise.
      if (!_presenceHeartbeat) {
        _presenceHeartbeat = setInterval(() => {
          userStatusRef.update({ last_changed: Date.now(), state: 'online' }).catch(()=>{});
        }, 5000);
      }
    } else {
      // not connected -> clear heartbeat
      if (_presenceHeartbeat) {
        clearInterval(_presenceHeartbeat);
        _presenceHeartbeat = null;
      }
    }
  });

  // Best-effort attempt to mark offline on page unload using beacon
  window.addEventListener('unload', () => {
    try {
      // Try to use onDisconnect as main line; sendBeacon is fallback
      const payload = JSON.stringify(makeOffline());
      // Using REST endpoint would be ideal, but as a fallback use sendBeacon to a small cloud function
      // Here we attempt a tiny write via navigator.sendBeacon to a special endpoint if you have one.
      // Fallback: attempt a synchronous set (sometimes fails)
      userStatusRef.set(makeOffline());
    } catch (e) {
      // ignore
    }
  });
}

// Call it like this:
setPresence("brother");




let typingTimeout;

replyInput.addEventListener("input", () => {
  // Mark brother as typing
  db.ref("status/brother/typing").set(true);
  
  // Reset after 2 seconds of no input
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    db.ref("status/brother/typing").set(false);
  }, 900);
});
const searchBox = document.getElementById('searchBox');
const replyPreviewContainer = document.getElementById('replyPreviewContainer');

// Instead of listening to your own typing status:
const typingIndicator = document.getElementById('typingIndicator');

// use a single place to derive the DB key from the email
const currentUserEmail = "mahekj05@gmail.com";
const currentUserKey = currentUserEmail.replace(/\./g, '_');

// listen for typing under the same key used elsewhere
db.ref('status/' + currentUserKey + '/typing').on('value', (snapshot) => {
  const isTyping = snapshot.val();
  typingIndicator.style.display = isTyping ? 'block' : 'none';
});

let currentKey = null;
let childListener = null;
let allChats = [];
let replyToText = null;
let searchTimeout;

// --- Infinite scroll variables ---
let isLoadingOlderMessages = false;
let hasMoreMessages = true;
let oldestLoadedTimestamp = null;

// --- Infinite scroll ---
let oldestLoadedKey = null;
let isLoadingOlder = false;
let reachedBeginning = false;

// --- Store messages ---
let messageStore = {};
let lastRenderedDate = null; 
let lastRenderedMsgTime = 0;
let initialLoadDone = false;
// global tracker// *** FIX: Track last date divider ***

// --- Cache helpers ---
function cacheChats(data) { localStorage.setItem('cachedChats', JSON.stringify(data)); }
function getCachedChats() { const c = localStorage.getItem('cachedChats'); return c ? JSON.parse(c) : null; }





function getCachedMessages(chatKey) { const c = localStorage.getItem('chat_' + chatKey); return c ? JSON.parse(c) : null; }

// --- Load cached chats ---
const cached = getCachedChats();
if (cached) renderChats(cached);

db.ref('chats').on('value', snapshot => {
  const chats = snapshot.val();
  if (chats) { cacheChats(chats); renderChats(chats); }
});


// use the correct brotherKey
function renderChats(chats) {
  chatList.innerHTML = '';
  allChats = [];
  const sortedKeys = Object.keys(chats).sort((a,b)=>{
    const lastA = Math.max(...Object.keys(chats[a]).map(Number));
    const lastB = Math.max(...Object.keys(chats[b]).map(Number));
    return lastB - lastA;
  });
  sortedKeys.forEach(key=>{
    const messages = chats[key];
    const timestamps = Object.keys(messages).map(Number).sort((a,b)=>a-b);
    const lastMsg = messages[timestamps[timestamps.length-1]];
    const lastTime = new Date(timestamps[timestamps.length-1]).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', hour12:true});
    
    
    const item = document.createElement('div');
    item.className = 'chat-item';
    item.onclick = ()=>openChat(key);
    const name = document.createElement('div'); name.className = 'chat-name'; name.textContent = key.replace(/_/g,'.');
    const preview = document.createElement('div'); preview.className = 'chat-preview'; preview.textContent = lastMsg.text;
    
    const event = new CustomEvent('chatOpened', { detail: key });
window.dispatchEvent(event);
    
    const time = document.createElement('div'); time.className = 'chat-time'; time.textContent = lastTime;
    item.appendChild(name); item.appendChild(preview); item.appendChild(time);
    chatList.appendChild(item);
    allChats.push({ key, element:item, preview:lastMsg.text });
  });
}

// --- Search ---
function filterChats(){
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(()=>{
    const term = searchBox.value.toLowerCase();
    allChats.forEach(chat=>{
      chat.element.style.display =
        chat.key.toLowerCase().includes(term) || chat.preview.toLowerCase().includes(term) ? '' : 'none';
    });
  },200);
}




// --- Date dividers ---
function formatDateSeparator(ts){
  const msgDate = new Date(Number(ts));
  const today = new Date();
  const yesterday = new Date(); yesterday.setDate(today.getDate()-1);
  if(msgDate.toDateString()===today.toDateString()) return "Today";
  else if(msgDate.toDateString()===yesterday.toDateString()) return "Yesterday";
  else return msgDate.toLocaleDateString([], { day:"numeric", month:"short", year:"numeric" });
}

function createDateDivider(label){
  const div = document.createElement("div");
  div.className = "date-divider";
  div.textContent = label;
  return div;
}


function highlightAndScrollTo(msgKey) {
  if (!msgKey) return;
  // prefer id format first
  const id = 'msg_' + msgKey;
  let target = document.getElementById(id);
  if (!target) {
    // fallback to data attribute
    target = document.querySelector('[data-msg-key="' + msgKey + '"]');
  }
  if (!target) {
    // If message not rendered yet, try small retry (best-effort)
    let tries = 0;
    const retry = setInterval(() => {
      tries++;
      let t = document.getElementById(id) || document.querySelector('[data-msg-key="' + msgKey + '"]');
      if (t) {
        clearInterval(retry);
        t.scrollIntoView({ behavior: 'smooth', block: 'center' });
        t.classList.add('message-highlight');
        setTimeout(() => t.classList.remove('message-highlight'), 2200);
      } else if (tries > 8) {
        clearInterval(retry);
        console.warn('Referenced message not found in DOM:', msgKey);
      }
    }, 150);
    return;
  }
  
  // scroll and highlight
  try {
    target.scrollIntoView({ behavior: 'smooth', block: 'center' });
  } catch (e) {
    target.scrollIntoView();
  }
  target.classList.add('message-highlight');
  // remove highlight after a short while
  setTimeout(() => {
    target && target.classList.remove('message-highlight');
  }, 2200);
}

function buildMessageBubble(msgKey, val) {
  // create bubble wrapper & classes
  const div = document.createElement('div');
  div.className = 'bubble ' + (val.from === 'user' ? 'from-user' : 'from-brother');
  
  // reply arrow (swipe UI)
  const arrow = document.createElement('div');
  arrow.className = 'reply-arrow';
  arrow.innerHTML = '↩';
  div.appendChild(arrow);
  
  // attach swipe/reply behavior (re-uses your helper)
  attachSwipeHandlers(div, msgKey, val.text || val.url || '');
  
  // reply preview if present
  if (val.replyTo && messageStore[val.replyTo]) {
    const replyDiv = document.createElement('div');
    replyDiv.className = 'reply-box';
    // if the referenced message had text use it, otherwise if media show type
    const ref = messageStore[val.replyTo];
    replyDiv.textContent = ref && ref.text ? ref.text : (ref && ref.type ? '[' + (ref.type || 'media') + ']' : '');
    div.prepend(replyDiv);
  }
  
  // If media (gif/image) -> render image tag, allow optional text underneath
  if (val.type === 'gif' || val.type === 'image' || val.url) {
    const media = document.createElement('img');
    media.style.maxWidth = '260px';
    media.style.maxHeight = '260px';
    media.style.borderRadius = '8px';
    media.style.display = 'block';
    media.style.marginBottom = '6px';
    // prefer val.url; some payloads may include url or mediaUrl
    media.src = val.url || val.mediaUrl || '';
    media.alt = val.type || 'media';
    // add error handler to help debug CORS/missing URL
    media.addEventListener('error', () => {
      const err = document.createElement('div');
      err.style.fontSize = '12px';
      err.style.color = '#b00';
      err.textContent = '[Unable to load media]';
      div.insertBefore(err, media.nextSibling);
    });
    div.appendChild(media);
    if (val.text) {
  const textNode = document.createElement('div');
  textNode.innerHTML = linkify(val.text);
  div.appendChild(textNode);
}
  } else {
    // regular text-only message
    // text message
const textNode = document.createElement('div');
textNode.innerHTML = linkify(val.text || '');
div.appendChild(textNode);
  }
  
  // timestamp
  const timeNode = document.createElement('div');
  timeNode.className = 'msg-time';
  timeNode.textContent = new Date(Number(msgKey)).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
  div.appendChild(timeNode);
  
  return div;
}


// ensure the local name points to the same function used in renderMessages
buildMessageBubble = window.buildMessageBubble;

// --- Render messages (fixed) ---




// Replace your entire openChat function with this optimized version
function openChat(key) {
  listEl.classList.remove('active');
  chatEl.classList.add('active');
  
  // Reset state
  currentKey = key;
  document.getElementById('chatTitle').textContent = "Bubu😘";
  history.pushState({screen: "chat"}, "Chat");

  messageStore = {};
  lastRenderedDate = null;
  lastRenderedMsgTime = 0;
  messagesEl.innerHTML = '';
  initialLoadDone = false;
  
  // Reset infinite scroll variables
  isLoadingOlderMessages = false;
  hasMoreMessages = true;
  oldestLoadedTimestamp = null;

  // Show loading indicator
  messagesEl.innerHTML = '<div class="loading-indicator">Loading messages...</div>';
  
  // Load cached messages first for immediate display
  const cachedMsgs = getCachedMessages(key);
  if (cachedMsgs) {
    processAndRenderMessages(cachedMsgs);
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
  
  // Set up real-time listener with optimized query
  if (childListener) {
    db.ref('chats/' + currentKey).off('value', childListener);
  }
  
  childListener = db.ref('chats/' + currentKey)
    .orderByKey()
    .limitToLast(100) // Only get the most recent 100 messages initially
    .on('value', snap => {
      const msgs = snap.val();
      if (msgs) {
        cacheMessages(currentKey, msgs);
        processAndRenderMessages(msgs);
        
        // Remove loading indicator if it exists
        const loadingIndicator = messagesEl.querySelector('.loading-indicator');
        if (loadingIndicator) {
          messagesEl.removeChild(loadingIndicator);
        }
      }
    });
    
  // Add scroll event listener for infinite scroll
  messagesEl.addEventListener('scroll', handleScroll);
}

// Replace your renderMessages function with this optimized version
function processAndRenderMessages(messages) {
  if (!messages) return;
  
  // Convert to array and sort by timestamp
  const messageArray = Object.entries(messages)
    .map(([key, value]) => ({ key: Number(key), value }))
    .sort((a, b) => a.key - b.key); // Sort by timestamp (ascending order)
  
  const fragment = document.createDocumentFragment();
  let addedNewMessages = false;
  
  messageArray.forEach(({ key, value }) => {
    const msgKey = String(key);
    const val = value;
    
    if (!val || (!val.text && !val.type && !val.url)) return;
    
    // Check if this message is already rendered
    const existingMsg = document.getElementById('msg_' + msgKey) || 
                       document.querySelector('[data-msg-key="' + msgKey + '"]');
    if (existingMsg) return;
    
    // Add to messageStore
    messageStore[msgKey] = val;
    
    const msgDate = new Date(key);
    const dateLabel = formatDateSeparator(msgKey);
    
    // Date divider
    if (lastRenderedDate !== msgDate.toDateString()) {
      fragment.appendChild(createDateDivider(dateLabel));
      lastRenderedDate = msgDate.toDateString();
    }
    
    const div = buildMessageBubble(msgKey, val);
    fragment.appendChild(div);
    addedNewMessages = true;
    
    // Play sound only for new incoming messages
    if (initialLoadDone && val.from === "user" && key > lastRenderedMsgTime) {
      const snd = document.getElementById("receiveSound");
      if (snd) snd.play().catch(() => {});
    }
    
    // Update last seen
    if (key > lastRenderedMsgTime) {
      lastRenderedMsgTime = key;
    }
  });
  
  if (addedNewMessages) {
    messagesEl.appendChild(fragment);
    
    // Only scroll to bottom if we're not loading older messages and it's a new message
    if (!isLoadingOlderMessages) {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }
  }
  
  // Mark first load as done
  initialLoadDone = true;
}

// Update your cacheMessages function to maintain proper order
function cacheMessages(chatKey, data) {
  if (!data) return;
  
  // Get all message keys and sort them (newest first)
  const keys = Object.keys(data).map(Number).sort((a, b) => b - a);
  
  // Take only the latest 300 messages but maintain order
  if (keys.length > 300) {
    const limitedData = {};
    
    // Get the 300 newest messages but store them in chronological order
    keys.slice(0, 300)
      .sort((a, b) => a - b) // Sort in ascending order for proper caching
      .forEach(key => {
        limitedData[key] = data[key];
      });
      
    localStorage.setItem('chat_' + chatKey, JSON.stringify(limitedData));
  } else {
    localStorage.setItem('chat_' + chatKey, JSON.stringify(data));
  }
}

// Optimized function to load older messages
async function loadOlderMessages() {
  if (!currentKey || isLoadingOlderMessages || !hasMoreMessages) return;
  
  isLoadingOlderMessages = true;
  
  try {
    // Show loading indicator at the top
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'loading-indicator';
    loadingDiv.textContent = 'Loading older messages...';
    messagesEl.insertBefore(loadingDiv, messagesEl.firstChild);
    
    // Get the oldest timestamp we have loaded
    const messageKeys = Object.keys(messageStore).map(Number);
    const oldestKey = oldestLoadedTimestamp || Math.min(...messageKeys);
    
    // Query Firebase for older messages
    const snapshot = await db.ref('chats/' + currentKey)
      .orderByKey()
      .endBefore(String(oldestKey))
      .limitToLast(50)
      .once('value');
    
    const olderMessages = snapshot.val();
    
    if (!olderMessages || Object.keys(olderMessages).length === 0) {
      hasMoreMessages = false;
      loadingDiv.textContent = 'No older messages';
      setTimeout(() => {
        if (loadingDiv.parentNode === messagesEl) {
          messagesEl.removeChild(loadingDiv);
        }
      }, 2000);
      return;
    }
    
    // Add older messages to messageStore
    Object.assign(messageStore, olderMessages);
    
    // Render older messages at the top
    renderOlderMessages(olderMessages);
    
    // Update oldest loaded timestamp
    const olderKeys = Object.keys(olderMessages).map(Number);
    oldestLoadedTimestamp = Math.min(...olderKeys);
    
    // Remove loading indicator
    if (loadingDiv.parentNode === messagesEl) {
      messagesEl.removeChild(loadingDiv);
    }
    
  } catch (error) {
    console.error('Error loading older messages:', error);
    const loadingDiv = messagesEl.querySelector('.loading-indicator');
    if (loadingDiv && loadingDiv.parentNode === messagesEl) {
      loadingDiv.textContent = 'Error loading messages';
      setTimeout(() => {
        if (loadingDiv.parentNode === messagesEl) {
          messagesEl.removeChild(loadingDiv);
        }
      }, 2000);
    }
  } finally {
    isLoadingOlderMessages = false;
  }
}


// Optimized function to render older messages
function renderOlderMessages(messages) {
  // Convert to array and sort by timestamp
  const messageArray = Object.entries(messages)
    .map(([key, value]) => ({ key: Number(key), value }))
    .sort((a, b) => a.key - b.key); // Sort by timestamp (ascending order)
  
  const fragment = document.createDocumentFragment();
  let currentDate = null;
  
  messageArray.forEach(({ key, value }) => {
    const msgKey = String(key);
    const val = value;
    
    if (!val || (!val.text && !val.type && !val.url)) return;
    
    const msgDate = new Date(key);
    const dateLabel = formatDateSeparator(msgKey);
    
    // Date divider
    if (currentDate !== msgDate.toDateString()) {
      fragment.appendChild(createDateDivider(dateLabel));
      currentDate = msgDate.toDateString();
    }
    
    const div = buildMessageBubble(msgKey, val);
    fragment.appendChild(div);
  });
  
  // Get first child to insert before
  const firstChild = messagesEl.firstChild;
  messagesEl.insertBefore(fragment, firstChild);
}
//script set 






// --- Send reply ---
function sendReply(){
  const text = replyInput.value.trim();
  if(text==='' || !currentKey) return;
  const timestamp = Date.now();
  const message = {text,from:'brother'};
  if(replyToText){message.replyTo = replyToText.msgKey; replyToText=null;}
  
  db.ref('chats/'+currentKey+'/'+timestamp).set(message);
  db.ref("status/brother/typing").set(false); // stop typing

  document.getElementById("sendSound").play();
  
  replyInput.value='';
  replyInput.style.height="auto";
  replyInput.focus();
  replyPreviewContainer.innerHTML='';
}



// --- Swipe & reply handlers ---
function attachSwipeHandlers(bubbleEl,msgKey,text){
  let startX=0,startY=0,currentX=0,dragging=false,vibrated=false;
  bubbleEl.addEventListener('touchstart',e=>{
    // Don't start swipe if clicking on a link
    if (e.target.closest('.message-link')) return;
    
    startX=e.touches[0].clientX; 
    startY=e.touches[0].clientY; 
    dragging=true; 
    vibrated=false; 
    bubbleEl.style.transition="none";
  });
  bubbleEl.addEventListener('touchmove', e => {
      if (!dragging) return;
      
      // Don't process swipe if clicking on a link
      if (e.target.closest('.message-link')) {
        dragging = false;
        return;
      }
      
      currentX = e.touches[0].clientX - startX;
      const dy = e.touches[0].clientY - startY;
      if (Math.abs(dy) > 30) return;  
      const offset=Math.sign(currentX)*Math.min(Math.abs(currentX),120);
    bubbleEl.style.transform=`translateX(${offset}px)`;
    if(Math.abs(offset)>50 && !bubbleEl.classList.contains("show-arrow")){
      bubbleEl.classList.add("show-arrow");
      if(!vibrated && navigator.vibrate){navigator.vibrate([80,50,80]);vibrated=true;}
    } else bubbleEl.classList.remove("show-arrow");
  });
  bubbleEl.addEventListener('touchend',()=>{
    dragging=false; bubbleEl.style.transition="transform 0.2s ease"; bubbleEl.classList.remove("show-arrow");
    if(Math.abs(currentX)>80){
      replyToText={msgKey,text};
      replyPreviewContainer.innerHTML=`<div class="reply-preview"><div class="reply-preview-text">${text}</div><button onclick="cancelReply()">✖</button></div>`;
      replyInput.focus();
    }
    bubbleEl.style.transform="translateX(0px)"; currentX=0;
  });
}

function cancelReply(){replyToText=null; replyPreviewContainer.innerHTML=''; replyInput.placeholder='Type a message…';}
replyInput.addEventListener('blur',()=>{if(!replyInput.value && !replyToText) cancelReply();});

// --- Dark mode ---
// --- Dark mode ---
const darkModeToggle = document.getElementById("darkModeToggle");
const themeMeta = document.getElementById("theme-color-meta");

function updateThemeColor() {
  if (document.body.classList.contains("dark")) {
    themeMeta.setAttribute("content", "#121212"); // dark mode color
  } else {
    themeMeta.setAttribute("content", "#DDF2ED"); // light mode color
  }
}




// On load, check saved mode
if (localStorage.getItem("darkMode") === "enabled") {
  document.body.classList.add("dark");
  darkModeToggle.textContent = "☀️";
}
updateThemeColor();

// Toggle button click
darkModeToggle.addEventListener("click", () => {
  document.body.classList.toggle("dark");
  if (document.body.classList.contains("dark")) {
    localStorage.setItem("darkMode", "enabled");
    darkModeToggle.textContent = "☀️";
  } else {
    localStorage.setItem("darkMode", "disabled");
    darkModeToggle.textContent = "🌙";
  }
  updateThemeColor();
});




window.addEventListener("popstate", function(event) {
  if (chatEl.classList.contains('active')) {
    chatEl.classList.remove('active');
    listEl.classList.add('active');
    currentKey = null;
  } else {
    history.back();
  }
});
</script>




<script>
  // ensure this runs after firebase.initializeApp(...) and after "const db = firebase.database();"
  const userEmail = "mahekj05@gmail.com";
  const userKey = userEmail.replace(/\./g, '_');
  
  // debug helper
  db.ref('.info/connected').on('value', snap => {
    console.log('DEBUG: .info/connected =>', snap.val());
  });
  
  // call setPresence that you already defined (or add below if missing)
  
  
  // For UI: update avatar border on status changes (you already have similar code)
  db.ref('status/' + userKey).on('value', snapshot => {
    const status = snapshot.val();
    console.log('DEBUG: status snapshot', status);
    const userLogo = document.getElementById('userLogo');
    if (!userLogo) return;
    let state = null;
    if (status && typeof status === 'object') state = status.state;
    else state = status;
    userLogo.style.border = (state === 'online') ? '3px solid green' : '3px solid orange';
  });
</script>
<style>
.chat-item {
  position: relative; /* Important for absolute badge positioning */
}
.unread-badge {
  position: absolute;
  top: 40px;
  right: 20px;
  background: #25D366; /* WhatsApp green */
  color: white;
  font-size: 12px;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 12px;
  min-width: 18px;
  text-align: center;
  display: inline-block; /* Show by default for testing */
}
</style>
<script>
// --- UNREAD BADGES & LAST SEEN TRACKING ---
let unreadCounts = {}; // store counts per chat key
let lastSeen = {};     // store last seen timestamp per chat

// --- Load/Save last seen from localStorage ---
function saveLastSeen() {
  localStorage.setItem('lastSeen', JSON.stringify(lastSeen));
}
function loadLastSeen() {
  const data = localStorage.getItem('lastSeen');
  if (data) lastSeen = JSON.parse(data);
}
loadLastSeen();

// --- Render chats and show badges ---
const oldRenderChats = renderChats;
renderChats = function(chats) {
  oldRenderChats(chats); // call original renderChats
  Object.keys(chats).forEach(key => {
    const item = allChats.find(c => c.key === key)?.element;
    if (item) {
      let badge = item.querySelector('.unread-badge');
      if (!badge) {
        badge = document.createElement('span');
        badge.className = 'unread-badge';
        item.appendChild(badge);
      }
      badge.textContent = unreadCounts[key] || 0;
      badge.style.display = (unreadCounts[key] || 0) > 0 ? 'inline-block' : 'none';
    }
  });
};

// --- Reset unread count when opening a chat ---
const oldOpenChat = openChat;
openChat = function(key) {
  unreadCounts[key] = 0;
  lastSeen[key] = Date.now();
  saveLastSeen();
  renderChats(getCachedChats() || {});
  oldOpenChat(key);
};

// --- Listen for new messages (child_added and child_changed) ---
db.ref('chats').on('child_added', snap => {
  const chatKey = snap.key;
  const msgs = snap.val();
  const lastKey = Math.max(...Object.keys(msgs).map(Number));
  const lastMsg = msgs[lastKey];
  const seenTime = lastSeen[chatKey] || 0;

  if (lastMsg.from === 'user' && lastKey > seenTime && chatKey !== currentKey) {
    unreadCounts[chatKey] = (unreadCounts[chatKey] || 0) + 1;
    renderChats(getCachedChats() || {});
  }
});

db.ref('chats').on('child_changed', snap => {
  const chatKey = snap.key;
  const msgs = snap.val();
  const lastKey = Math.max(...Object.keys(msgs).map(Number));
  const lastMsg = msgs[lastKey];
  const seenTime = lastSeen[chatKey] || 0;

  if (lastMsg.from === 'user' && lastKey > seenTime && chatKey !== currentKey) {
    unreadCounts[chatKey] = (unreadCounts[chatKey] || 0) + 1;
    renderChats(getCachedChats() || {});
  }
});
  // When going back to inbox, badges will already be updated
</script>
<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker
        .register("./service-worker.js")
        .then((reg) => console.log("Service Worker registered:", reg.scope))
        .catch((err) => console.error("Service Worker failed:", err));
    });
  }
</script>
  <script>
    // Prevent pinch zoom
    document.addEventListener('touchmove', function(event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
    }, { passive: false });
    
    // Prevent double-tap zoom
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, { passive: false });
  </script>

<script>
/* ===== Configuration ===== */
// Add your GIPHY API key here:
/* ===== Tenor configuration ===== */
// Get a Tenor API key: (Google Cloud Console -> enable Tenor API & create key)
const TENOR_API_KEY = "AIzaSyB_R_WfxdRYAnMCykNpxDAAJRqKkjpgUTs"; // <-- replace with your key
const TENOR_CLIENT_KEY = "brother dashboard"; // optional string identifying your app (use same value for all calls) // <-- get one at https://developers.giphy.com/ (free)

/* ===== Emoji picker setup using emoji-button ===== */
const { EmojiButton } = window;
let picker;
try{
  picker = new EmojiButton({ position: 'top-end', zIndex: 99999 });
  const emojiBtn = document.getElementById('emojiBtn');
  const replyInput = document.getElementById('replyInput');

  emojiBtn.addEventListener('click', () => {
    picker.togglePicker(emojiBtn);
  });

  picker.on('emoji', selection => {
    // Insert emoji at cursor position in textarea
    insertAtCursor(replyInput, selection.emoji);
    replyInput.focus();
  });
} catch(e){
  console.warn("Emoji picker failed to load:", e);
}

/* helper: insert at cursor for textarea */
function insertAtCursor(input, text) {
  const start = input.selectionStart || 0;
  const end = input.selectionEnd || 0;
  const value = input.value || '';
  input.value = value.slice(0, start) + text + value.slice(end);
  // move cursor after inserted text
  const newPos = start + text.length;
  input.selectionStart = input.selectionEnd = newPos;
  input.dispatchEvent(new Event('input'));
}

/* ===== GIF picker modal + search ===== */
const gifBtn = document.getElementById('gifBtn');
const gifModal = document.getElementById('gifModal');
const gifSearch = document.getElementById('gifSearch');
const gifSearchBtn = document.getElementById('gifSearchBtn');
const gifResults = document.getElementById('gifResults');
const gifCloseBtn = document.getElementById('gifCloseBtn');

gifBtn.addEventListener('click', () => {
  console.log("GIF button clicked");
  gifModal.style.display = 'flex';
  searchTenor('trending');
});

gifCloseBtn.addEventListener('click', () => {
  gifModal.style.display = 'none';
  gifModal.setAttribute('aria-hidden','true');
});

gifSearchBtn.addEventListener('click', () => {
  const q = gifSearch.value.trim();
  if (!q) return;
  searchTenor(q);
});

async function searchTenor(query) {
  gifResults.innerHTML = 'Loading…';
  try {
    let url;
    const encoded = encodeURIComponent(query || '');
    // Trending / featured
    if (query === 'trending' || !query) {
      url = `https://tenor.googleapis.com/v2/featured?key=${TENOR_API_KEY}&client_key=${TENOR_CLIENT_KEY}&limit=25&contentfilter=low`;
    } else {
      // Search endpoint
      url = `https://tenor.googleapis.com/v2/search?q=${encoded}&key=${TENOR_API_KEY}&client_key=${TENOR_CLIENT_KEY}&limit=25&contentfilter=low`;
    }
    
    const res = await fetch(url);
    if (!res.ok) throw new Error('Tenor fetch failed: ' + res.status);
    const json = await res.json();
    
    gifResults.innerHTML = '';
    
    const results = json.results || [];
    results.forEach(r => {
      // defensive: pick a small preview format first (nanogif / tinygif), then fallback
      const mf = r.media_formats || {};
      const preview =
        (mf.nanogif && mf.nanogif.url) ||
        (mf.tinygif && mf.tinygif.url) ||
        (mf.nanowebp && mf.nanowebp.url) ||
        (mf.gif && mf.gif.url) ||
        null;
      
      // pick the share/full url (prefer full gif)
      const full =
        (mf.gif && mf.gif.url) ||
        (mf.mediumgif && mf.mediumgif.url) ||
        (mf.nanowebp && mf.nanowebp.url) ||
        preview;
      
      if (!preview) return; // no usable preview -> skip
      
      const img = document.createElement('img');
      img.className = 'gif-thumb';
      img.src = preview;
      img.alt = r.content_description || r.id || 'gif';
      
      img.addEventListener('click', () => {
        // send selected GIF as media message (your existing helper)
        sendMediaMessage({ type: 'gif', url: full });
        
        // optional: register the share with Tenor to improve search relevancy
        // (don't block UI on this; fire-and-forget)
        try {
          fetch(`https://tenor.googleapis.com/v2/registershare?id=${r.id}&key=${TENOR_API_KEY}&client_key=${TENOR_CLIENT_KEY}&q=${encoded}`)
            .catch(() => {});
        } catch (e) {}
        
        gifModal.style.display = 'none';
      });
      
      gifResults.appendChild(img);
    });
    
    if (results.length === 0) gifResults.innerHTML = 'No GIFs found.';
  } catch (err) {
    console.error('Tenor search error', err);
    gifResults.innerHTML = 'Search failed.';
  }
}

/* ===== Attach/file input (optional) ===== */
const attachBtn = document.getElementById('attachBtn');
const attachFile = document.getElementById('attachFile');

attachBtn.addEventListener('click', () => attachFile.click());


/* ===== Image compression helper (compress to approx target size and return dataURL) ===== */

function blobToDataURL(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

function imageBitmapOrImgFromFile(file) {
  // returns a Promise that resolves with an object {bitmap, width, height}
  if (window.createImageBitmap) {
    return createImageBitmap(file).then(bitmap => ({ bitmap, width: bitmap.width, height: bitmap.height }));
  } else {
    // fallback for older browsers
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        // draw into an offscreen canvas to create an ImageBitmap equivalent
        resolve({ img, width: img.naturalWidth, height: img.naturalHeight });
      };
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }
}

function canvasToBlob(canvas, quality) {
  return new Promise((resolve) => {
    canvas.toBlob(blob => resolve(blob), 'image/jpeg', quality);
  });
}

/**
 * Compress a File/Blob image to an approximate target size (KB).
 * Returns a Promise<string> resolving to a dataURL (JPEG).
 *
 * @param {File|Blob} file - source image file
 * @param {number} targetKb - desired max size in kilobytes (e.g. 200)
 * @param {object} opts - optional { maxWidth, maxHeight, minQuality }
 */
async function compressImageFile(file, targetKb = 200, opts = {}) {
  const maxWidth = opts.maxWidth || 1920;
  const maxHeight = opts.maxHeight || 1920;
  const minQuality = (opts.minQuality !== undefined) ? opts.minQuality : 0.45;
  
  // Load image (bitmap or img)
  const imgObj = await imageBitmapOrImgFromFile(file);
  let srcWidth = imgObj.width;
  let srcHeight = imgObj.height;
  
  // compute initial scale to fit maxWidth/maxHeight
  let scale = Math.min(1, maxWidth / srcWidth, maxHeight / srcHeight);
  let targetWidth = Math.round(srcWidth * scale);
  let targetHeight = Math.round(srcHeight * scale);
  
  // create canvas
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // helper to draw (bitmap or img) into canvas with current dims
  function drawToCanvas() {
    canvas.width = targetWidth;
    canvas.height = targetHeight;
    // if we have a bitmap use drawImage(bitmap,...)
    if (imgObj.bitmap) {
      ctx.drawImage(imgObj.bitmap, 0, 0, targetWidth, targetHeight);
    } else if (imgObj.img) {
      ctx.drawImage(imgObj.img, 0, 0, targetWidth, targetHeight);
    }
  }
  
  // iterative quality reduction loop, optionally downscale if quality floor hits
  let quality = 0.92;
  let blob = null;
  let dataUrl = null;
  const targetBytes = targetKb * 1024;
  
  // try multiple attempts: reduce quality first, then scale down if needed
  for (let attempt = 0; attempt < 8; attempt++) {
    drawToCanvas();
    blob = await canvasToBlob(canvas, quality);
    if (!blob) break;
    if (blob.size <= targetBytes || quality <= minQuality) {
      dataUrl = await blobToDataURL(blob);
      if (blob.size <= targetBytes) return dataUrl;
      // if we hit minQuality but still too big — we'll scale down image and try again
    }
    
    // if blob is too big, reduce quality
    if (blob.size > targetBytes) {
      // lower quality step
      quality = quality - 0.12;
      if (quality < minQuality) quality = minQuality;
    }
    
    // if at minimum quality and still large, scale down the dimensions by 0.85 and retry
    if (quality <= minQuality && blob.size > targetBytes) {
      targetWidth = Math.max(200, Math.round(targetWidth * 0.85));
      targetHeight = Math.max(200, Math.round(targetHeight * 0.85));
      // reset quality to a reasonable value for next loop
      quality = Math.max(minQuality, 0.82);
    }
  }
  
  // final fallback: return the last generated dataURL even if slightly larger than target
  if (blob) dataUrl = await blobToDataURL(blob);
  return dataUrl;
}

/* ===== Replace attachFile handling to compress before sending ===== */
attachFile.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  // Only compress images (not gifs/videos). GIFs you may want to pass through as-is.
  if (!f.type.startsWith('image/')) {
    // fallback: send as-is (or handle video differently)
    const reader = new FileReader();
    reader.onload = function(ev) {
      sendMediaMessage({ type: 'image', url: ev.target.result });
    };
    reader.readAsDataURL(f);
    attachFile.value = '';
    return;
  }
  
  try {
    // compress to ~200 KB
    const compressedDataUrl = await compressImageFile(f, 200, { maxWidth: 1600, maxHeight: 1600 });
    if (compressedDataUrl) {
      sendMediaMessage({ type: 'image', url: compressedDataUrl });
    } else {
      // fallback if compression failed
      const reader = new FileReader();
      reader.onload = function(ev) {
        sendMediaMessage({ type: 'image', url: ev.target.result });
      };
      reader.readAsDataURL(f);
    }
  } catch (err) {
    console.error('Image compression failed', err);
    // fallback send original as dataURL (beware of DB size)
    const reader = new FileReader();
    reader.onload = function(ev) {
      sendMediaMessage({ type: 'image', url: ev.target.result });
    };
    reader.readAsDataURL(f);
  }
  attachFile.value = '';
});

/* ===== Paste handler: compress pasted image blob before sending ===== */
document.addEventListener('paste', async (e) => {
  const items = e.clipboardData && e.clipboardData.items;
  if (!items) return;
  for (const it of items) {
    if (it.kind === 'file') {
      const blob = it.getAsFile();
      if (blob && blob.type.startsWith('image/')) {
        try {
          const compressed = await compressImageFile(blob, 200, { maxWidth: 1600, maxHeight: 1600 });
          if (compressed) sendMediaMessage({ type: 'image', url: compressed });
        } catch (err) {
          console.error('Paste compression failed', err);
          // fallback to sending original
          const reader = new FileReader();
          reader.onload = (ev) => sendMediaMessage({ type: 'image', url: ev.target.result });
          reader.readAsDataURL(blob);
        }
        e.preventDefault();
        return;
      }
    }
    if (it.kind === 'string' && it.type === 'text/plain') {
      it.getAsString(str => {
        if (str.match(/\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || str.includes('giphy.com')) {
          // unchanged for URLs
          sendMediaMessage({ type: 'gif', url: str });
        }
      });
    }
  }
});


/* ===== Paste handler for image/GIF URLs or direct images ===== */
document.addEventListener('paste', (e) => {
  // If clipboard contains an image file, or URL
  const items = e.clipboardData && e.clipboardData.items;
  if(!items) return;
  for (const it of items) {
    if (it.kind === 'file') {
      const blob = it.getAsFile();
      if (blob) {
        // File pasted -> read and send as dataURL (or upload to Storage in production)
        const reader = new FileReader();
        reader.onload = (ev) => sendMediaMessage({ type: 'image', url: ev.target.result });
        reader.readAsDataURL(blob);
        e.preventDefault();
        return;
      }
    }
    if (it.kind === 'string' && it.type === 'text/plain') {
      it.getAsString(str => {
        // if user pasted a giphy or image URL, send as gif/image
        if (str.match(/\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || str.includes('giphy.com')) {
          sendMediaMessage({ type: 'gif', url: str });
        }
      });
    }
  }
});

/* ===== sendMediaMessage helper =====
   Sends a chat message object to your DB with type and url.
*/
function sendMediaMessage(payload){
  // payload = { type: 'gif' | 'image', url: '...' }
  if(!currentKey) { alert('Open a chat first'); return; }
  const timestamp = Date.now();
  const message = { from: 'brother', type: payload.type, url: payload.url };
  // optionally include replyTo
  if(replyToText){ message.replyTo = replyToText.msgKey; replyToText=null; replyPreviewContainer.innerHTML=''; }
  db.ref('chats/' + currentKey + '/' + timestamp).set(message);
  document.getElementById("sendSound").play().catch(()=>{});
}

/* ===== Override send button to allow sending text or GIF/image URLs typed in ===== */
document.getElementById('sendBtn').addEventListener('click', sendReply);

const originalSendReply = window.sendReply || function(){};
window.sendReply = function(){
  const txtEl = document.getElementById('replyInput');
  const text = (txtEl.value || '').trim();
  if(!currentKey) return;
  if(!text && !replyToText) return; // nothing to send
  // if text is a direct image/GIF URL, send as media
  if(text.match(/^https?:\/\/.*\.(gif|png|jpg|jpeg|webp)(\?.*)?$/i) || text.includes('giphy.com')) {
    sendMediaMessage({ type: 'gif', url: text });
    txtEl.value = '';
    return;
  }
  // else send as regular text
  const timestamp = Date.now();
  const message = { text, from:'brother' };
  if(replyToText){message.replyTo = replyToText.msgKey; replyToText=null; replyPreviewContainer.innerHTML='';}
  db.ref('chats/'+currentKey+'/'+timestamp).set(message);
  db.ref("status/brother/typing").set(false);
  try{ document.getElementById("sendSound").play(); }catch(e){}
  txtEl.value='';
  txtEl.style.height="auto";
  txtEl.focus();
};

/* ===== Render GIF / image in message bubble =====
   Modify your existing buildMessageBubble to handle `val.type === 'gif'` or `val.type === 'image'`.
   If you already have buildMessageBubble defined above, replace the rendering part with the snippet below.
*/
window.buildMessageBubble = function(msgKey, val) {
  const div = document.createElement('div');
  div.className = 'bubble ' + (val.from === 'user' ? 'from-user' : 'from-brother');
  div.setAttribute('data-msg-key', String(msgKey));
  div.id = 'msg_' + String(msgKey);
  div.style.position = 'relative'; // needed for media menu
  
  // reply arrow
  const arrow = document.createElement('div');
  arrow.className = 'reply-arrow';
  arrow.innerHTML = '↩';
  div.appendChild(arrow);
  attachSwipeHandlers(div, msgKey, val.text || '');
  
  // reply preview
  if (val.replyTo && messageStore[val.replyTo]) {
    const replyDiv = document.createElement('div');
    replyDiv.className = 'reply-box';
    const referenced = messageStore[val.replyTo];
    if (referenced && referenced.text) {
  const truncatedText = referenced.text.length > 120 ?
    referenced.text.slice(0, 120) + '…' : referenced.text;
  replyDiv.innerHTML = linkify(truncatedText);
} else {
  replyDiv.textContent = '[media]';
}
    
    replyDiv.addEventListener('click', (e) => {
      e.stopPropagation();
      e.stopImmediatePropagation(); // prevent long-press interference
      highlightAndScrollTo(val.replyTo);
    });
    
    div.prepend(replyDiv);
  }
  
  // media (image/gif)
  if (val.type === 'gif' || val.type === 'image') {
    const media = document.createElement('img');
    media.style.maxWidth = '100%';
    media.style.maxHeight = '260px';
    media.style.borderRadius = '8px';
    media.style.display = 'block';
    media.style.marginBottom = '6px';
    media.src = val.url;
    media.alt = val.type;
    div.appendChild(media);
    
    // ⋮ menu for media
    const menuBtn = document.createElement('button');
    menuBtn.innerHTML = '⋮';
    menuBtn.className = 'menu-btn';
    menuBtn.style.position = 'absolute';
    menuBtn.style.top = '6px';
    menuBtn.style.right = '6px';
    menuBtn.style.background = 'transparent';
    menuBtn.style.border = 'none';
    menuBtn.style.fontSize = '18px';
    menuBtn.style.cursor = 'pointer';
    
    const menu = createDeleteMenu(msgKey);
    div.appendChild(menu);
    
    menuBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      menu.style.display = (menu.style.display === 'none') ? 'block' : 'none';
    });
    
    document.addEventListener('click', () => { menu.style.display = 'none'; });
    div.appendChild(menuBtn);
    
    if (val.text) {
  const textNode = document.createElement('div');
  textNode.innerHTML = linkify(val.text);
  div.appendChild(textNode);
}
    
} else {
  // text message
  const textNode = document.createElement('div');
  textNode.innerHTML = linkify(val.text || '');
  div.appendChild(textNode);
  
  // long press support - modified to ignore link clicks
  let pressTimer;
  const startPress = (e) => {
    // Don't start long press if clicking on a link or reply box
    if (e.target.closest('.message-link') || e.target.closest('.reply-box')) return;
    
    e.preventDefault();
    pressTimer = setTimeout(() => {
      if (confirm('Delete this message?')) {
        const chatKey = currentKey;
        db.ref('chats/' + chatKey + '/' + msgKey).remove()
          .then(() => console.log('Text deleted:', msgKey))
          .catch(err => console.error('Failed to delete text:', err));
      }
    }, 700);
  };
    const cancelPress = () => clearTimeout(pressTimer);
    
    div.addEventListener('mousedown', startPress);
    div.addEventListener('mouseup', cancelPress);
    div.addEventListener('mouseleave', cancelPress);
    div.addEventListener('touchstart', startPress);
    div.addEventListener('touchend', cancelPress);
    div.addEventListener('touchmove', cancelPress);
  }
  
  // timestamp
  const timeNode = document.createElement('div');
  timeNode.className = 'msg-time';
  timeNode.textContent = new Date(Number(msgKey)).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
  div.appendChild(timeNode);
  
  return div;
};

// helper to create delete menu for media
function createDeleteMenu(msgKey) {
  const menu = document.createElement('div');
  menu.className = 'menu-popup';
  menu.style.position = 'absolute';
  menu.style.top = '28px';
  menu.style.right = '6px';
  menu.style.background = 'grey';
  menu.style.border = '1px solid #ccc';
  menu.style.borderRadius = '6px';
  menu.style.padding = '4px 0';
  menu.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
  menu.style.display = 'none';
  menu.style.zIndex = 100;
  
  const delOption = document.createElement('div');
  delOption.textContent = 'Delete';
  delOption.style.padding = '6px 12px';
  delOption.style.cursor = 'pointer';
  delOption.addEventListener('mouseover', () => { delOption.style.background = '#f0f0f0'; });
  delOption.addEventListener('mouseout', () => { delOption.style.background = 'transparent'; });
  
  delOption.addEventListener('click', (e) => {
    e.stopPropagation();
    menu.style.display = 'none';
    if (!confirm('Delete this message?')) return;
    const chatKey = currentKey;
    db.ref('chats/' + chatKey + '/' + msgKey).remove()
      .then(() => console.log('Deleted:', msgKey))
      .catch(err => console.error('Failed to delete:', err));
  });
  
  menu.appendChild(delOption);
  return menu;
}
</script>
<script>
  //highlight reply bubble 
  
  
  function highlightAndScrollTo(msgKey) {
  if (!msgKey) return;
  const id = 'msg_' + msgKey;
  let target = document.getElementById(id) || document.querySelector('[data-msg-key="'+msgKey+'"]');
  if (!target) return;

  target.scrollIntoView({ behavior: 'smooth', block: 'center' });

  // Apply grey/orange highlight temporarily
  target.classList.add('message-highlight');
  setTimeout(() => {
    target.classList.remove('message-highlight');
  }, 2000);
}
</script>
<!-- your existing page content -->



  <!-- LIGHTBOX MARKUP -->
  <div id="lightbox" class="lightbox" aria-hidden="true" style="background: black;">
    <div class="inner" role="dialog" aria-modal="true">
      <button class="btn close" aria-label="Close"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"
     xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Back">
  <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round"/>
</svg></button>
      <button class="btn prev" aria-label="Previous">
        
        <svg width="130" height="44" viewBox="0 0 160 44" xmlns="http://www.w3.org/2000/svg"
     role="img" aria-label="Download">
  <g fill="none">
    <rect x="1" y="1" width="108" height="42" rx="22" fill="currentColor" opacity="0.08" stroke="currentColor"/>


    <!-- Text -->
    <text x="20" y="27" font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial" font-size="18"
          fill="currentColor">Previous</text>
  </g>
</svg></button>
      <div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center;">
        <img id="lightboxImg" src="" alt="" />
      </div>
      <button class="btn next" aria-label="Next">
              <svg width="130" height="44" viewBox="0 0 160 44" xmlns="http://www.w3.org/2000/svg"
     role="img" aria-label="Download">
  <g fill="none">
    <rect x="1" y="1" width="108" height="42" rx="22" fill="currentColor" opacity="0.08" stroke="currentColor"/>
    <!-- Text -->
    <text x="35" y="27" font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial" font-size="18"
          fill="currentColor">Next</text>
  </g>
</svg>
      </button>
      <a id="lightboxDownload" class="btn download" aria-label="Download" target="_blank" rel="noopener"><!-- Download button -->
<svg width="130" height="44" viewBox="0 0 160 44" xmlns="http://www.w3.org/2000/svg"
     role="img" aria-label="Download">
  <g fill="none">
    <rect x="1" y="1" width="158" height="42" rx="22" fill="currentColor" opacity="0.08" stroke="currentColor"/>
    <!-- Icon -->
    <g transform="translate(18,10)" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 0v10"/>
      <path d="m7 6 5 5 5-5"/>
      <path d="M3 20h18"/>
    </g>
    <!-- Text -->
    <text x="64" y="27" font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial" font-size="18"
          fill="currentColor">Download</text>
  </g>
</svg></a>
      <div class="counter" id="lightboxCounter"></div>
    </div>
  </div>

  <!-- LIGHTBOX SCRIPT -->
  <script>
  (function(){
    const messagesEl = document.getElementById('messages');
    const lightbox = document.getElementById('lightbox');
    const lImg = document.getElementById('lightboxImg');
    const btnClose = lightbox.querySelector('.close');
    const btnPrev = lightbox.querySelector('.prev');
    const btnNext = lightbox.querySelector('.next');
    const btnDownload = document.getElementById('lightboxDownload');
    const counter = document.getElementById('lightboxCounter');

    let gallery = [], idx = 0;

    function buildGallery(){
      gallery = Array.from(messagesEl.querySelectorAll('img')).map(i=>i.src);
    }
    function openAt(src){
      buildGallery();
      idx = gallery.indexOf(src);
      if(idx === -1) { gallery.unshift(src); idx = 0; }
      show();
    }
    function show(){
      lImg.src = gallery[idx];
      lightbox.classList.add('open');
      btnDownload.href = gallery[idx];
      btnDownload.setAttribute('download','image');
      counter.textContent = (gallery.length>1) ? (idx+1)+' / '+gallery.length : '';
    }
    function close(){ lightbox.classList.remove('open'); }
    function prev(){ idx=(idx-1+gallery.length)%gallery.length; show(); }
    function next(){ idx=(idx+1)%gallery.length; show(); }

    messagesEl.addEventListener('click', e=>{
      const img=e.target.closest('img');
      if(img) openAt(img.src);
    });
    btnClose.addEventListener('click', close);
    btnPrev.addEventListener('click', prev);
    btnNext.addEventListener('click', next);
    document.addEventListener('keydown', e=>{
      if(!lightbox.classList.contains('open')) return;
      if(e.key==='Escape') close();
      if(e.key==='ArrowLeft') prev();
      if(e.key==='ArrowRight') next();
    });
  })();
  
  
  // Handle scroll events for infinite scroll
function handleScroll() {
  if (isLoadingOlderMessages || !hasMoreMessages) return;
  
  // Load more messages when scrolled to top
  if (messagesEl.scrollTop < 100) {
    loadOlderMessages();
  }
}

// Function to load older messages


// Function to render older messages at the top
function renderOlderMessages(messages) {
  const sortedKeys = Object.keys(messages).map(Number).sort((a, b) => a - b).map(String);
  const fragment = document.createDocumentFragment();
  
  let currentDate = null;
  
  sortedKeys.forEach(msgKey => {
    const val = messages[msgKey];
    if (!val || (!val.text && !val.type && !val.url)) return;
    
    const msgDate = new Date(Number(msgKey));
    const dateLabel = formatDateSeparator(msgKey);
    
    // Date divider
    if (currentDate !== msgDate.toDateString()) {
      fragment.appendChild(createDateDivider(dateLabel));
      currentDate = msgDate.toDateString();
    }
    
    const div = buildMessageBubble(msgKey, val);
    fragment.appendChild(div);
  });
  
  // Get first child to insert before
  const firstChild = messagesEl.firstChild;
  messagesEl.insertBefore(fragment, firstChild);
}

// Clean up scroll listener when changing chats
const originalOnPopState = window.onpopstate;
window.onpopstate = function(event) {
  messagesEl.removeEventListener('scroll', handleScroll);
  if (originalOnPopState) originalOnPopState(event);
};
  </script>
</body>
</html>
