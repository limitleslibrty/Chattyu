<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Brother Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <script src="firebase-config.js"></script>

  <!-- Preload images for faster UI -->
  <link rel="preload" as="image" href="chat_logo.png">
  <link rel="preload" as="image" href="chat.png">

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html { height: 100%; font-family: 'Segoe UI', sans-serif; background: #f2f3f7; overflow-x: hidden; }

    #list, #chat { display: none; height: 100%; width: 100%; }
    #list.active, #chat.active { display: flex; flex-direction: column; }

    #messages { overflow-x: hidden; }

    #inboxHeader {
      padding: 25px 20px 10px;
      font-size: 28px;
      font-weight: 700;
      
      background: #ffffff;
      background-clip: text;
      color: transparent;
      background-image: linear-gradient(to right, #2563eb, #7c3aed);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      border-bottom: 1px solid #e5e7eb;
    }

    #searchBox {
      margin: 12px 20px 0;
      padding: 10px 15px;
      border-radius: 30px;
      border: 1px solid #ccc;
      outline: none;
      font-size: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.04);
    }

    #list {
      background: linear-gradient(to bottom right, #f4f6f9, #e2e6ec);
      overflow-y: auto;
    }

    .chat-item {
      position: relative;
      background: #ffffff;
      padding: 15px 20px;
      margin: 12px 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .chat-item:hover { background: #e0ecff; transform: translateY(-2px); }
    .chat-name { font-size: 16px; font-weight: 600; color: #333; }
    .chat-preview { font-size: 14px; color: #666; margin-top: 4px; }
    .chat-time {
      position: absolute; right: 20px; top: 18px;
      font-size: 12px; color: #888;
    }
    


    #chatHeader {
      background: #FFFFFF; color: #000000;
      padding: 4px; font-weight: 400; font-size: 18px;
      border-bottom: 1px solid #D2D0CEEB;
      display: flex; align-items: center;
    }

    #messages {
      flex: 1; padding: 10px; overflow-y: auto; display: flex; flex-direction: column;
      background-image: url('chat.png');
      background-size: 110% 110%;
      background-repeat: no-repeat;
      background-position: center;
    }

    .bubble {
    
  white-space: pre-wrap;  
      margin: 6px 0;
      padding: 12px 16px;
      border-radius: 12px;
      max-width: 75%;
      font-size: 16px;
      line-height: 1.4;
      position: relative;
      word-wrap: break-word;
      will-change: transform;
    }

    .from-user { background: #ffffff; align-self: flex-start; }
    .from-brother { background: #dcf8c6; align-self: flex-end; }

    .msg-time {
      font-size: 10px; color: #555; margin-top: 4px; align-self: flex-end;
    }

    .reply-box {
      font-size: 13px;
      color: #555;
      background: rgba(0,0,0,0.05);
      padding: 6px 10px;
      border-left: 4px solid #888;
      margin-bottom: 6px;
      border-radius: 4px;
    }

    #inputArea {
      display: flex; padding: 10px; background: #fff; border-top: 1px solid #ccc;
      flex-direction: column;
    }
    .reply-preview {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f0f0f0;
      padding: 6px 10px;
      border-left: 4px solid #4caf50;
      border-radius: 6px;
      font-size: 13px;
      margin-bottom: 6px;
      color: #333;
    }
    .reply-preview-text {
      flex: 1;
      white-space: normal;
      overflow: hidden;
      max-height: 3.2em;
    }
    .reply-preview button {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: #888;
    }

    #inputControls { display: flex; align-items: flex-end; }
    #inputControls textarea {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #ccc;
      border-radius: 20px;
      resize: none;
      overflow: hidden;
      font-size: 15px;
      line-height: 1.4;
      max-height: 120px;
    }
    #inputControls textarea:focus {
      border-color: #bbb;
      outline: none;
    }
    #inputControls button {
      margin-left: 10px; padding: 8px 16px;
      background: #075E54; color: #fff; border: none; border-radius: 20px;
    }

    .reply-arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      transition: opacity 0.2s ease;
      font-size: 18px;
      color: #4caf50;
    }
    .from-user .reply-arrow { left: -28px; }
    .from-brother .reply-arrow { right: -28px; }
    .bubble.show-arrow .reply-arrow { opacity: 1; }
    
    
    
    
    /* 🌙 DARK MODE FIX */
body.dark {
  background: #121212 !important;
  color: #e5e5e5 !important;
}

/* Inbox header */
body.dark #inboxHeader {
  background-image: linear-gradient(to right, #9333ea, #3b82f6) !important;
  color: #ffffff !important;
}




/* Inbox chat items (dark mode) */
body.dark .chat-item {
  background: #2a2a2a;          /* dark gray card */
  color: #fff;                  /* default text = white */
}

body.dark .chat-item .chat-name {
  color: #ffffff;               /* pure white for names */
}

body.dark .chat-item .chat-preview {
  color: #bbbbbb;               /* softer gray for preview */
}

body.dark .chat-item .chat-time {
  color: #888888;               /* dim gray for timestamp */
}


/* Chat list */
body.dark #list {
  background: #1e1e1e !important;
}

body.dark .chat-item {
  background: #2a2a2a !important;
  color: #ffffff !important;   /* chat list names = pure white */
}

body.dark .chat-item:hover {
  background: #333 !important;
}

body.dark .chat-item small,
body.dark .chat-item .preview {
  color: #cccccc !important; /* slightly brighter gray */
}

/* Chat header */
body.dark #chatHeader {
  background: #1e1e1e !important;
  color: #ffffff !important;
}

/* Messages area */
body.dark #messages {
  background: #121212 !important;
}

/* User bubbles */
body.dark .from-user {
  background: #2a2a2a !important;
  color: #ffffff !important;
}

/* Brother bubbles */
body.dark .from-brother {
  background: #056162 !important;
  color: #ffffff !important;
}

/* Chat bubble timestamp */
body.dark .msg-time {
  font-size: 11px !important;
  color: #ffffff !important;   /* full white */
  text-align: right !important;
  margin-top: 4px !important;
  display: block !important;
}


/* Reply box (dark mode) */
body.dark .reply-box {
  color: #e5e5e5;
  background: rgba(255,255,255,0.08);  /* soft white overlay */
  border-left: 3px solid #3b82f6;      /* nice blue accent */
}
/* Input area */
body.dark #inputArea {
  background: #1e1e1e !important;
}

body.dark #inputControls textarea {
  background: #2a2a2a !important;
  color: #ffffff !important;
  border: 1px solid #444 !important;
}

body.dark #inputControls button {
  background: #3b82f6 !important;
  color: #ffffff !important;
}
    /* Reply preview (dark mode) */
body.dark .reply-preview {
  background: rgba(255, 255, 255, 0.08);  /* soft overlay on dark */
  border-left: 4px solid #3b82f6;         /* blue accent */
  color: #e5e5e5;
}

    /* Toggle button base */
#darkModeToggle {
  margin-left: auto;
  margin-right: 10px;
  padding: 6px 14px;
  border-radius: 20px;
  border: none;
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  transition: all 0.3s ease;
}

/* Light mode toggle */
body:not(.dark) #darkModeToggle {
background: #FFFFFF;   /* light gray */
  color: #111;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);

  
}

/* Dark mode toggle */
body.dark #darkModeToggle {
  background: #2a2a2a;   /* dark gray */
  color: #facc15;        /* warm yellow (sun icon) */
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

/* Hover effect */
#darkModeToggle:hover {
  transform: scale(1.05);
}
    
    
    
    
    
    
    
    
  </style>
</head>
<body>
  <div id="list" class="active">
    <div id="inboxHeader" style="margin-left: 10px;">S talk</div>
    <input type="text" id="searchBox" placeholder="Search chats..." oninput="filterChats()" />
    <div id="chatList"></div>
  </div>

  <div id="chat">
    <div id="chatHeader">
      <img src="chat_logo.png" alt="loading" height="40px" width="40px" style="border-radius:100%;margin-left: 10px;" />
      <div style="margin-left:10px;" id="chatTitle">Chat</div>
      <button id="darkModeToggle" >
  🌙
</button>
    </div>
    <div id="messages"></div>
    <div id="inputArea">
      <div id="replyPreviewContainer"></div>
      <div id="inputControls">
        <textarea id="replyInput" placeholder="Type a message…" rows="1"></textarea>
        <button onclick="sendReply()">Send</button>
      </div>
    </div>
  </div>

<script>
  const db = firebase.database();
  const listEl = document.getElementById('list');
  const chatEl = document.getElementById('chat');
  const chatList = document.getElementById('chatList');
  const messagesEl = document.getElementById('messages');
  const replyInput = document.getElementById('replyInput');
  const searchBox = document.getElementById('searchBox');
  const replyPreviewContainer = document.getElementById('replyPreviewContainer');
  let currentKey = null;
  let childListener = null;
  let allChats = [];
  let replyToText = null;
  let searchTimeout;

  // --- Infinite scroll state (added) ---
  let oldestLoadedKey = null;
  let isLoadingOlder = false;
  let reachedBeginning = false;

  // Store all loaded messages for the open chat so reply boxes work (added)
  let messageStore = {};

  // ✅ Caching helpers
  function cacheChats(data) { localStorage.setItem('cachedChats', JSON.stringify(data)); }
  function getCachedChats() { const c = localStorage.getItem('cachedChats'); return c ? JSON.parse(c) : null; }
  function cacheMessages(chatKey, data) { localStorage.setItem('chat_' + chatKey, JSON.stringify(data)); }
  function getCachedMessages(chatKey) { const c = localStorage.getItem('chat_' + chatKey); return c ? JSON.parse(c) : null; }

  // ✅ Load cached chats first
  const cached = getCachedChats();
  if (cached) renderChats(cached);

  db.ref('chats').on('value', snapshot => {
    const chats = snapshot.val();
    if (chats) { cacheChats(chats); renderChats(chats); }
  });

  function renderChats(chats) {
    chatList.innerHTML = '';
    allChats = [];
    const sortedKeys = Object.keys(chats).sort((a, b) => {
      const lastA = Math.max(...Object.keys(chats[a]).map(Number));
      const lastB = Math.max(...Object.keys(chats[b]).map(Number));
      return lastB - lastA;
    });
    sortedKeys.forEach(key => {
      const messages = chats[key];
      const timestamps = Object.keys(messages).sort();
      const lastMsg = messages[timestamps[timestamps.length - 1]];
      const lastTime = new Date(parseInt(timestamps[timestamps.length - 1])).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
      const item = document.createElement('div');
      item.className = 'chat-item'; item.onclick = () => openChat(key);
      const name = document.createElement('div'); name.className = 'chat-name'; name.textContent = key.replace(/_/g, '.');
      const preview = document.createElement('div'); preview.className = 'chat-preview'; preview.textContent = lastMsg.text;
      const time = document.createElement('div'); time.className = 'chat-time'; time.textContent = lastTime;
      item.appendChild(name); item.appendChild(preview); item.appendChild(time);
      chatList.appendChild(item);
      allChats.push({ key, element: item, preview: lastMsg.text });
    });
  }

  // ✅ Debounced search
  function filterChats() {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
      const term = searchBox.value.toLowerCase();
      allChats.forEach(chat => {
        chat.element.style.display =
          chat.key.toLowerCase().includes(term) || chat.preview.toLowerCase().includes(term)
            ? ''
            : 'none';
      });
    }, 200);
  }

  // ✅ Render only last 30 messages
  function renderMessages(chatKey, messages, limit = 30) {
    messagesEl.innerHTML = '';
    messageStore = { ...messages }; // keep a copy for reply lookups (added)
    const sortedKeys = Object.keys(messages).sort((a, b) => a - b);
    const recent = sortedKeys.slice(-limit);

    // set infinite-scroll anchors (added)
    oldestLoadedKey = recent.length ? recent[0] : null;
    reachedBeginning = !oldestLoadedKey;

    recent.forEach(msgKey => {
      const val = messages[msgKey];
      if (!val || !val.text) return;
      const div = document.createElement('div');
      div.className = 'bubble ' + (val.from === 'user' ? 'from-user' : 'from-brother');

      const arrow = document.createElement('div');
      arrow.className = 'reply-arrow';
      arrow.innerHTML = '↩';
      div.appendChild(arrow);

      attachSwipeHandlers(div, msgKey, val.text);

      if (val.replyTo && messageStore[val.replyTo]) {
        const replyDiv = document.createElement('div');
        replyDiv.className = 'reply-box';
        replyDiv.textContent = messageStore[val.replyTo].text;
        div.prepend(replyDiv);
      }
      const textNode = document.createElement('div'); textNode.textContent = val.text; div.appendChild(textNode);
      const timeNode = document.createElement('div'); timeNode.className = 'msg-time'; timeNode.textContent = new Date(parseInt(msgKey)).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
      div.appendChild(timeNode);
      messagesEl.appendChild(div);
    });
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  function openChat(key) {
    listEl.classList.remove('active'); chatEl.classList.add('active');
    currentKey = key; document.getElementById('chatTitle').textContent = "Babu😘";
    history.pushState({ screen: "chat" }, "Chat");

    // reset infinite scroll flags (added)
    oldestLoadedKey = null;
    isLoadingOlder = false;
    reachedBeginning = false;

    const cachedMsgs = getCachedMessages(key);
    if (cachedMsgs) renderMessages(key, cachedMsgs);

    if (childListener) db.ref('chats/' + currentKey).off('value', childListener);
    childListener = db.ref('chats/' + currentKey)
      .limitToLast(30) // ✅ load only recent messages
      .on('value', snap => {
        const msgs = snap.val();
        if (msgs) {
          cacheMessages(currentKey, msgs);
          renderMessages(currentKey, msgs);
        }
      });
  }

  function sendReply() {
    const text = replyInput.value.trim();
    if (text === '' || !currentKey) return;

    const timestamp = Date.now();
    const message = { text, from: 'brother' };

    if (replyToText) {
      message.replyTo = replyToText.msgKey;
      replyToText = null;
    }

    db.ref('chats/' + currentKey + '/' + timestamp).set(message);

    replyInput.value = '';
    replyInput.style.height = "auto";
    replyInput.focus();
    replyPreviewContainer.innerHTML = '';
  }



  // Allow Enter to create new line, only button sends
replyInput.addEventListener("keydown", function(e) {
  if (e.key === "Enter") {
    // auto-resize the box as new lines are added
    setTimeout(() => {
      this.style.height = "auto";
      this.style.height = this.scrollHeight + "px";
    }, 0);
  }
});



  replyInput.addEventListener("input", function () {
    this.style.height = "auto";
    this.style.height = (this.scrollHeight) + "px";
  });

  function attachSwipeHandlers(bubbleEl, msgKey, text) {
    let startX = 0, startY = 0, currentX = 0;
    let dragging = false, vibrated = false;

    bubbleEl.addEventListener("touchstart", e => {
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      dragging = true;
      vibrated = false;
      bubbleEl.style.transition = "none";
    });

    bubbleEl.addEventListener("touchmove", e => {
      if (!dragging) return;
      currentX = e.touches[0].clientX - startX;
      const dy = e.touches[0].clientY - startY;
      if (Math.abs(dy) > 30) return;

      const offset = Math.sign(currentX) * Math.min(Math.abs(currentX), 120);
      bubbleEl.style.transform = `translateX(${offset}px)`;

      if (Math.abs(offset) > 50) {
        if (!bubbleEl.classList.contains("show-arrow")) {
          bubbleEl.classList.add("show-arrow");
          if (!vibrated && navigator.vibrate) {
            navigator.vibrate([80, 50, 80]);
            vibrated = true;
          }
        }
      } else {
        bubbleEl.classList.remove("show-arrow");
      }
    });

    bubbleEl.addEventListener("touchend", () => {
      dragging = false;
      bubbleEl.style.transition = "transform 0.2s ease";
      bubbleEl.classList.remove("show-arrow");

      if (Math.abs(currentX) > 80) {
        replyToText = { msgKey, text };
        replyPreviewContainer.innerHTML = `
          <div class="reply-preview">
            <div class="reply-preview-text">${text}</div>
            <button onclick="cancelReply()">✖</button>
          </div>`;
        replyInput.focus();
      }
      bubbleEl.style.transform = "translateX(0px)";
      currentX = 0;
    });
  }

  function cancelReply() {
    replyToText = null;
    replyPreviewContainer.innerHTML = '';
    replyInput.placeholder = 'Type a message…';
  }

  replyInput.addEventListener('blur', () => {
    if (!replyInput.value && !replyToText) cancelReply();
  });

  history.replaceState({ screen: "list" }, "Inbox");
  window.onpopstate = function(event) {
    if (event.state && event.state.screen === "list") {
      chatEl.classList.remove('active');
      listEl.classList.add('active');
      cancelReply();
    }
  };

// ===== Infinite Scroll: load older messages on scroll top (improved) =====
messagesEl.addEventListener('scroll', () => {
  if (messagesEl.scrollTop < 80 && !isLoadingOlder) {
    loadOlderMessages();
  }
});

  async function loadOlderMessages() {
    if (!currentKey || isLoadingOlder || reachedBeginning || !oldestLoadedKey) return;
    isLoadingOlder = true;

    try {
      // Get 31 so we can drop the overlapping last item (oldestLoadedKey)
      const snap = await db.ref('chats/' + currentKey)
        .orderByKey()
        .endAt(String(oldestLoadedKey))
        .limitToLast(31)
        .once('value');

      const olderChunk = snap.val() || {};
      const keys = Object.keys(olderChunk).sort((a, b) => a - b);

      // Remove the overlapping newest key (which equals current oldestLoadedKey)
      const slice = keys.slice(0, Math.max(0, keys.length - 1));

      if (slice.length === 0 || keys.length < 31) {
  reachedBeginning = true;
  isLoadingOlder = false;
  return;
}

      // Preserve scroll position
      const prevHeight = messagesEl.scrollHeight;

      // Merge into store so reply boxes can resolve text
      slice.forEach(k => { messageStore[k] = olderChunk[k]; });

      // Create and prepend DOM nodes in chronological order
      slice.forEach(msgKey => {
        const val = olderChunk[msgKey];
        if (!val || !val.text) return;

        const div = document.createElement('div');
        div.className = 'bubble ' + (val.from === 'user' ? 'from-user' : 'from-brother');

        const arrow = document.createElement('div');
        arrow.className = 'reply-arrow';
        arrow.innerHTML = '↩';
        div.appendChild(arrow);

        attachSwipeHandlers(div, msgKey, val.text);

        if (val.replyTo && messageStore[val.replyTo]) {
          const replyDiv = document.createElement('div');
          replyDiv.className = 'reply-box';
          replyDiv.textContent = messageStore[val.replyTo].text;
          div.prepend(replyDiv);
        }

        const textNode = document.createElement('div');
        textNode.textContent = val.text;
        div.appendChild(textNode);

        const timeNode = document.createElement('div');
        timeNode.className = 'msg-time';
        timeNode.textContent = new Date(parseInt(msgKey)).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        div.appendChild(timeNode);

        // Prepend to the top
        if (messagesEl.firstChild) {
          messagesEl.insertBefore(div, messagesEl.firstChild);
        } else {
          messagesEl.appendChild(div);
        }
      });

      // Update the anchor to the new oldest key
      oldestLoadedKey = slice[0];

      // Adjust scrollTop so the viewport stays anchored

// Adjust scrollTop so the viewport stays anchored (after DOM paint)
requestAnimationFrame(() => {
  const newHeight = messagesEl.scrollHeight;
  messagesEl.scrollTop = newHeight - prevHeight + messagesEl.scrollTop;
});

      // Optional: also update cache with the newly merged messages
      // (kept off to avoid changing your existing cache flow)
      // cacheMessages(currentKey, messageStore);

    } catch (e) {
      console.error('Failed to load older messages:', e);
    } finally {
      isLoadingOlder = false;
    }
  }
  // ===== End Infinite Scroll additions =====
  
  
//dark mode

// Dark Mode toggle
const darkModeToggle = document.getElementById("darkModeToggle");

// Load preference
if (localStorage.getItem("darkMode") === "enabled") {
  document.body.classList.add("dark");
  darkModeToggle.textContent = "☀️";
}

darkModeToggle.addEventListener("click", () => {
  document.body.classList.toggle("dark");

  if (document.body.classList.contains("dark")) {
    localStorage.setItem("darkMode", "enabled");
    darkModeToggle.textContent = "☀️";
  } else {
    localStorage.setItem("darkMode", "disabled");
    darkModeToggle.textContent = "🌙";
  }
});
</script>
</body>
</html>